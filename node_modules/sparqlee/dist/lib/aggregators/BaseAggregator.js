"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseAggregator = void 0;
const TermTransformer_1 = require("../transformers/TermTransformer");
const Consts_1 = require("../util/Consts");
const TypeHandling_1 = require("../util/TypeHandling");
class BaseAggregator {
    constructor(expr, sharedContext) {
        this.sharedContext = sharedContext;
        this.distinct = expr.distinct;
        this.separator = expr.separator || ' ';
        this.termTransformer = new TermTransformer_1.TermTransformer(sharedContext.superTypeProvider, sharedContext.enableExtendedXsdTypes);
    }
    termToNumericOrError(term) {
        // TODO: Check behaviour
        if (term.termType !== 'Literal') {
            throw new Error(`Term with value ${term.value} has type ${term.termType} and is not a numeric literal`);
        }
        else if (!(0, TypeHandling_1.isSubTypeOf)(term.datatype.value, Consts_1.TypeAlias.SPARQL_NUMERIC, this.sharedContext.superTypeProvider)) {
            throw new Error(`Term datatype ${term.datatype.value} with value ${term.value} has type ${term.termType} and is not a numeric literal`);
        }
        return this.termTransformer.transformLiteral(term);
    }
    extractValue(term) {
        if (term.termType !== 'Literal') {
            throw new Error(`Term with value ${term.value} has type ${term.termType} and is not a literal`);
        }
        const transformedLit = this.termTransformer.transformLiteral(term);
        return { type: transformedLit.dataType, value: transformedLit.typedValue };
    }
    static emptyValue() {
        return undefined;
    }
}
exports.BaseAggregator = BaseAggregator;
//# sourceMappingURL=BaseAggregator.js.map
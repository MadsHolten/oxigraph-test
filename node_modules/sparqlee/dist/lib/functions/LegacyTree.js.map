{"version":3,"file":"LegacyTree.js","sourceRoot":"","sources":["../../../lib/functions/LegacyTree.ts"],"names":[],"mappings":"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","sourcesContent":["import type * as E from '../expressions';\nimport { isLiteralTermExpression } from '../expressions';\nimport { mainSparqlType } from '../util/TypeHandling';\nimport type { ArgumentType, ExperimentalArgumentType } from './Core';\nimport type { ImplementationFunction } from './OverloadTree';\n\ntype SearchStack = LegacyTree[];\ntype LegacyNodeCallback = (node: LegacyTree, argumentType: ArgumentType) => void;\n\n/**\n * Maps argument types on their specific implementation in a tree like structure.\n * When adding any functionality to this class, make sure you add it to SpecialFunctions as well.\n */\nexport class LegacyTree {\n  private implementation?: ImplementationFunction | undefined;\n  private readonly legacyImportance: number;\n  private readonly subTrees: Record<ArgumentType, LegacyTree>;\n\n  public constructor(legacyImportance?: number) {\n    this.implementation = undefined;\n    this.subTrees = Object.create(null);\n    this.legacyImportance = legacyImportance || 0;\n  }\n\n  /**\n   * Searches in a depth first way for the best matching overload. considering this a the tree's root.\n   * @param args\n   */\n  public search(args: E.TermExpression[]): ImplementationFunction | undefined {\n    // SearchStack is a stack of all node's that need to be checked for implementation.\n    // It provides an easy way to keep order in our search.\n    const searchStack: { node: LegacyTree; index: number }[] = [];\n    const startIndex = 0;\n    if (args.length === 0) {\n      return this.implementation;\n    }\n    // GetSubTreeWithArg return a SearchStack containing the node's that should be contacted next.\n    // We also log the index since there is no other way to remember this index.\n    // the provided stack should be pushed on top of our search stack since it also has it's order.\n    searchStack.push(...this.getSubTreeWithArg(args[startIndex]).map(node => ({ node, index: startIndex + 1 })));\n    while (searchStack.length > 0) {\n      const { index, node } = <{ node: LegacyTree; index: number }>searchStack.pop();\n      if (index === args.length) {\n        return node.implementation;\n      }\n      searchStack.push(...node.getSubTreeWithArg(args[index]).map(item =>\n        ({ node: item, index: index + 1 })));\n    }\n    return this.implementation;\n  }\n\n  /**\n   * Adds an overload to the tree structure considering this as the tree's root.\n   * @param argumentTypes a list of ArgumentTypes that would need to be provided in the same order to\n   * get the implementation.\n   * @param func the implementation for this overload.\n   */\n  public addOverload(argumentTypes: ExperimentalArgumentType[], func: ImplementationFunction): void {\n    this._addOverload([ ...argumentTypes ], func, false, 0);\n  }\n\n  public addLegacyOverload(argumentTypes: ExperimentalArgumentType[], func: ImplementationFunction): void {\n    this._addOverload([ ...argumentTypes ], func, true, 0);\n  }\n\n  private _addOverload(argumentTypes: ExperimentalArgumentType[], func: ImplementationFunction,\n    alwaysOverride: boolean, prevPrio: number): void {\n    const [ argumentType, ..._argumentTypes ] = argumentTypes;\n    if (!argumentType) {\n      if (alwaysOverride || this.legacyImportance <= prevPrio) {\n        this.implementation = func;\n      }\n      return;\n    }\n    const holder = mainSparqlType(argumentType);\n    for (const mainType of holder.types) {\n      if (alwaysOverride || !this.subTrees[mainType]) {\n        this.subTrees[mainType] = new LegacyTree(holder.prio);\n      }\n      this.subTrees[mainType]._addOverload(_argumentTypes, func, alwaysOverride, holder.prio);\n    }\n  }\n\n  /**\n   * @param arg term to try and match to possible overloads of this node.\n   * @returns SearchStack a stack with top element the next node that should be asked for implementation or overload.\n   */\n  private getSubTreeWithArg(arg: E.TermExpression): SearchStack {\n    const literalExpression = isLiteralTermExpression(arg);\n    const res: SearchStack = [];\n    // These types refer to Type exported by lib/util/Consts.ts\n    if (this.subTrees.term) {\n      res.push(this.subTrees.term);\n    }\n    // TermTypes are defined in E.TermType.\n    if (this.subTrees[arg.termType]) {\n      res.push(this.subTrees[arg.termType]);\n    }\n    if (literalExpression && this.subTrees[literalExpression.mainSparqlType]) {\n      res.push(this.subTrees[literalExpression.mainSparqlType]);\n    }\n    return res;\n  }\n}\n\n"]}
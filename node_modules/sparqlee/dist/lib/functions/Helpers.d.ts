/**
 * These helpers provide a (albeit inflexible) DSL for writing function
 * definitions for the SPARQL functions.
 */
import type * as RDF from '@rdfjs/types';
import type { ICompleteSharedContext } from '../evaluators/evaluatorHelpers/BaseExpressionEvaluator';
import * as E from '../expressions';
import * as C from '../util/Consts';
import type { ExperimentalArgumentType } from './Core';
import { LegacyTree } from './LegacyTree';
import type { ImplementationFunction } from './OverloadTree';
import { OverloadTree } from './OverloadTree';
declare type Term = E.TermExpression;
export declare function declare(identifier: string): Builder;
export declare class Builder {
    private readonly overloadTree;
    private readonly legacyTree;
    private collected;
    constructor(identifier: string);
    collect(): {
        experimentalTree: OverloadTree;
        tree: LegacyTree;
    };
    set(argTypes: ExperimentalArgumentType[], func: ImplementationFunction): Builder;
    /**
     * A legacy function should be set only after all other functions are set
     * @param argTypes
     * @param func
     */
    setLegacy(argTypes: ExperimentalArgumentType[], func: ImplementationFunction): Builder;
    copy({ from, to }: {
        from: ExperimentalArgumentType[];
        to: ExperimentalArgumentType[];
    }): Builder;
    onUnary<T extends Term>(type: ExperimentalArgumentType, op: (context: ICompleteSharedContext) => (val: T) => Term): Builder;
    onUnaryTyped<T>(type: ExperimentalArgumentType, op: (context: ICompleteSharedContext) => (val: T) => Term): Builder;
    onBinary<L extends Term, R extends Term>(types: ExperimentalArgumentType[], op: (context: ICompleteSharedContext) => (left: L, right: R) => Term): Builder;
    onBinaryTyped<L, R>(types: ExperimentalArgumentType[], op: (context: ICompleteSharedContext) => (left: L, right: R) => Term): Builder;
    onTernaryTyped<A1, A2, A3>(types: ExperimentalArgumentType[], op: (context: ICompleteSharedContext) => (a1: A1, a2: A2, a3: A3) => Term): Builder;
    onTernary<A1 extends Term, A2 extends Term, A3 extends Term>(types: ExperimentalArgumentType[], op: (context: ICompleteSharedContext) => (a1: A1, a2: A2, a3: A3) => Term): Builder;
    onQuaternaryTyped<A1, A2, A3, A4>(types: ExperimentalArgumentType[], op: (context: ICompleteSharedContext) => (a1: A1, a2: A2, a3: A3, a4: A4) => Term): Builder;
    onTerm1(op: (context: ICompleteSharedContext) => (term: Term) => Term): Builder;
    onLiteral1<T>(op: (context: ICompleteSharedContext) => (lit: E.Literal<T>) => Term): Builder;
    onBoolean1(op: (context: ICompleteSharedContext) => (lit: E.BooleanLiteral) => Term): Builder;
    onBoolean1Typed(op: (context: ICompleteSharedContext) => (lit: boolean) => Term): Builder;
    onString1(op: (context: ICompleteSharedContext) => (lit: E.Literal<string>) => Term): Builder;
    onString1Typed(op: (context: ICompleteSharedContext) => (lit: string) => Term): Builder;
    onLangString1(op: (context: ICompleteSharedContext) => (lit: E.LangStringLiteral) => Term): Builder;
    onStringly1(op: (context: ICompleteSharedContext) => (lit: E.Literal<string>) => Term): Builder;
    onStringly1Typed(op: (context: ICompleteSharedContext) => (lit: string) => Term): Builder;
    onNumeric1(op: (context: ICompleteSharedContext) => (val: E.NumericLiteral) => Term): Builder;
    onDateTime1(op: (context: ICompleteSharedContext) => (date: E.DateTimeLiteral) => Term): Builder;
    /**
     * We return the base types and not the provided types because we don't want to create invalid terms.
     * Providing negative number to a function unary - for example should not
     * return a term of type negative number having a positive value.
     * @param op the numeric operator performed
     */
    numericConverter(op: (context: ICompleteSharedContext) => (val: number) => number): Builder;
    private static readonly legacyArithmeticPromotion;
    /**
     * !!! Be aware when using this function, it will create different overloads with different return types !!!
     * Arithmetic operators take 2 numeric arguments, and return a single numerical
     * value. The type of the return value is heavily dependant on the types of the
     * input arguments. In JS everything is a double, but in SPARQL it is not.
     *
     * The different arguments are handled by type promotion and subtype substitution.
     * The way numeric function arguments work is described here:
     * https://www.w3.org/TR/xpath20/#mapping
     * Above url is referenced in the sparql spec: https://www.w3.org/TR/sparql11-query/#OperatorMapping
     */
    arithmetic(op: (context: ICompleteSharedContext) => (left: number, right: number) => number): Builder;
    numberTest(test: (context: ICompleteSharedContext) => (left: number, right: number) => boolean): Builder;
    stringTest(test: (context: ICompleteSharedContext) => (left: string, right: string) => boolean): Builder;
    booleanTest(test: (context: ICompleteSharedContext) => (left: boolean, right: boolean) => boolean): Builder;
    dateTimeTest(test: (context: ICompleteSharedContext) => (left: Date, right: Date) => boolean): Builder;
    numeric(op: ImplementationFunction): Builder;
    invalidLexicalForm(types: ExperimentalArgumentType[], index: number): Builder;
}
export declare function bool(val: boolean): E.BooleanLiteral;
export declare function integer(num: number, dt?: C.KnownLiteralTypes): E.IntegerLiteral;
export declare function decimal(num: number, dt?: C.KnownLiteralTypes): E.DecimalLiteral;
export declare function float(num: number, dt?: C.KnownLiteralTypes): E.FloatLiteral;
export declare function double(num: number, dt?: C.KnownLiteralTypes): E.DoubleLiteral;
export declare function string(str: string): E.StringLiteral;
export declare function langString(str: string, lang: string): E.LangStringLiteral;
export declare function dateTime(date: Date, str: string): E.DateTimeLiteral;
export declare function expressionToVar(variableExpression: E.VariableExpression): RDF.Variable;
export {};

import type * as E from '../expressions';
import type { ExperimentalArgumentType } from './Core';
import type { ImplementationFunction } from './OverloadTree';
/**
 * Maps argument types on their specific implementation in a tree like structure.
 * When adding any functionality to this class, make sure you add it to SpecialFunctions as well.
 */
export declare class LegacyTree {
    private implementation?;
    private readonly legacyImportance;
    private readonly subTrees;
    constructor(legacyImportance?: number);
    /**
     * Searches in a depth first way for the best matching overload. considering this a the tree's root.
     * @param args
     */
    search(args: E.TermExpression[]): ImplementationFunction | undefined;
    /**
     * Adds an overload to the tree structure considering this as the tree's root.
     * @param argumentTypes a list of ArgumentTypes that would need to be provided in the same order to
     * get the implementation.
     * @param func the implementation for this overload.
     */
    addOverload(argumentTypes: ExperimentalArgumentType[], func: ImplementationFunction): void;
    addLegacyOverload(argumentTypes: ExperimentalArgumentType[], func: ImplementationFunction): void;
    private _addOverload;
    /**
     * @param arg term to try and match to possible overloads of this node.
     * @returns SearchStack a stack with top element the next node that should be asked for implementation or overload.
     */
    private getSubTreeWithArg;
}

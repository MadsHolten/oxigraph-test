"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OverloadTree = void 0;
const expressions_1 = require("../expressions");
const Consts_1 = require("../util/Consts");
const TypeHandling_1 = require("../util/TypeHandling");
const Helpers_1 = require("./Helpers");
/**
 * Maps argument types on their specific implementation in a tree like structure.
 * When adding any functionality to this class, make sure you add it to SpecialFunctions as well.
 */
class OverloadTree {
    constructor(identifier, depth) {
        this.identifier = identifier;
        this.implementation = undefined;
        this.generalOverloads = Object.create(null);
        this.literalOverLoads = [];
        this.depth = depth || 0;
        this.promotionCount = undefined;
    }
    getSubtree(overrideType) {
        const generalType = (0, TypeHandling_1.asGeneralType)(overrideType);
        if (generalType) {
            return this.generalOverloads[generalType];
        }
        for (const [type, overloadTree] of this.literalOverLoads) {
            if (overrideType === type) {
                return overloadTree;
            }
        }
        return undefined;
    }
    /**
     * Get the implementation for the types that exactly match @param args .
     */
    getImplementationExact(args) {
        // eslint-disable-next-line @typescript-eslint/no-this-alias,consistent-this
        let node = this;
        for (const expression of args) {
            node = node.getSubtree(expression);
            if (!node) {
                return undefined;
            }
        }
        return node.implementation;
    }
    getOverloadCacheIdentifier(args) {
        return this.identifier + args.map(term => {
            const literalExpression = (0, expressions_1.isLiteralTermExpression)(term);
            return literalExpression ? literalExpression.dataType : term.termType;
        }).join('');
    }
    /**
     * Searches in a depth first way for the best matching overload. considering this a the tree's root.
     * @param args:
     * @param overloadCache
     * @param superTypeProvider
     */
    search(args, superTypeProvider, overloadCache) {
        const identifier = this.getOverloadCacheIdentifier(args);
        if (overloadCache.has(identifier)) {
            return overloadCache.get(identifier);
        }
        // SearchStack is a stack of all node's that need to be checked for implementation.
        // It provides an easy way to keep order in our search.
        const searchStack = [];
        const startIndex = 0;
        if (args.length === 0) {
            return this.implementation;
        }
        // GetSubTreeWithArg return a SearchStack containing the node's that should be contacted next.
        // We also log the index since there is no other way to remember this index.
        // the provided stack should be pushed on top of our search stack since it also has it's order.
        searchStack.push(...this.getSubTreeWithArg(args[startIndex], superTypeProvider).map(node => ({ node, index: startIndex + 1 })));
        while (searchStack.length > 0) {
            const { index, node } = searchStack.pop();
            // We check the implementation because it would be possible a path is created but not implemented.
            // ex: f(double, double, double) and f(term, term). and calling f(double, double).
            if (index === args.length && node.implementation) {
                overloadCache.set(identifier, node.implementation);
                return node.implementation;
            }
            searchStack.push(...node.getSubTreeWithArg(args[index], superTypeProvider).map(item => ({ node: item, index: index + 1 })));
        }
        // Calling a function with one argument but finding no implementation should return no implementation.
        // Not even the one with no arguments.
        overloadCache.set(identifier, undefined);
        return undefined;
    }
    /**
     * Adds an overload to the tree structure considering this as the tree's root.
     * @param ExperimentalArgumentTypes a list of ExperimentalArgumentTypes that would need to be provided in
     * the same order to get the implementation.
     * @param func the implementation for this overload.
     */
    addOverload(ExperimentalArgumentTypes, func) {
        this._addOverload([...ExperimentalArgumentTypes], func, 0);
    }
    _addOverload(ExperimentalArgumentTypes, func, promotionCount) {
        const [experimentalArgumentType, ..._experimentalArgumentTypes] = ExperimentalArgumentTypes;
        if (!experimentalArgumentType) {
            if (this.promotionCount === undefined || promotionCount <= this.promotionCount) {
                this.promotionCount = promotionCount;
                this.implementation = func;
            }
            return;
        }
        let nextTree = this.getSubtree(experimentalArgumentType);
        if (!nextTree) {
            const newNode = new OverloadTree(this.identifier, this.depth + 1);
            const generalType = (0, TypeHandling_1.asGeneralType)(experimentalArgumentType);
            if (generalType) {
                this.generalOverloads[generalType] = newNode;
            }
            const overrideType = (0, TypeHandling_1.asOverrideType)(experimentalArgumentType);
            if (overrideType) {
                this.literalOverLoads.push([overrideType, newNode]);
            }
            nextTree = newNode;
        }
        nextTree._addOverload(_experimentalArgumentTypes, func, promotionCount);
        // Defined by https://www.w3.org/TR/xpath-31/#promotion .
        // e.g. When a function takes a string, it can also accept a XSD_ANY_URI if it's cast first.
        // TODO: When promoting decimal type a cast needs to be preformed.
        if (experimentalArgumentType === Consts_1.TypeURL.XSD_STRING) {
            this.addPromotedOverload(Consts_1.TypeURL.XSD_ANY_URI, func, arg => (0, Helpers_1.string)(arg.str()), _experimentalArgumentTypes, promotionCount);
        }
        // TODO: in case of decimal a round needs to happen.
        if (experimentalArgumentType === Consts_1.TypeURL.XSD_DOUBLE) {
            this.addPromotedOverload(Consts_1.TypeURL.XSD_FLOAT, func, arg => (0, Helpers_1.double)(arg.typedValue), _experimentalArgumentTypes, promotionCount);
            this.addPromotedOverload(Consts_1.TypeURL.XSD_DECIMAL, func, arg => (0, Helpers_1.double)(arg.typedValue), _experimentalArgumentTypes, promotionCount);
        }
        if (experimentalArgumentType === Consts_1.TypeURL.XSD_FLOAT) {
            this.addPromotedOverload(Consts_1.TypeURL.XSD_DECIMAL, func, arg => (0, Helpers_1.float)(arg.typedValue), _experimentalArgumentTypes, promotionCount);
        }
    }
    addPromotedOverload(typeToPromote, func, conversionFunction, ExperimentalArgumentTypes, promotionCount) {
        let nextTree = this.getSubtree(typeToPromote);
        if (!nextTree) {
            const newNode = new OverloadTree(this.identifier, this.depth + 1);
            this.literalOverLoads.push([typeToPromote, newNode]);
            nextTree = newNode;
        }
        nextTree._addOverload(ExperimentalArgumentTypes, funcConf => args => func(funcConf)([
            ...args.slice(0, this.depth),
            conversionFunction(args[this.depth]),
            ...args.slice(this.depth + 1, args.length),
        ]), promotionCount + 1);
    }
    /**
     * @param arg term to try and match to possible overloads of this node.
     * @returns SearchStack a stack with top element the next node that should be asked for implementation or overload.
     */
    getSubTreeWithArg(arg, openWorldType) {
        const res = [];
        const literalExpression = (0, expressions_1.isLiteralTermExpression)(arg);
        // These types refer to Type exported by lib/util/Consts.ts
        if (this.generalOverloads.term) {
            res.push(this.generalOverloads.term);
        }
        // TermTypes are defined in E.TermType.
        if (this.generalOverloads[arg.termType]) {
            res.push(this.generalOverloads[arg.termType]);
        }
        if (literalExpression) {
            // Defending implementation. Mainly the scary sort.
            // This function has cost O(n) + O(m * log(m)) with n = amount of overloads and m = amount of matched overloads
            // We map over each of the overloads, filter only the once that can be used (this is normally 1 or 2).
            // The sort function on an array with 1 or 2 arguments will be negligible.
            const concreteType = (0, TypeHandling_1.asKnownLiteralType)(literalExpression.dataType);
            let subExtensionTable;
            if (concreteType) {
                // Concrete dataType is known by sparqlee.
                subExtensionTable = TypeHandling_1.superTypeDictTable[concreteType];
            }
            else {
                // Datatype is a custom datatype
                subExtensionTable = (0, TypeHandling_1.getSuperTypes)(literalExpression.dataType, openWorldType);
            }
            const matches = this.literalOverLoads.filter(([matchType, _]) => matchType in subExtensionTable)
                .map(([matchType, tree]) => [subExtensionTable[matchType], tree]);
            matches.sort(([prioA, matchTypeA], [prioB, matchTypeB]) => prioA - prioB);
            res.push(...matches.map(([_, sortedType]) => sortedType));
        }
        return res;
    }
}
exports.OverloadTree = OverloadTree;
//# sourceMappingURL=OverloadTree.js.map
{"version":3,"file":"Core.js","sourceRoot":"","sources":["../../../lib/functions/Core.ts"],"names":[],"mappings":"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","sourcesContent":["import type * as RDF from '@rdfjs/types';\nimport type { ICompleteSharedContext } from '../evaluators/evaluatorHelpers/BaseExpressionEvaluator';\nimport type * as E from '../expressions';\nimport type * as C from '../util/Consts';\nimport * as Err from '../util/Errors';\nimport type { ISuperTypeProvider } from '../util/TypeHandling';\nimport type { LegacyTree } from './LegacyTree';\nimport type { ImplementationFunction, OverloadTree, OverLoadCache } from './OverloadTree';\n\nexport interface IEvalSharedContext extends ICompleteSharedContext{\n  args: E.Expression[];\n  mapping: RDF.Bindings;\n}\nexport interface IEvalContext<Term, BNode> extends IEvalSharedContext {\n  bnode?: (input?: string) => BNode;\n  evaluate: (expr: E.Expression, mapping: RDF.Bindings) => Term;\n}\n\nexport type EvalContextAsync = IEvalContext<Promise<E.TermExpression>, Promise<RDF.BlankNode>>;\nexport type EvalContextSync = IEvalContext<E.TermExpression, RDF.BlankNode>;\n\n// ----------------------------------------------------------------------------\n// Overloaded Functions\n// ----------------------------------------------------------------------------\n\n// Function and operator arguments are 'flattened' in the SPARQL spec.\n// If the argument is a literal, the datatype often also matters.\nexport type ExperimentalArgumentType = 'term' | E.TermType | C.TypeURL | C.TypeAlias;\nexport type ArgumentType = 'term' | E.TermType | C.MainSparqlType;\n\nexport interface IOverloadedDefinition {\n  arity: number | number[];\n  overloads: { experimentalTree: OverloadTree; tree: LegacyTree };\n}\n\nexport abstract class BaseFunction<Operator> {\n  public arity: number | number[];\n  private readonly overloads: { experimentalTree: OverloadTree; tree: LegacyTree };\n\n  protected constructor(public operator: Operator, definition: IOverloadedDefinition) {\n    this.arity = definition.arity;\n    this.overloads = definition.overloads;\n  }\n\n  /**\n   * A function application works by monomorphing the function to a specific\n   * instance depending on the runtime types. We then just apply this function\n   * to the args.\n   */\n  public apply = (args: E.TermExpression[], context: ICompleteSharedContext):\n  E.TermExpression => {\n    const concreteFunction =\n      this.monomorph(args, context.superTypeProvider, context.overloadCache, context.enableExtendedXsdTypes) ||\n      this.handleInvalidTypes(args);\n    return concreteFunction(context)(args);\n  };\n\n  protected abstract handleInvalidTypes(args: E.TermExpression[]): never;\n\n  /**\n   * We monomorph by checking the map of overloads for keys corresponding\n   * to the runtime types. We start by checking for an implementation for the\n   * most concrete types (integer, string, date, IRI), if we find none,\n   * we consider their term types (literal, blank, IRI), and lastly we consider\n   * all arguments as generic terms.\n   *\n   * Another option would be to populate the overloads with an implementation\n   * for every concrete type when the function is generic over termtypes or\n   * terms.\n   */\n  private monomorph(args: E.TermExpression[], superTypeProvider: ISuperTypeProvider,\n    overloadCache: OverLoadCache, experimental: boolean): ImplementationFunction | undefined {\n    return experimental ?\n      this.overloads.experimentalTree.search(args, superTypeProvider, overloadCache) :\n      this.overloads.tree.search(args);\n  }\n}\n\n// Regular Functions ----------------------------------------------------------\n\n/**\n * Varying kinds of functions take arguments of different types on which the\n * specific behaviour is dependant. Although their behaviour is often varying,\n * it is always relatively simple, and better suited for synced behaviour.\n * The types of their arguments are always terms, but might differ in\n * their term-type (eg: iri, literal),\n * their specific literal type (eg: string, integer),\n * their arity (see BNODE),\n * or even their specific numeric type (eg: integer, float).\n *\n * Examples include:\n *  - Arithmetic operations such as: *, -, /, +\n *  - Bool operators such as: =, !=, <=, <, ...\n *  - Functions such as: str, IRI\n *\n * See also: https://www.w3.org/TR/sparql11-query/#func-rdfTerms\n * and https://www.w3.org/TR/sparql11-query/#OperatorMapping\n */\nexport class RegularFunction extends BaseFunction<C.RegularOperator> {\n  protected functionClass: 'regular' = 'regular';\n\n  public constructor(op: C.RegularOperator, definition: IOverloadedDefinition) {\n    super(op, definition);\n  }\n\n  protected handleInvalidTypes(args: E.TermExpression[]): never {\n    throw new Err.InvalidArgumentTypes(args, this.operator);\n  }\n}\n\n// Named Functions ------------------------------------------------------------\nexport class NamedFunction extends BaseFunction<C.NamedOperator> {\n  protected functionClass: 'named' = 'named';\n\n  public constructor(op: C.NamedOperator, definition: IOverloadedDefinition) {\n    super(op, definition);\n  }\n\n  protected handleInvalidTypes(args: E.TermExpression[]): never {\n    throw new Err.InvalidArgumentTypes(args, this.operator);\n  }\n}\n\n// Special Functions ----------------------------------------------------------\n/**\n * Special Functions are those that don't really fit in sensible categories and\n * have extremely heterogeneous signatures that make them impossible to abstract\n * over. They are small in number, and their behaviour is often complex and open\n * for multiple correct implementations with different trade-offs.\n *\n * Due to their varying nature, they need all available information present\n * during evaluation. This reflects in the signature of the apply() method.\n *\n * They need access to an evaluator to be able to even implement their logic.\n * Especially relevant for IF, and the logical connectives.\n *\n * They can have both sync and async implementations, and both would make sense\n * in some contexts.\n */\nexport class SpecialFunction {\n  public functionClass: 'special' = 'special';\n  public arity: number;\n  public applySync: E.SpecialApplicationSync;\n  public applyAsync: E.SpecialApplicationAsync;\n  public checkArity: (args: E.Expression[]) => boolean;\n\n  public constructor(public operator: C.SpecialOperator, definition: ISpecialDefinition) {\n    this.arity = definition.arity;\n    this.applySync = definition.applySync;\n    this.applyAsync = definition.applyAsync;\n    this.checkArity = definition.checkArity || defaultArityCheck(this.arity);\n  }\n}\n\nfunction defaultArityCheck(arity: number): (args: E.Expression[]) => boolean {\n  return (args: E.Expression[]): boolean => {\n    // Infinity is used to represent var-args, so it's always correct.\n    if (arity === Number.POSITIVE_INFINITY) {\n      return true;\n    }\n\n    // If the function has overloaded arity, the actual arity needs to be present.\n    if (Array.isArray(arity)) {\n      return arity.includes(args.length);\n    }\n\n    return args.length === arity;\n  };\n}\n\nexport interface ISpecialDefinition {\n  arity: number;\n  applyAsync: E.SpecialApplicationAsync;\n  applySync: E.SpecialApplicationSync;\n  checkArity?: (args: E.Expression[]) => boolean;\n}\n"]}
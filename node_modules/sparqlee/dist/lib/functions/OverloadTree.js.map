{"version":3,"file":"OverloadTree.js","sourceRoot":"","sources":["../../../lib/functions/OverloadTree.ts"],"names":[],"mappings":"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","sourcesContent":["import type * as LRUCache from 'lru-cache';\nimport type { ICompleteSharedContext } from '../evaluators/evaluatorHelpers/BaseExpressionEvaluator';\nimport type * as E from '../expressions';\nimport { isLiteralTermExpression } from '../expressions';\nimport type { KnownLiteralTypes } from '../util/Consts';\nimport { TypeURL } from '../util/Consts';\nimport type { ISuperTypeProvider, OverrideType,\n  GeneralSuperTypeDict } from '../util/TypeHandling';\nimport {\n  superTypeDictTable,\n  getSuperTypes,\n  asKnownLiteralType, asOverrideType, asGeneralType,\n} from '../util/TypeHandling';\nimport type { ExperimentalArgumentType } from './Core';\nimport { double, float, string } from './Helpers';\n\nexport type SearchStack = OverloadTree[];\nexport type ImplementationFunction = (sharedContext: ICompleteSharedContext) => E.SimpleApplication;\nexport type OverLoadCache = LRUCache<string, ImplementationFunction | undefined>;\n/**\n * Maps argument types on their specific implementation in a tree like structure.\n * When adding any functionality to this class, make sure you add it to SpecialFunctions as well.\n */\nexport class OverloadTree {\n  private implementation?: ImplementationFunction | undefined;\n  // We need this field. e.g. decimal decimal should be kept even when double double is added.\n  // We use promotion count to check priority.\n  private promotionCount?: number | undefined;\n  private readonly generalOverloads: Record<'term' | E.TermType, OverloadTree>;\n  private readonly literalOverLoads: [OverrideType, OverloadTree][];\n  private readonly depth: number;\n\n  public constructor(private readonly identifier: string, depth?: number) {\n    this.implementation = undefined;\n    this.generalOverloads = Object.create(null);\n    this.literalOverLoads = [];\n    this.depth = depth || 0;\n    this.promotionCount = undefined;\n  }\n\n  private getSubtree(overrideType: ExperimentalArgumentType): OverloadTree | undefined {\n    const generalType = asGeneralType(overrideType);\n    if (generalType) {\n      return this.generalOverloads[generalType];\n    }\n    for (const [ type, overloadTree ] of this.literalOverLoads) {\n      if (overrideType === type) {\n        return overloadTree;\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * Get the implementation for the types that exactly match @param args .\n   */\n  public getImplementationExact(args: ExperimentalArgumentType[]): ImplementationFunction | undefined {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias,consistent-this\n    let node: OverloadTree | undefined = this;\n    for (const expression of args) {\n      node = node.getSubtree(expression);\n      if (!node) {\n        return undefined;\n      }\n    }\n    return node.implementation;\n  }\n\n  private getOverloadCacheIdentifier(args: E.TermExpression[]): string {\n    return this.identifier + args.map(term => {\n      const literalExpression = isLiteralTermExpression(term);\n      return literalExpression ? literalExpression.dataType : term.termType;\n    }).join('');\n  }\n\n  /**\n   * Searches in a depth first way for the best matching overload. considering this a the tree's root.\n   * @param args:\n   * @param overloadCache\n   * @param superTypeProvider\n   */\n  public search(args: E.TermExpression[], superTypeProvider: ISuperTypeProvider, overloadCache: OverLoadCache):\n  ImplementationFunction | undefined {\n    const identifier = this.getOverloadCacheIdentifier(args);\n    if (overloadCache.has(identifier)) {\n      return overloadCache.get(identifier);\n    }\n    // SearchStack is a stack of all node's that need to be checked for implementation.\n    // It provides an easy way to keep order in our search.\n    const searchStack: { node: OverloadTree; index: number }[] = [];\n    const startIndex = 0;\n    if (args.length === 0) {\n      return this.implementation;\n    }\n    // GetSubTreeWithArg return a SearchStack containing the node's that should be contacted next.\n    // We also log the index since there is no other way to remember this index.\n    // the provided stack should be pushed on top of our search stack since it also has it's order.\n    searchStack.push(...this.getSubTreeWithArg(args[startIndex], superTypeProvider).map(node =>\n      ({ node, index: startIndex + 1 })));\n    while (searchStack.length > 0) {\n      const { index, node } = <{ node: OverloadTree; index: number }>searchStack.pop();\n      // We check the implementation because it would be possible a path is created but not implemented.\n      // ex: f(double, double, double) and f(term, term). and calling f(double, double).\n      if (index === args.length && node.implementation) {\n        overloadCache.set(identifier, node.implementation);\n        return node.implementation;\n      }\n      searchStack.push(...node.getSubTreeWithArg(args[index], superTypeProvider).map(item =>\n        ({ node: item, index: index + 1 })));\n    }\n    // Calling a function with one argument but finding no implementation should return no implementation.\n    // Not even the one with no arguments.\n    overloadCache.set(identifier, undefined);\n    return undefined;\n  }\n\n  /**\n   * Adds an overload to the tree structure considering this as the tree's root.\n   * @param ExperimentalArgumentTypes a list of ExperimentalArgumentTypes that would need to be provided in\n   * the same order to get the implementation.\n   * @param func the implementation for this overload.\n   */\n  public addOverload(ExperimentalArgumentTypes: ExperimentalArgumentType[], func: ImplementationFunction): void {\n    this._addOverload([ ...ExperimentalArgumentTypes ], func, 0);\n  }\n\n  private _addOverload(ExperimentalArgumentTypes: ExperimentalArgumentType[],\n    func: ImplementationFunction, promotionCount: number): void {\n    const [ experimentalArgumentType, ..._experimentalArgumentTypes ] = ExperimentalArgumentTypes;\n    if (!experimentalArgumentType) {\n      if (this.promotionCount === undefined || promotionCount <= this.promotionCount) {\n        this.promotionCount = promotionCount;\n        this.implementation = func;\n      }\n      return;\n    }\n    let nextTree = this.getSubtree(experimentalArgumentType);\n    if (!nextTree) {\n      const newNode = new OverloadTree(this.identifier, this.depth + 1);\n      const generalType = asGeneralType(experimentalArgumentType);\n      if (generalType) {\n        this.generalOverloads[generalType] = newNode;\n      }\n      const overrideType = asOverrideType(experimentalArgumentType);\n      if (overrideType) {\n        this.literalOverLoads.push([ overrideType, newNode ]);\n      }\n      nextTree = newNode;\n    }\n    nextTree._addOverload(_experimentalArgumentTypes, func, promotionCount);\n    // Defined by https://www.w3.org/TR/xpath-31/#promotion .\n    // e.g. When a function takes a string, it can also accept a XSD_ANY_URI if it's cast first.\n    // TODO: When promoting decimal type a cast needs to be preformed.\n    if (experimentalArgumentType === TypeURL.XSD_STRING) {\n      this.addPromotedOverload(TypeURL.XSD_ANY_URI, func, arg =>\n        string(arg.str()), _experimentalArgumentTypes, promotionCount);\n    }\n    // TODO: in case of decimal a round needs to happen.\n    if (experimentalArgumentType === TypeURL.XSD_DOUBLE) {\n      this.addPromotedOverload(TypeURL.XSD_FLOAT, func, arg =>\n        double((<E.NumericLiteral>arg).typedValue), _experimentalArgumentTypes, promotionCount);\n      this.addPromotedOverload(TypeURL.XSD_DECIMAL, func, arg =>\n        double((<E.NumericLiteral>arg).typedValue), _experimentalArgumentTypes, promotionCount);\n    }\n    if (experimentalArgumentType === TypeURL.XSD_FLOAT) {\n      this.addPromotedOverload(TypeURL.XSD_DECIMAL, func, arg =>\n        float((<E.NumericLiteral>arg).typedValue), _experimentalArgumentTypes, promotionCount);\n    }\n  }\n\n  private addPromotedOverload(typeToPromote: OverrideType, func: ImplementationFunction,\n    conversionFunction: (arg: E.TermExpression) => E.TermExpression,\n    ExperimentalArgumentTypes: ExperimentalArgumentType[], promotionCount: number): void {\n    let nextTree = this.getSubtree(typeToPromote);\n    if (!nextTree) {\n      const newNode = new OverloadTree(this.identifier, this.depth + 1);\n      this.literalOverLoads.push([ typeToPromote, newNode ]);\n      nextTree = newNode;\n    }\n    nextTree._addOverload(ExperimentalArgumentTypes, funcConf => args => func(funcConf)([\n      ...args.slice(0, this.depth),\n      conversionFunction(args[this.depth]),\n      ...args.slice(this.depth + 1, args.length),\n    ]), promotionCount + 1);\n  }\n\n  /**\n   * @param arg term to try and match to possible overloads of this node.\n   * @returns SearchStack a stack with top element the next node that should be asked for implementation or overload.\n   */\n  private getSubTreeWithArg(arg: E.TermExpression, openWorldType: ISuperTypeProvider): SearchStack {\n    const res: SearchStack = [];\n    const literalExpression = isLiteralTermExpression(arg);\n    // These types refer to Type exported by lib/util/Consts.ts\n    if (this.generalOverloads.term) {\n      res.push(this.generalOverloads.term);\n    }\n    // TermTypes are defined in E.TermType.\n    if (this.generalOverloads[arg.termType]) {\n      res.push(this.generalOverloads[arg.termType]);\n    }\n    if (literalExpression) {\n      // Defending implementation. Mainly the scary sort.\n      // This function has cost O(n) + O(m * log(m)) with n = amount of overloads and m = amount of matched overloads\n      // We map over each of the overloads, filter only the once that can be used (this is normally 1 or 2).\n      // The sort function on an array with 1 or 2 arguments will be negligible.\n      const concreteType = asKnownLiteralType(literalExpression.dataType);\n      let subExtensionTable: GeneralSuperTypeDict;\n      if (concreteType) {\n        // Concrete dataType is known by sparqlee.\n        subExtensionTable = superTypeDictTable[concreteType];\n      } else {\n        // Datatype is a custom datatype\n        subExtensionTable = getSuperTypes(literalExpression.dataType, openWorldType);\n      }\n      const matches: [number, OverloadTree][] = this.literalOverLoads.filter(([ matchType, _ ]) =>\n        matchType in subExtensionTable)\n        .map(([ matchType, tree ]) => [ subExtensionTable[<KnownLiteralTypes> matchType], tree ]);\n      matches.sort(([ prioA, matchTypeA ], [ prioB, matchTypeB ]) => prioA - prioB);\n      res.push(...matches.map(([ _, sortedType ]) => sortedType));\n    }\n    return res;\n  }\n}\n\n"]}
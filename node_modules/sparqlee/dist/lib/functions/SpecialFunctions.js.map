{"version":3,"file":"SpecialFunctions.js","sourceRoot":"","sources":["../../../lib/functions/SpecialFunctions.ts"],"names":[],"mappings":"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","sourcesContent":["import type * as RDF from '@rdfjs/types';\nimport * as uuid from 'uuid';\nimport * as E from '../expressions';\nimport * as C from '../util/Consts';\nimport * as Err from '../util/Errors';\nimport { bool, declare, expressionToVar, langString, string } from './Helpers';\nimport type { EvalContextAsync, EvalContextSync, OverloadTree } from '.';\nimport { regularFunctions, specialFunctions } from '.';\n\ntype Term = E.TermExpression;\ntype PTerm = Promise<E.TermExpression>;\n\n// ----------------------------------------------------------------------------\n// Functional forms\n// ----------------------------------------------------------------------------\n\n// BOUND ----------------------------------------------------------------------\n\n/**\n * https://www.w3.org/TR/sparql11-query/#func-bound\n * This function doesn't require type promotion or subtype-substitution, everything works on TermExpression\n */\nconst bound: ISpecialDefinition = {\n  arity: 1,\n  async applyAsync({ args, mapping }: EvalContextAsync): PTerm {\n    return bound_({ args, mapping });\n  },\n  applySync({ args, mapping }: EvalContextSync): Term {\n    return bound_({ args, mapping });\n  },\n};\n\nfunction bound_({ args, mapping }: { args: E.Expression[]; mapping: RDF.Bindings }): E.BooleanLiteral {\n  const variable = <E.VariableExpression> args[0];\n  if (variable.expressionType !== E.ExpressionType.Variable) {\n    throw new Err.InvalidArgumentTypes(args, C.SpecialOperator.BOUND);\n  }\n  const val = mapping.has(expressionToVar(variable));\n  return bool(val);\n}\n\n// IF -------------------------------------------------------------------------\n\n/**\n * https://www.w3.org/TR/sparql11-query/#func-if\n * This function doesn't require type promotion or subtype-substitution, everything works on TermExpression\n */\nconst ifSPARQL: ISpecialDefinition = {\n  arity: 3,\n  async applyAsync({ args, mapping, evaluate }: EvalContextAsync): PTerm {\n    const valFirst = await evaluate(args[0], mapping);\n    const ebv = valFirst.coerceEBV();\n    return ebv ?\n      evaluate(args[1], mapping) :\n      evaluate(args[2], mapping);\n  },\n  applySync({ args, mapping, evaluate }: EvalContextSync): Term {\n    const valFirst = evaluate(args[0], mapping);\n    const ebv = valFirst.coerceEBV();\n    return ebv ?\n      evaluate(args[1], mapping) :\n      evaluate(args[2], mapping);\n  },\n};\n\n// COALESCE -------------------------------------------------------------------\n\n/**\n * https://www.w3.org/TR/sparql11-query/#func-coalesce\n * This function doesn't require type promotion or subtype-substitution, everything works on TermExpression\n */\nconst coalesce: ISpecialDefinition = {\n  arity: Number.POSITIVE_INFINITY,\n  async applyAsync({ args, mapping, evaluate }: EvalContextAsync): PTerm {\n    const errors: Error[] = [];\n    for (const expr of args) {\n      try {\n        return await evaluate(expr, mapping);\n      } catch (error: unknown) {\n        errors.push(<Error> error);\n      }\n    }\n    throw new Err.CoalesceError(errors);\n  },\n  applySync({ args, mapping, evaluate }: EvalContextSync): Term {\n    const errors: Error[] = [];\n    for (const expr of args) {\n      try {\n        return evaluate(expr, mapping);\n      } catch (error: unknown) {\n        errors.push(<Error> error);\n      }\n    }\n    throw new Err.CoalesceError(errors);\n  },\n};\n\n// Logical-or (||) ------------------------------------------------------------\n\n/**\n * https://www.w3.org/TR/sparql11-query/#func-logical-or\n * This function doesn't require type promotion or subtype-substitution, everything works on TermExpression\n */\nconst logicalOr: ISpecialDefinition = {\n  arity: 2,\n  async applyAsync({ args, mapping, evaluate }: EvalContextAsync): PTerm {\n    const [ leftExpr, rightExpr ] = args;\n    try {\n      const leftTerm = await evaluate(leftExpr, mapping);\n      const left = leftTerm.coerceEBV();\n      if (left) {\n        return bool(true);\n      }\n      const rightTerm = await evaluate(rightExpr, mapping);\n      const right = rightTerm.coerceEBV();\n      return bool(right);\n    } catch (error: unknown) {\n      const rightErrorTerm = await evaluate(rightExpr, mapping);\n      const rightError = rightErrorTerm.coerceEBV();\n      if (!rightError) {\n        throw error;\n      }\n      return bool(true);\n    }\n  },\n  applySync({ args, mapping, evaluate }: EvalContextSync): Term {\n    const [ leftExpr, rightExpr ] = args;\n    try {\n      const leftTerm = evaluate(leftExpr, mapping);\n      const left = leftTerm.coerceEBV();\n      if (left) {\n        return bool(true);\n      }\n      const rightTerm = evaluate(rightExpr, mapping);\n      const right = rightTerm.coerceEBV();\n      return bool(right);\n    } catch (error: unknown) {\n      const rightErrorTerm = evaluate(rightExpr, mapping);\n      const rightError = rightErrorTerm.coerceEBV();\n      if (!rightError) {\n        throw error;\n      }\n      return bool(true);\n    }\n  },\n};\n\n// Logical-and (&&) -----------------------------------------------------------\n\n/**\n * https://www.w3.org/TR/sparql11-query/#func-logical-and\n * This function doesn't require type promotion or subtype-substitution, everything works on TermExpression\n */\nconst logicalAnd: ISpecialDefinition = {\n  arity: 2,\n  async applyAsync({ args, mapping, evaluate }: EvalContextAsync): PTerm {\n    const [ leftExpr, rightExpr ] = args;\n    try {\n      const leftTerm = await evaluate(leftExpr, mapping);\n      const left = leftTerm.coerceEBV();\n      if (!left) {\n        return bool(false);\n      }\n      const rightTerm = await evaluate(rightExpr, mapping);\n      const right = rightTerm.coerceEBV();\n      return bool(right);\n    } catch (error: unknown) {\n      const rightErrorTerm = await evaluate(rightExpr, mapping);\n      const rightError = rightErrorTerm.coerceEBV();\n      if (rightError) {\n        throw error;\n      }\n      return bool(false);\n    }\n  },\n  applySync({ args, mapping, evaluate }: EvalContextSync): Term {\n    const [ leftExpr, rightExpr ] = args;\n    try {\n      const leftTerm = evaluate(leftExpr, mapping);\n      const left = leftTerm.coerceEBV();\n      if (!left) {\n        return bool(false);\n      }\n      const rightTerm = evaluate(rightExpr, mapping);\n      const right = rightTerm.coerceEBV();\n      return bool(right);\n    } catch (error: unknown) {\n      const rightErrorTerm = evaluate(rightExpr, mapping);\n      const rightError = rightErrorTerm.coerceEBV();\n      if (rightError) {\n        throw error;\n      }\n      return bool(false);\n    }\n  },\n};\n\n// SameTerm -------------------------------------------------------------------\n\n/**\n * https://www.w3.org/TR/sparql11-query/#func-sameTerm\n * This function doesn't require type promotion or subtype-substitution, everything works on TermExpression\n */\nconst sameTerm: ISpecialDefinition = {\n  arity: 2,\n  async applyAsync({ args, mapping, evaluate }: EvalContextAsync): PTerm {\n    const [ leftExpr, rightExpr ] = args.map(arg => evaluate(arg, mapping));\n    const [ left, right ] = await Promise.all([ leftExpr, rightExpr ]);\n    return bool(left.toRDF().equals(right.toRDF()));\n  },\n  applySync({ args, mapping, evaluate }: EvalContextSync): Term {\n    const [ left, right ] = args.map(arg => evaluate(arg, mapping));\n    return bool(left.toRDF().equals(right.toRDF()));\n  },\n};\n\n// IN -------------------------------------------------------------------------\n\n/**\n * https://www.w3.org/TR/sparql11-query/#func-in\n * This function doesn't require type promotion or subtype-substitution, everything works on TermExpression\n */\nconst inSPARQL: ISpecialDefinition = {\n  arity: Number.POSITIVE_INFINITY,\n  checkArity(args: E.Expression[]) {\n    return args.length > 0;\n  },\n  async applyAsync(context: EvalContextAsync): PTerm {\n    const { args, mapping, evaluate } = context;\n    const [ leftExpr, ...remaining ] = args;\n    const left = await evaluate(leftExpr, mapping);\n    return inRecursiveAsync(left, { ...context, args: remaining }, []);\n  },\n  applySync(context: EvalContextSync): Term {\n    const { args, mapping, evaluate } = context;\n    const [ leftExpr, ...remaining ] = args;\n    const left = evaluate(leftExpr, mapping);\n    return inRecursiveSync(left, { ...context, args: remaining }, []);\n  },\n};\n\nasync function inRecursiveAsync(\n  needle: Term,\n  context: EvalContextAsync,\n  results: (Error | false)[],\n): PTerm {\n  const { args, mapping, evaluate, overloadCache } = context;\n  if (args.length === 0) {\n    const noErrors = results.every(val => !val);\n    return noErrors ? bool(false) : Promise.reject(new Err.InError(results));\n  }\n\n  try {\n    const nextExpression = args.shift();\n    // We know this will not be undefined because we check args.length === 0\n    const next = await evaluate(nextExpression!, mapping);\n    const isEqual = regularFunctions[C.RegularOperator.EQUAL];\n    if ((<E.BooleanLiteral> isEqual.apply([ needle, next ], context)).typedValue) {\n      return bool(true);\n    }\n    return inRecursiveAsync(needle, context, [ ...results, false ]);\n  } catch (error: unknown) {\n    return inRecursiveAsync(needle, context, [ ...results, <Error> error ]);\n  }\n}\n\nfunction inRecursiveSync(\n  needle: Term,\n  context: EvalContextSync,\n  results: (Error | false)[],\n): Term {\n  const { args, mapping, evaluate, overloadCache } = context;\n  if (args.length === 0) {\n    const noErrors = results.every(val => !val);\n    if (noErrors) {\n      return bool(false);\n    }\n    throw new Err.InError(results);\n  }\n\n  try {\n    const nextExpression = args.shift();\n    // We know this will not be undefined because we check args.length === 0\n    const next = evaluate(nextExpression!, mapping);\n    const isEqual = regularFunctions[C.RegularOperator.EQUAL];\n    if ((<E.BooleanLiteral> isEqual.apply([ needle, next ], context)).typedValue) {\n      return bool(true);\n    }\n    return inRecursiveSync(needle, context, [ ...results, false ]);\n  } catch (error: unknown) {\n    return inRecursiveSync(needle, context, [ ...results, <Error> error ]);\n  }\n}\n\n// NOT IN ---------------------------------------------------------------------\n\n/**\n * https://www.w3.org/TR/sparql11-query/#func-not-in\n * This function doesn't require type promotion or subtype-substitution, everything works on TermExpression\n */\nconst notInSPARQL: ISpecialDefinition = {\n  arity: Number.POSITIVE_INFINITY,\n  checkArity(args: E.Expression[]) {\n    return args.length > 0;\n  },\n  async applyAsync(context: EvalContextAsync): PTerm {\n    const _in = specialFunctions[C.SpecialOperator.IN];\n    const isIn = await _in.applyAsync(context);\n    return bool(!(<E.BooleanLiteral> isIn).typedValue);\n  },\n  applySync(context: EvalContextSync): Term {\n    const _in = specialFunctions[C.SpecialOperator.IN];\n    const isIn = _in.applySync(context);\n    return bool(!(<E.BooleanLiteral> isIn).typedValue);\n  },\n};\n\n// ----------------------------------------------------------------------------\n// Annoying functions\n// ----------------------------------------------------------------------------\n\n// CONCAT ---------------------------------------------------------------------\n\n/**\n * This OverloadTree with the constant function will handle both type promotion and subtype-substitution\n */\nconst concatTree: OverloadTree = declare(C.SpecialOperator.CONCAT).onStringly1(() => expr => expr)\n  .collect().experimentalTree;\n\n/**\n * https://www.w3.org/TR/sparql11-query/#func-concat\n */\nconst concat: ISpecialDefinition = {\n  arity: Number.POSITIVE_INFINITY,\n  async applyAsync(context: EvalContextAsync): PTerm {\n    const { args, mapping, evaluate, overloadCache, superTypeProvider } = context;\n    const pLits: Promise<E.Literal<string>>[] = args\n      .map(async expr => evaluate(expr, mapping))\n      .map(async pTerm => {\n        const operation = concatTree.search([ await pTerm ], superTypeProvider, overloadCache);\n        if (!operation) {\n          throw new Err.InvalidArgumentTypes(args, C.SpecialOperator.CONCAT);\n        }\n        return <E.Literal<string>> operation(context)([ await pTerm ]);\n      });\n    const lits = await Promise.all(pLits);\n    const strings = lits.map(lit => lit.typedValue);\n    const joined = strings.join('');\n    const lang = langAllEqual(lits) ? lits[0].language : undefined;\n    return lang ? langString(joined, lang) : string(joined);\n  },\n\n  applySync(context: EvalContextSync): Term {\n    const { args, mapping, evaluate, superTypeProvider, overloadCache } = context;\n    const lits = args\n      .map(expr => evaluate(expr, mapping))\n      .map(pTerm => {\n        const operation = concatTree.search([ pTerm ], superTypeProvider, overloadCache);\n        if (!operation) {\n          throw new Err.InvalidArgumentTypes(args, C.SpecialOperator.CONCAT);\n        }\n        return <E.Literal<string>> operation(context)([ pTerm ]);\n      });\n    const strings = lits.map(lit => lit.typedValue);\n    const joined = strings.join('');\n    const lang = langAllEqual(lits) ? lits[0].language : undefined;\n    return lang ? langString(joined, lang) : string(joined);\n  },\n};\n\nfunction langAllEqual(lits: E.Literal<string>[]): boolean {\n  return lits.length > 0 && lits.every(lit => lit.language === lits[0].language);\n}\n\n// ----------------------------------------------------------------------------\n// Context dependant functions\n// ----------------------------------------------------------------------------\n\n// BNODE ---------------------------------------------------------------------\n\n/**\n * This OverloadTree with the constant function will handle both type promotion and subtype-substitution\n */\nconst bnodeTree = declare(C.SpecialOperator.BNODE).onString1(() => arg => arg).collect().experimentalTree;\n\n/**\n * https://www.w3.org/TR/sparql11-query/#func-bnode\n * id has to be distinct over all id's in dataset\n */\nconst BNODE: ISpecialDefinition = {\n  arity: Number.POSITIVE_INFINITY,\n  checkArity(args: E.Expression[]) {\n    return args.length === 0 || args.length === 1;\n  },\n  async applyAsync(context: EvalContextAsync): PTerm {\n    const { args, mapping, evaluate, superTypeProvider, overloadCache } = context;\n    const input = args.length === 1 ?\n      await evaluate(args[0], mapping) :\n      undefined;\n\n    let strInput: string | undefined;\n    if (input) {\n      const operation = bnodeTree.search([ input ], superTypeProvider, overloadCache);\n      if (!operation) {\n        throw new Err.InvalidArgumentTypes(args, C.SpecialOperator.BNODE);\n      }\n      strInput = operation(context)([ input ]).str();\n    }\n\n    // eslint-disable-next-line unicorn/consistent-destructuring\n    if (context.bnode) {\n      const bnode = await context.bnode(strInput);\n      return new E.BlankNode(bnode);\n    }\n\n    return BNODE_(strInput);\n  },\n  applySync(context: EvalContextSync): Term {\n    const { args, mapping, evaluate, superTypeProvider, overloadCache } = context;\n    const input = args.length === 1 ?\n      evaluate(args[0], mapping) :\n      undefined;\n\n    let strInput: string | undefined;\n    if (input) {\n      const operation = bnodeTree.search([ input ], superTypeProvider, overloadCache);\n      if (!operation) {\n        throw new Err.InvalidArgumentTypes(args, C.SpecialOperator.BNODE);\n      }\n      strInput = operation(context)([ input ]).str();\n    }\n\n    // eslint-disable-next-line unicorn/consistent-destructuring\n    if (context.bnode) {\n      const bnode = context.bnode(strInput);\n      return new E.BlankNode(bnode);\n    }\n\n    return BNODE_(strInput);\n  },\n};\n\nfunction BNODE_(input?: string): E.BlankNode {\n  return new E.BlankNode(input || uuid.v4());\n}\n\n// ----------------------------------------------------------------------------\n// Wrap these declarations into functions\n// ----------------------------------------------------------------------------\n\nexport interface ISpecialDefinition {\n  arity: number;\n  applyAsync: E.SpecialApplicationAsync;\n  // TODO: Test these implementations\n  applySync: E.SpecialApplicationSync;\n  checkArity?: (args: E.Expression[]) => boolean;\n}\n\nexport const specialDefinitions: Record<C.SpecialOperator, ISpecialDefinition> = {\n  // --------------------------------------------------------------------------\n  // Functional Forms\n  // https://www.w3.org/TR/sparql11-query/#func-forms\n  // --------------------------------------------------------------------------\n  bound,\n  if: ifSPARQL,\n  coalesce,\n  '&&': logicalAnd,\n  '||': logicalOr,\n  sameterm: sameTerm,\n  in: inSPARQL,\n  notin: notInSPARQL,\n\n  // Annoying functions\n  concat,\n\n  // Context dependent functions\n  BNODE,\n};\n\n"]}
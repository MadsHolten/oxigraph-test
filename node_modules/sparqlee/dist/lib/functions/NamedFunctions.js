"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.namedDefinitions = void 0;
const Consts_1 = require("../util/Consts");
const Err = require("../util/Errors");
const Parsing_1 = require("../util/Parsing");
const Helpers_1 = require("./Helpers");
// ----------------------------------------------------------------------------
// ----------------------------------------------------------------------------
// ----------------------------------------------------------------------------
// Begin definitions.
// ----------------------------------------------------------------------------
// XPath Constructor functions
// https://www.w3.org/TR/sparql11-query/#
// https://www.w3.org/TR/xpath-functions/#casting-from-primitive-to-primitive
// ----------------------------------------------------------------------------
/**
 * https://www.w3.org/TR/xpath-functions/#casting-to-string
 */
const xsdToString = {
    arity: 1,
    overloads: (0, Helpers_1.declare)(Consts_1.TypeURL.XSD_STRING)
        .onNumeric1(() => (val) => (0, Helpers_1.string)((0, Helpers_1.float)(val.typedValue).str()))
        .onBoolean1Typed(() => val => (0, Helpers_1.string)((0, Helpers_1.bool)(val).str()))
        .onTerm1(() => (val) => (0, Helpers_1.string)(val.str()))
        .collect(),
};
const xsdToFloat = {
    arity: 1,
    overloads: (0, Helpers_1.declare)(Consts_1.TypeURL.XSD_FLOAT)
        .onNumeric1(() => (val) => (0, Helpers_1.float)(val.typedValue))
        .onBoolean1Typed(() => val => (0, Helpers_1.float)(val ? 1 : 0))
        .onUnary(Consts_1.TypeURL.XSD_STRING, () => (val) => {
        const result = (0, Parsing_1.parseXSDFloat)(val.str());
        if (result === undefined) {
            throw new Err.CastError(val, Consts_1.TypeURL.XSD_FLOAT);
        }
        return (0, Helpers_1.float)(result);
    })
        .copy({ from: [Consts_1.TypeURL.XSD_STRING], to: [Consts_1.TypeAlias.SPARQL_NON_LEXICAL] })
        .collect(),
};
const xsdToDouble = {
    arity: 1,
    overloads: (0, Helpers_1.declare)(Consts_1.TypeURL.XSD_DOUBLE)
        .onNumeric1(() => (val) => (0, Helpers_1.double)(val.typedValue))
        .onBoolean1Typed(() => val => (0, Helpers_1.double)(val ? 1 : 0))
        .onUnary(Consts_1.TypeURL.XSD_STRING, () => (val) => {
        const result = (0, Parsing_1.parseXSDFloat)(val.str());
        if (result === undefined) {
            throw new Err.CastError(val, Consts_1.TypeURL.XSD_DOUBLE);
        }
        return (0, Helpers_1.double)(result);
    })
        .copy({ from: [Consts_1.TypeURL.XSD_STRING], to: [Consts_1.TypeAlias.SPARQL_NON_LEXICAL] })
        .collect(),
};
const xsdToDecimal = {
    arity: 1,
    overloads: (0, Helpers_1.declare)(Consts_1.TypeURL.XSD_DECIMAL)
        .onNumeric1(() => (val) => {
        const result = (0, Parsing_1.parseXSDDecimal)(val.str());
        if (result === undefined) {
            throw new Err.CastError(val, Consts_1.TypeURL.XSD_DECIMAL);
        }
        return (0, Helpers_1.decimal)(result);
    })
        .onString1(() => (val) => {
        const str = val.str();
        const result = /^([+-])?(\d+(\.\d+)?)$/u.test(str) ? (0, Parsing_1.parseXSDDecimal)(str) : undefined;
        if (result === undefined) {
            throw new Err.CastError(val, Consts_1.TypeURL.XSD_DECIMAL);
        }
        return (0, Helpers_1.decimal)(result);
    })
        .copy({ from: [Consts_1.TypeURL.XSD_STRING], to: [Consts_1.TypeAlias.SPARQL_NON_LEXICAL] })
        .onBoolean1Typed(() => val => (0, Helpers_1.decimal)(val ? 1 : 0))
        .collect(),
};
const xsdToInteger = {
    arity: 1,
    overloads: (0, Helpers_1.declare)(Consts_1.TypeURL.XSD_INTEGER)
        .onBoolean1Typed(() => val => (0, Helpers_1.integer)(val ? 1 : 0))
        .onNumeric1(() => (val) => {
        const result = (0, Parsing_1.parseXSDInteger)(val.str());
        if (result === undefined) {
            throw new Err.CastError(val, Consts_1.TypeURL.XSD_INTEGER);
        }
        return (0, Helpers_1.integer)(result);
    })
        .onString1(() => (val) => {
        const str = val.str();
        const result = /^\d+$/u.test(str) ? (0, Parsing_1.parseXSDInteger)(str) : undefined;
        if (result === undefined) {
            throw new Err.CastError(val, Consts_1.TypeURL.XSD_INTEGER);
        }
        return (0, Helpers_1.integer)(result);
    })
        .copy({ from: [Consts_1.TypeAlias.SPARQL_NUMERIC], to: [Consts_1.TypeAlias.SPARQL_NON_LEXICAL] })
        .collect(),
};
const xsdToDatetime = {
    arity: 1,
    overloads: (0, Helpers_1.declare)(Consts_1.TypeURL.XSD_DATE_TIME)
        .onUnary(Consts_1.TypeURL.XSD_DATE_TIME, () => (val) => val)
        .onUnary(Consts_1.TypeURL.XSD_STRING, () => (val) => {
        const date = new Date(val.str());
        if (Number.isNaN(date.getTime())) {
            throw new Err.CastError(val, Consts_1.TypeURL.XSD_DATE_TIME);
        }
        return (0, Helpers_1.dateTime)(date, val.str());
    })
        .copy({ from: [Consts_1.TypeURL.XSD_STRING], to: [Consts_1.TypeAlias.SPARQL_NON_LEXICAL] })
        .collect(),
};
const xsdToBoolean = {
    arity: 1,
    overloads: (0, Helpers_1.declare)(Consts_1.TypeURL.XSD_BOOLEAN)
        .onNumeric1(() => (val) => (0, Helpers_1.bool)(val.coerceEBV()))
        .onUnary(Consts_1.TypeURL.XSD_BOOLEAN, () => (val) => (0, Helpers_1.bool)(val.coerceEBV()))
        .onUnary(Consts_1.TypeURL.XSD_STRING, () => (val) => {
        switch (val.str()) {
            case 'true':
                return (0, Helpers_1.bool)(true);
            case 'false':
                return (0, Helpers_1.bool)(false);
            case '1':
                return (0, Helpers_1.bool)(true);
            case '0':
                return (0, Helpers_1.bool)(false);
            default:
                throw new Err.CastError(val, Consts_1.TypeURL.XSD_BOOLEAN);
        }
    })
        .copy({ from: [Consts_1.TypeURL.XSD_STRING], to: [Consts_1.TypeAlias.SPARQL_NON_LEXICAL] })
        .collect(),
};
// End definitions.
// ----------------------------------------------------------------------------
// ----------------------------------------------------------------------------
// ----------------------------------------------------------------------------
exports.namedDefinitions = {
    // --------------------------------------------------------------------------
    // XPath Constructor functions
    // https://www.w3.org/TR/sparql11-query/#FunctionMapping
    // --------------------------------------------------------------------------
    [Consts_1.TypeURL.XSD_STRING]: xsdToString,
    [Consts_1.TypeURL.XSD_FLOAT]: xsdToFloat,
    [Consts_1.TypeURL.XSD_DOUBLE]: xsdToDouble,
    [Consts_1.TypeURL.XSD_DECIMAL]: xsdToDecimal,
    [Consts_1.TypeURL.XSD_INTEGER]: xsdToInteger,
    [Consts_1.TypeURL.XSD_DATE_TIME]: xsdToDatetime,
    [Consts_1.TypeURL.XSD_DATE]: xsdToDatetime,
    [Consts_1.TypeURL.XSD_BOOLEAN]: xsdToBoolean,
};
//# sourceMappingURL=NamedFunctions.js.map
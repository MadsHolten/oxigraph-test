import type * as LRUCache from 'lru-cache';
import type { ICompleteSharedContext } from '../evaluators/evaluatorHelpers/BaseExpressionEvaluator';
import type * as E from '../expressions';
import type { ISuperTypeProvider } from '../util/TypeHandling';
import type { ExperimentalArgumentType } from './Core';
export declare type SearchStack = OverloadTree[];
export declare type ImplementationFunction = (sharedContext: ICompleteSharedContext) => E.SimpleApplication;
export declare type OverLoadCache = LRUCache<string, ImplementationFunction | undefined>;
/**
 * Maps argument types on their specific implementation in a tree like structure.
 * When adding any functionality to this class, make sure you add it to SpecialFunctions as well.
 */
export declare class OverloadTree {
    private readonly identifier;
    private implementation?;
    private promotionCount?;
    private readonly generalOverloads;
    private readonly literalOverLoads;
    private readonly depth;
    constructor(identifier: string, depth?: number);
    private getSubtree;
    /**
     * Get the implementation for the types that exactly match @param args .
     */
    getImplementationExact(args: ExperimentalArgumentType[]): ImplementationFunction | undefined;
    private getOverloadCacheIdentifier;
    /**
     * Searches in a depth first way for the best matching overload. considering this a the tree's root.
     * @param args:
     * @param overloadCache
     * @param superTypeProvider
     */
    search(args: E.TermExpression[], superTypeProvider: ISuperTypeProvider, overloadCache: OverLoadCache): ImplementationFunction | undefined;
    /**
     * Adds an overload to the tree structure considering this as the tree's root.
     * @param ExperimentalArgumentTypes a list of ExperimentalArgumentTypes that would need to be provided in
     * the same order to get the implementation.
     * @param func the implementation for this overload.
     */
    addOverload(ExperimentalArgumentTypes: ExperimentalArgumentType[], func: ImplementationFunction): void;
    private _addOverload;
    private addPromotedOverload;
    /**
     * @param arg term to try and match to possible overloads of this node.
     * @returns SearchStack a stack with top element the next node that should be asked for implementation or overload.
     */
    private getSubTreeWithArg;
}

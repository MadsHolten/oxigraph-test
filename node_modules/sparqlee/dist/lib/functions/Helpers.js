"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.expressionToVar = exports.dateTime = exports.langString = exports.string = exports.double = exports.float = exports.decimal = exports.integer = exports.bool = exports.Builder = exports.declare = void 0;
const rdf_data_factory_1 = require("rdf-data-factory");
const E = require("../expressions");
const expressions_1 = require("../expressions");
const C = require("../util/Consts");
const Consts_1 = require("../util/Consts");
const Err = require("../util/Errors");
const TypeHandling_1 = require("../util/TypeHandling");
const LegacyTree_1 = require("./LegacyTree");
const OverloadTree_1 = require("./OverloadTree");
const DF = new rdf_data_factory_1.DataFactory();
function declare(identifier) {
    return new Builder(identifier);
}
exports.declare = declare;
class Builder {
    constructor(identifier) {
        this.overloadTree = new OverloadTree_1.OverloadTree(identifier);
        this.legacyTree = new LegacyTree_1.LegacyTree();
        this.collected = false;
    }
    collect() {
        if (this.collected) {
            // Only 1 time allowed because we can't copy a tree. (And we don't need this).
            throw new Error('Builders can only be collected once!');
        }
        this.collected = true;
        return { experimentalTree: this.overloadTree, tree: this.legacyTree };
    }
    set(argTypes, func) {
        this.overloadTree.addOverload(argTypes, func);
        this.legacyTree.addOverload(argTypes, func);
        return this;
    }
    /**
     * A legacy function should be set only after all other functions are set
     * @param argTypes
     * @param func
     */
    setLegacy(argTypes, func) {
        this.legacyTree.addLegacyOverload(argTypes, func);
        return this;
    }
    copy({ from, to }) {
        const impl = this.overloadTree.getImplementationExact(from);
        if (!impl) {
            throw new Err.UnexpectedError('Tried to copy implementation, but types not found', { from, to });
        }
        return this.set(to, impl);
    }
    onUnary(type, op) {
        return this.set([type], context => ([val]) => op(context)(val));
    }
    onUnaryTyped(type, op) {
        return this.set([type], context => ([val]) => op(context)(val.typedValue));
    }
    onBinary(types, op) {
        return this.set(types, context => ([left, right]) => op(context)(left, right));
    }
    onBinaryTyped(types, op) {
        return this.set(types, context => ([left, right]) => op(context)(left.typedValue, right.typedValue));
    }
    onTernaryTyped(types, op) {
        return this.set(types, context => ([a1, a2, a3]) => op(context)(a1.typedValue, a2.typedValue, a3.typedValue));
    }
    onTernary(types, op) {
        return this.set(types, context => ([a1, a2, a3]) => op(context)(a1, a2, a3));
    }
    onQuaternaryTyped(types, op) {
        return this.set(types, context => ([a1, a2, a3, a4]) => op(context)(a1.typedValue, a2.typedValue, a3.typedValue, a4.typedValue));
    }
    onTerm1(op) {
        return this.set(['term'], context => ([term]) => op(context)(term));
    }
    onLiteral1(op) {
        return this.set(['literal'], context => ([term]) => op(context)(term));
    }
    onBoolean1(op) {
        return this
            .set([C.TypeURL.XSD_BOOLEAN], context => ([lit]) => op(context)(lit));
    }
    onBoolean1Typed(op) {
        return this
            .set([C.TypeURL.XSD_BOOLEAN], context => ([lit]) => op(context)(lit.typedValue));
    }
    onString1(op) {
        return this
            .set([C.TypeURL.XSD_STRING], context => ([lit]) => op(context)(lit));
    }
    onString1Typed(op) {
        return this
            .set([C.TypeURL.XSD_STRING], context => ([lit]) => op(context)(lit.typedValue));
    }
    onLangString1(op) {
        return this
            .set([C.TypeURL.RDF_LANG_STRING], context => ([lit]) => op(context)(lit));
    }
    onStringly1(op) {
        return this
            .set([C.TypeAlias.SPARQL_STRINGLY], context => ([lit]) => op(context)(lit));
    }
    onStringly1Typed(op) {
        return this
            .set([C.TypeAlias.SPARQL_STRINGLY], context => ([lit]) => op(context)(lit.typedValue));
    }
    onNumeric1(op) {
        return this
            .set([C.TypeAlias.SPARQL_NUMERIC], context => ([val]) => op(context)(val))
            .invalidLexicalForm([C.TypeAlias.SPARQL_NON_LEXICAL], 1);
    }
    onDateTime1(op) {
        return this
            .set([C.TypeURL.XSD_DATE_TIME], context => ([val]) => op(context)(val))
            .invalidLexicalForm([C.TypeAlias.SPARQL_NON_LEXICAL], 1);
    }
    /**
     * We return the base types and not the provided types because we don't want to create invalid terms.
     * Providing negative number to a function unary - for example should not
     * return a term of type negative number having a positive value.
     * @param op the numeric operator performed
     */
    numericConverter(op) {
        const evalHelper = (context) => (arg) => op(context)(arg.typedValue);
        return this.onBinary([Consts_1.TypeURL.XSD_INTEGER], context => arg => integer(evalHelper(context)(arg)))
            .onBinary([Consts_1.TypeURL.XSD_DECIMAL], context => arg => decimal(evalHelper(context)(arg)))
            .onBinary([Consts_1.TypeURL.XSD_FLOAT], context => arg => float(evalHelper(context)(arg)))
            .onBinary([Consts_1.TypeURL.XSD_DOUBLE], context => arg => double(evalHelper(context)(arg)))
            .invalidLexicalForm([C.TypeAlias.SPARQL_NON_LEXICAL], 1);
    }
    /**
     * !!! Be aware when using this function, it will create different overloads with different return types !!!
     * Arithmetic operators take 2 numeric arguments, and return a single numerical
     * value. The type of the return value is heavily dependant on the types of the
     * input arguments. In JS everything is a double, but in SPARQL it is not.
     *
     * The different arguments are handled by type promotion and subtype substitution.
     * The way numeric function arguments work is described here:
     * https://www.w3.org/TR/xpath20/#mapping
     * Above url is referenced in the sparql spec: https://www.w3.org/TR/sparql11-query/#OperatorMapping
     */
    arithmetic(op) {
        const evalHelper = (context) => (left, right) => op(context)(left.typedValue, right.typedValue);
        return this.onBinary([Consts_1.TypeURL.XSD_INTEGER, Consts_1.TypeURL.XSD_INTEGER], context => (left, right) => integer(evalHelper(context)(left, right)))
            .onBinary([Consts_1.TypeURL.XSD_DECIMAL, Consts_1.TypeURL.XSD_DECIMAL], context => (left, right) => decimal(evalHelper(context)(left, right)))
            .onBinary([Consts_1.TypeURL.XSD_FLOAT, Consts_1.TypeURL.XSD_FLOAT], context => (left, right) => float(evalHelper(context)(left, right)))
            .onBinary([Consts_1.TypeURL.XSD_DOUBLE, Consts_1.TypeURL.XSD_DOUBLE], context => (left, right) => double(evalHelper(context)(left, right)))
            .setLegacy([Consts_1.TypeAlias.SPARQL_NUMERIC, Consts_1.TypeAlias.SPARQL_NUMERIC], (context) => ([left, right]) => Builder.legacyArithmeticPromotion[left.mainSparqlType][right.mainSparqlType](op(context)(left.typedValue, right.typedValue)));
    }
    numberTest(test) {
        return this.numeric(context => ([left, right]) => {
            const result = test(context)(left.typedValue, right.typedValue);
            return bool(result);
        });
    }
    stringTest(test) {
        return this
            .set([C.TypeURL.XSD_STRING, C.TypeURL.XSD_STRING], context => ([left, right]) => {
            const result = test(context)(left.typedValue, right.typedValue);
            return bool(result);
        })
            .invalidLexicalForm([C.TypeAlias.SPARQL_NON_LEXICAL, C.TypeURL.XSD_STRING], 1)
            .invalidLexicalForm([C.TypeURL.XSD_STRING, C.TypeAlias.SPARQL_NON_LEXICAL], 2);
    }
    booleanTest(test) {
        return this
            .set([C.TypeURL.XSD_BOOLEAN, C.TypeURL.XSD_BOOLEAN], context => ([left, right]) => {
            const result = test(context)(left.typedValue, right.typedValue);
            return bool(result);
        })
            .invalidLexicalForm([C.TypeAlias.SPARQL_NON_LEXICAL, C.TypeURL.XSD_BOOLEAN], 1)
            .invalidLexicalForm([C.TypeURL.XSD_BOOLEAN, C.TypeAlias.SPARQL_NON_LEXICAL], 2);
    }
    dateTimeTest(test) {
        return this
            .set([C.TypeURL.XSD_DATE_TIME, C.TypeURL.XSD_DATE_TIME], context => ([left, right]) => {
            const result = test(context)(left.typedValue, right.typedValue);
            return bool(result);
        })
            .invalidLexicalForm([C.TypeAlias.SPARQL_NON_LEXICAL, C.TypeURL.XSD_DATE_TIME], 1)
            .invalidLexicalForm([C.TypeURL.XSD_DATE_TIME, C.TypeAlias.SPARQL_NON_LEXICAL], 2);
    }
    numeric(op) {
        return this
            .set([C.TypeAlias.SPARQL_NUMERIC, C.TypeAlias.SPARQL_NUMERIC], op)
            .invalidLexicalForm([C.TypeAlias.SPARQL_NUMERIC, C.TypeAlias.SPARQL_NON_LEXICAL], 2)
            .invalidLexicalForm([C.TypeAlias.SPARQL_NON_LEXICAL, C.TypeAlias.SPARQL_NUMERIC], 1);
    }
    invalidLexicalForm(types, index) {
        return this.set(types, () => (args) => {
            throw new Err.InvalidLexicalForm(args[index - 1].toRDF());
        });
    }
}
exports.Builder = Builder;
Builder.legacyArithmeticPromotion = {
    integer: {
        integer: num => new expressions_1.IntegerLiteral(num),
        decimal: num => new expressions_1.DecimalLiteral(num),
        float: num => new expressions_1.FloatLiteral(num),
        double: num => new expressions_1.DoubleLiteral(num),
    },
    decimal: {
        integer: num => new expressions_1.DecimalLiteral(num),
        decimal: num => new expressions_1.DecimalLiteral(num),
        float: num => new expressions_1.FloatLiteral(num),
        double: num => new expressions_1.DoubleLiteral(num),
    },
    float: {
        integer: num => new expressions_1.FloatLiteral(num),
        decimal: num => new expressions_1.FloatLiteral(num),
        float: num => new expressions_1.FloatLiteral(num),
        double: num => new expressions_1.DoubleLiteral(num),
    },
    double: {
        integer: num => new expressions_1.DoubleLiteral(num),
        decimal: num => new expressions_1.DoubleLiteral(num),
        float: num => new expressions_1.DoubleLiteral(num),
        double: num => new expressions_1.DoubleLiteral(num),
    },
};
// ----------------------------------------------------------------------------
// Literal Construction helpers
// ----------------------------------------------------------------------------
function bool(val) {
    return new E.BooleanLiteral(val);
}
exports.bool = bool;
function integer(num, dt) {
    if (dt && !(0, TypeHandling_1.isInternalSubType)(dt, Consts_1.TypeURL.XSD_INTEGER)) {
        throw new Error('apple');
    }
    return new E.IntegerLiteral(num, dt);
}
exports.integer = integer;
function decimal(num, dt) {
    if (dt && !(0, TypeHandling_1.isInternalSubType)(dt, Consts_1.TypeURL.XSD_DECIMAL)) {
        throw new Error('apple');
    }
    return new E.DecimalLiteral(num, dt);
}
exports.decimal = decimal;
function float(num, dt) {
    if (dt && !(0, TypeHandling_1.isInternalSubType)(dt, Consts_1.TypeURL.XSD_FLOAT)) {
        throw new Error('apple');
    }
    return new E.FloatLiteral(num, dt);
}
exports.float = float;
function double(num, dt) {
    if (dt && !(0, TypeHandling_1.isInternalSubType)(dt, Consts_1.TypeURL.XSD_DOUBLE)) {
        throw new Error('apple');
    }
    return new E.DoubleLiteral(num, dt);
}
exports.double = double;
function string(str) {
    return new E.StringLiteral(str);
}
exports.string = string;
function langString(str, lang) {
    return new E.LangStringLiteral(str, lang);
}
exports.langString = langString;
function dateTime(date, str) {
    return new E.DateTimeLiteral(date, str);
}
exports.dateTime = dateTime;
function expressionToVar(variableExpression) {
    return DF.variable(variableExpression.name.slice(1));
}
exports.expressionToVar = expressionToVar;
//# sourceMappingURL=Helpers.js.map
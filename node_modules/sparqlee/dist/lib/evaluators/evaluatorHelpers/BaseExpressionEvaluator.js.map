{"version":3,"file":"BaseExpressionEvaluator.js","sourceRoot":"","sources":["../../../../lib/evaluators/evaluatorHelpers/BaseExpressionEvaluator.ts"],"names":[],"mappings":";;;AAEA,qDAA0D;AAG1D,yCAAyC;AA0BzC,MAAa,uBAAuB;IAClC,YAAsC,eAAiC;QAAjC,oBAAe,GAAf,eAAe,CAAkB;IAAI,CAAC;IAElE,IAAI,CAAC,IAAY,EAAE,OAAqB;QAChD,OAAO,IAAI,CAAC;IACd,CAAC;IAES,QAAQ,CAAC,IAAgB,EAAE,OAAqB;QACxD,MAAM,IAAI,GAAG,OAAO,CAAC,GAAG,CAAC,IAAA,yBAAe,EAAC,IAAI,CAAC,CAAC,CAAC;QAChD,IAAI,CAAC,IAAI,EAAE;YACT,MAAM,IAAI,GAAG,CAAC,oBAAoB,CAAC,IAAI,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;SACxD;QACD,OAAO,IAAI,CAAC,eAAe,CAAC,sBAAsB,CAAC,IAAI,CAAC,CAAC;IAC3D,CAAC;CACF;AAdD,0DAcC","sourcesContent":["import type * as RDF from '@rdfjs/types';\nimport type * as E from '../../expressions';\nimport { expressionToVar } from '../../functions/Helpers';\nimport type { OverLoadCache } from '../../functions/OverloadTree';\nimport type { ITermTransformer } from '../../transformers/TermTransformer';\nimport * as Err from '../../util/Errors';\nimport type { SuperTypeCallback, TypeCache, ISuperTypeProvider } from '../../util/TypeHandling';\n\nexport interface ISharedContext {\n  now?: Date;\n  baseIRI?: string;\n  overloadCache?: OverLoadCache;\n  typeCache?: TypeCache;\n  getSuperType?: SuperTypeCallback;\n  /**\n   * This feature is opt in. It activates the use of a new 'experimental' type system.\n   * This system is needed when using typeCache, overloadCache or getSuperType.\n   * The system is more powerful and reliable. In most cases however the old system works perfectly.\n   * Using this experimental system makes sparqlee a bit slower but more reliable using type promotion for example.\n   */\n  enableExtendedXsdTypes?: boolean;\n}\n\nexport interface ICompleteSharedContext {\n  now: Date;\n  baseIRI?: string;\n  overloadCache: OverLoadCache;\n  superTypeProvider: ISuperTypeProvider;\n  enableExtendedXsdTypes: boolean;\n}\n\nexport class BaseExpressionEvaluator {\n  public constructor(protected readonly termTransformer: ITermTransformer) { }\n\n  protected term(expr: E.Term, mapping: RDF.Bindings): E.Term {\n    return expr;\n  }\n\n  protected variable(expr: E.Variable, mapping: RDF.Bindings): E.Term {\n    const term = mapping.get(expressionToVar(expr));\n    if (!term) {\n      throw new Err.UnboundVariableError(expr.name, mapping);\n    }\n    return this.termTransformer.transformRDFTermUnsafe(term);\n  }\n}\n"]}
import type * as RDF from '@rdfjs/types';
import type { Algebra } from 'sparqlalgebrajs';
import type { BaseAggregator } from '../../aggregators/BaseAggregator';
import type { ICompleteSharedContext } from './BaseExpressionEvaluator';
export declare abstract class BaseAggregateEvaluator {
    protected expression: Algebra.AggregateExpression;
    protected aggregator: BaseAggregator<any>;
    protected throwError: boolean;
    protected state: any;
    protected constructor(expr: Algebra.AggregateExpression, sharedContext: ICompleteSharedContext, throwError?: boolean);
    /**
     * The spec says to throw an error when a set function is called on an empty
     * set (unless explicitly mentioned otherwise like COUNT).
     * However, aggregate error handling says to not bind the result in case of an
     * error. So to simplify logic in the caller, we return undefined by default.
     *
     * @param throwError whether this function should respect the spec and throw an error if no empty value is defined
     */
    static emptyValue(expr: Algebra.AggregateExpression, throwError?: boolean): RDF.Term | undefined;
    result(): RDF.Term | undefined;
    /**
     * Put a binding from the result stream in the aggregate state.
     *
     * If any binding evaluation errors, the corresponding aggregate variable should be unbound.
     * If this happens, calling @see result() will return @constant undefined
     *
     * @param bindings the bindings to pass to the expression
     */
    abstract put(bindings: RDF.Bindings): void | Promise<void>;
    /**
     * The actual result method. When the first binding has been given, and the state
     * of the evaluators initialised. The .result API function will be replaced with this
     * function, which implements the behaviour we want.
     *
     * @param bindings the bindings to pass to the expression
     */
    protected __result(): RDF.Term;
    /**
     * The actual put method. When the first binding has been given, and the state
     * of the evaluators initialised. The .put API function will be replaced with this
     * function, which implements the behaviour we want.
     *
     * @param bindings the bindings to pass to the expression
     */
    protected abstract __put(bindings: RDF.Bindings): void | Promise<void>;
    protected abstract safeThrow(err: unknown): void;
}

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseAggregateEvaluator = void 0;
const aggregators_1 = require("../../aggregators");
const Err = require("../../util/Errors");
class BaseAggregateEvaluator {
    constructor(expr, sharedContext, throwError) {
        this.throwError = false;
        this.expression = expr;
        this.aggregator = new aggregators_1.aggregators[expr.aggregator](expr, sharedContext);
        this.throwError = throwError || false;
    }
    /**
     * The spec says to throw an error when a set function is called on an empty
     * set (unless explicitly mentioned otherwise like COUNT).
     * However, aggregate error handling says to not bind the result in case of an
     * error. So to simplify logic in the caller, we return undefined by default.
     *
     * @param throwError whether this function should respect the spec and throw an error if no empty value is defined
     */
    static emptyValue(expr, throwError = false) {
        const val = aggregators_1.aggregators[expr.aggregator].emptyValue();
        if (val === undefined && throwError) {
            throw new Err.EmptyAggregateError();
        }
        return val;
    }
    result() {
        return this.aggregator.constructor.emptyValue();
    }
    /**
     * The actual result method. When the first binding has been given, and the state
     * of the evaluators initialised. The .result API function will be replaced with this
     * function, which implements the behaviour we want.
     *
     * @param bindings the bindings to pass to the expression
     */
    __result() {
        return this.aggregator.result(this.state);
    }
}
exports.BaseAggregateEvaluator = BaseAggregateEvaluator;
//# sourceMappingURL=BaseAggregateEvaluator.js.map
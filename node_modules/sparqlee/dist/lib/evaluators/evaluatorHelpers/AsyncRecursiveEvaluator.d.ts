import type * as RDF from '@rdfjs/types';
import type { Algebra as Alg } from 'sparqlalgebrajs';
import * as E from '../../expressions';
import type { ITermTransformer } from '../../transformers/TermTransformer';
import type { IExpressionEvaluator } from '../../Types';
import type { ISuperTypeProvider } from '../../util/TypeHandling';
import type { AsyncExtensionFunctionCreator } from '../AsyncEvaluator';
import { BaseExpressionEvaluator } from './BaseExpressionEvaluator';
import type { ICompleteSharedContext } from './BaseExpressionEvaluator';
export interface ICompleteAsyncEvaluatorContext extends ICompleteSharedContext {
    exists?: (expression: Alg.ExistenceExpression, mapping: RDF.Bindings) => Promise<boolean>;
    aggregate?: (expression: Alg.AggregateExpression) => Promise<RDF.Term>;
    bnode?: (input?: string) => Promise<RDF.BlankNode>;
    extensionFunctionCreator?: AsyncExtensionFunctionCreator;
}
export declare class AsyncRecursiveEvaluator extends BaseExpressionEvaluator implements IExpressionEvaluator<E.Expression, Promise<E.Term>> {
    private readonly context;
    protected openWorldType: ISuperTypeProvider;
    private readonly subEvaluators;
    constructor(context: ICompleteAsyncEvaluatorContext, termTransformer?: ITermTransformer);
    evaluate(expr: E.Expression, mapping: RDF.Bindings): Promise<E.Term>;
    private evalOperator;
    private evalSpecialOperator;
    private _evalAsyncArgs;
    private evalNamed;
    private evalAsyncExtension;
    private evalExistence;
    private evalAggregate;
}

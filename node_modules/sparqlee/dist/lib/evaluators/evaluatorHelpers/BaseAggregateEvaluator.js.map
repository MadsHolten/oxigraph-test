{"version":3,"file":"BaseAggregateEvaluator.js","sourceRoot":"","sources":["../../../../lib/evaluators/evaluatorHelpers/BaseAggregateEvaluator.ts"],"names":[],"mappings":";;;AAGA,mDAAgD;AAGhD,yCAAyC;AAGzC,MAAsB,sBAAsB;IAM1C,YAAsB,IAAiC,EACrD,aAAqC,EAAE,UAAoB;QAJnD,eAAU,GAAG,KAAK,CAAC;QAK3B,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC;QACvB,IAAI,CAAC,UAAU,GAAG,IAAI,yBAAW,CAAe,IAAI,CAAC,UAAU,CAAC,CAAC,IAAI,EAAE,aAAa,CAAC,CAAC;QACtF,IAAI,CAAC,UAAU,GAAG,UAAU,IAAI,KAAK,CAAC;IACxC,CAAC;IAED;;;;;;;OAOG;IACI,MAAM,CAAC,UAAU,CAAC,IAAiC,EAAE,UAAU,GAAG,KAAK;QAC5E,MAAM,GAAG,GAAG,yBAAW,CAAe,IAAI,CAAC,UAAU,CAAC,CAAC,UAAU,EAAE,CAAC;QACpE,IAAI,GAAG,KAAK,SAAS,IAAI,UAAU,EAAE;YACnC,MAAM,IAAI,GAAG,CAAC,mBAAmB,EAAE,CAAC;SACrC;QACD,OAAO,GAAG,CAAC;IACb,CAAC;IAEM,MAAM;QACX,OAA2B,IAAI,CAAC,UAAU,CAAC,WAAY,CAAC,UAAU,EAAE,CAAC;IACvE,CAAC;IAYD;;;;;;OAMG;IACO,QAAQ;QAChB,OAAO,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;IAC5C,CAAC;CAYF;AAhED,wDAgEC","sourcesContent":["import type * as RDF from '@rdfjs/types';\nimport type { Algebra } from 'sparqlalgebrajs';\nimport type { IAggregatorClass } from '../../aggregators';\nimport { aggregators } from '../../aggregators';\nimport type { BaseAggregator } from '../../aggregators/BaseAggregator';\nimport type { SetFunction } from '../../util/Consts';\nimport * as Err from '../../util/Errors';\nimport type { ICompleteSharedContext } from './BaseExpressionEvaluator';\n\nexport abstract class BaseAggregateEvaluator {\n  protected expression: Algebra.AggregateExpression;\n  protected aggregator: BaseAggregator<any>;\n  protected throwError = false;\n  protected state: any;\n\n  protected constructor(expr: Algebra.AggregateExpression,\n    sharedContext: ICompleteSharedContext, throwError?: boolean) {\n    this.expression = expr;\n    this.aggregator = new aggregators[<SetFunction> expr.aggregator](expr, sharedContext);\n    this.throwError = throwError || false;\n  }\n\n  /**\n   * The spec says to throw an error when a set function is called on an empty\n   * set (unless explicitly mentioned otherwise like COUNT).\n   * However, aggregate error handling says to not bind the result in case of an\n   * error. So to simplify logic in the caller, we return undefined by default.\n   *\n   * @param throwError whether this function should respect the spec and throw an error if no empty value is defined\n   */\n  public static emptyValue(expr: Algebra.AggregateExpression, throwError = false): RDF.Term | undefined {\n    const val = aggregators[<SetFunction> expr.aggregator].emptyValue();\n    if (val === undefined && throwError) {\n      throw new Err.EmptyAggregateError();\n    }\n    return val;\n  }\n\n  public result(): RDF.Term | undefined {\n    return (<IAggregatorClass> this.aggregator.constructor).emptyValue();\n  }\n\n  /**\n   * Put a binding from the result stream in the aggregate state.\n   *\n   * If any binding evaluation errors, the corresponding aggregate variable should be unbound.\n   * If this happens, calling @see result() will return @constant undefined\n   *\n   * @param bindings the bindings to pass to the expression\n   */\n  abstract put(bindings: RDF.Bindings): void | Promise<void>;\n\n  /**\n   * The actual result method. When the first binding has been given, and the state\n   * of the evaluators initialised. The .result API function will be replaced with this\n   * function, which implements the behaviour we want.\n   *\n   * @param bindings the bindings to pass to the expression\n   */\n  protected __result(): RDF.Term {\n    return this.aggregator.result(this.state);\n  }\n\n  /**\n   * The actual put method. When the first binding has been given, and the state\n   * of the evaluators initialised. The .put API function will be replaced with this\n   * function, which implements the behaviour we want.\n   *\n   * @param bindings the bindings to pass to the expression\n   */\n  protected abstract __put(bindings: RDF.Bindings): void | Promise<void>;\n\n  protected abstract safeThrow(err: unknown): void;\n}\n"]}
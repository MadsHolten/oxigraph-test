{"version":3,"file":"SyncRecursiveEvaluator.js","sourceRoot":"","sources":["../../../../lib/evaluators/evaluatorHelpers/SyncRecursiveEvaluator.ts"],"names":[],"mappings":"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","sourcesContent":["import type * as RDF from '@rdfjs/types';\nimport type { Algebra as Alg } from 'sparqlalgebrajs';\nimport * as E from '../../expressions';\nimport type { SyncExtension } from '../../expressions';\nimport type { EvalContextSync } from '../../functions';\nimport type { ITermTransformer } from '../../transformers/TermTransformer';\nimport { TermTransformer } from '../../transformers/TermTransformer';\nimport type { IExpressionEvaluator } from '../../Types';\nimport * as Err from '../../util/Errors';\nimport type { ISuperTypeProvider } from '../../util/TypeHandling';\nimport type { SyncExtensionFunctionCreator } from '../SyncEvaluator';\nimport type { ICompleteSharedContext } from './BaseExpressionEvaluator';\nimport { BaseExpressionEvaluator } from './BaseExpressionEvaluator';\n\nexport interface ICompleteSyncEvaluatorContext extends ICompleteSharedContext {\n  exists?: (expression: Alg.ExistenceExpression, mapping: RDF.Bindings) => boolean;\n  aggregate?: (expression: Alg.AggregateExpression) => RDF.Term;\n  bnode?: (input?: string) => RDF.BlankNode;\n  extensionFunctionCreator?: SyncExtensionFunctionCreator;\n}\n\nexport class SyncRecursiveEvaluator extends BaseExpressionEvaluator\n  implements IExpressionEvaluator<E.Expression, E.Term> {\n  protected openWorldType: ISuperTypeProvider;\n  private readonly subEvaluators: Record<string, (expr: E.Expression, mapping: RDF.Bindings) => E.Term> = {\n    // Shared\n    [E.ExpressionType.Term]: this.term.bind(this),\n    [E.ExpressionType.Variable]: this.variable.bind(this),\n\n    // Sync\n    [E.ExpressionType.Operator]: this.evalOperator.bind(this),\n    [E.ExpressionType.SpecialOperator]: this.evalSpecialOperator.bind(this),\n    [E.ExpressionType.Named]: this.evalNamed.bind(this),\n    [E.ExpressionType.Existence]: this.evalExistence.bind(this),\n    [E.ExpressionType.Aggregate]: this.evalAggregate.bind(this),\n    [E.ExpressionType.SyncExtension]: this.evalSyncExtension.bind(this),\n  };\n\n  public constructor(private readonly context: ICompleteSyncEvaluatorContext, termTransformer?: ITermTransformer) {\n    super(termTransformer || new TermTransformer(context.superTypeProvider, context.enableExtendedXsdTypes));\n  }\n\n  public evaluate(expr: E.Expression, mapping: RDF.Bindings): E.Term {\n    const evaluator = this.subEvaluators[expr.expressionType];\n    if (!evaluator) {\n      throw new Err.InvalidExpressionType(expr);\n    }\n    return evaluator.bind(this)(expr, mapping);\n  }\n\n  private evalOperator(expr: E.Operator, mapping: RDF.Bindings): E.Term {\n    const args = expr.args.map(arg => this.evaluate(arg, mapping));\n    return expr.apply(args);\n  }\n\n  private evalSpecialOperator(expr: E.SpecialOperator, mapping: RDF.Bindings): E.Term {\n    const evaluate = this.evaluate.bind(this);\n    const context: EvalContextSync = {\n      args: expr.args,\n      mapping,\n\n      superTypeProvider: this.context.superTypeProvider,\n      now: this.context.now,\n      baseIRI: this.context.baseIRI,\n      overloadCache: this.context.overloadCache,\n\n      evaluate,\n      bnode: this.context.bnode,\n      enableExtendedXsdTypes: this.context.enableExtendedXsdTypes,\n    };\n    return expr.applySync(context);\n  }\n\n  private evalNamed(expr: E.Named, mapping: RDF.Bindings): E.Term {\n    const args = expr.args.map(arg => this.evaluate(arg, mapping));\n    return expr.apply(args);\n  }\n\n  private evalSyncExtension(expr: SyncExtension, mapping: RDF.Bindings): E.Term {\n    const args = expr.args.map(arg => this.evaluate(arg, mapping));\n    return expr.apply(args);\n  }\n\n  private evalExistence(expr: E.Existence, mapping: RDF.Bindings): E.Term {\n    if (!this.context.exists) {\n      throw new Err.NoExistenceHook();\n    }\n\n    return new E.BooleanLiteral(this.context.exists(expr.expression, mapping));\n  }\n\n  private evalAggregate(expr: E.Aggregate, mapping: RDF.Bindings): E.Term {\n    if (!this.context.aggregate) {\n      throw new Err.NoAggregator();\n    }\n\n    return this.termTransformer.transformRDFTermUnsafe(this.context.aggregate(expr.expression));\n  }\n}\n"]}
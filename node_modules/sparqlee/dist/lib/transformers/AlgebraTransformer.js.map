{"version":3,"file":"AlgebraTransformer.js","sourceRoot":"","sources":["../../../lib/transformers/AlgebraTransformer.ts"],"names":[],"mappings":"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","sourcesContent":["import { Algebra as Alg } from 'sparqlalgebrajs';\nimport type { AsyncExtensionFunction, AsyncExtensionFunctionCreator } from '../evaluators/AsyncEvaluator';\nimport type { ICompleteSharedContext } from '../evaluators/evaluatorHelpers/BaseExpressionEvaluator';\nimport type { SyncExtensionFunction, SyncExtensionFunctionCreator } from '../evaluators/SyncEvaluator';\nimport * as E from '../expressions';\nimport type { AsyncExtensionApplication, SimpleApplication } from '../expressions';\nimport { namedFunctions, regularFunctions, specialFunctions } from '../functions';\nimport * as C from '../util/Consts';\nimport * as Err from '../util/Errors';\nimport { ExtensionFunctionError } from '../util/Errors';\nimport type { ITermTransformer } from './TermTransformer';\nimport { TermTransformer } from './TermTransformer';\n\ntype FunctionCreatorConfig = { type: 'sync'; creator: SyncExtensionFunctionCreator } |\n{ type: 'async'; creator: AsyncExtensionFunctionCreator };\n\ntype AlgebraTransformConfig = ICompleteSharedContext & FunctionCreatorConfig;\n\nexport interface IAlgebraTransformer extends ITermTransformer{\n  transformAlgebra: (expr: Alg.Expression) => E.Expression;\n}\n\nexport class AlgebraTransformer extends TermTransformer implements IAlgebraTransformer {\n  private readonly creatorConfig: FunctionCreatorConfig;\n  public constructor(protected readonly algebraConfig: AlgebraTransformConfig) {\n    super(algebraConfig.superTypeProvider, algebraConfig.enableExtendedXsdTypes);\n    this.creatorConfig = <FunctionCreatorConfig> { type: algebraConfig.type, creator: algebraConfig.creator };\n  }\n\n  public transformAlgebra(expr: Alg.Expression): E.Expression {\n    if (!expr) {\n      throw new Err.InvalidExpression(expr);\n    }\n    const types = Alg.expressionTypes;\n\n    switch (expr.expressionType) {\n      case types.TERM:\n        return this.transformTerm(expr);\n      case types.OPERATOR:\n        return this.transformOperator(expr);\n      case types.NAMED:\n        return this.transformNamed(expr);\n      case types.EXISTENCE:\n        return AlgebraTransformer.transformExistence(expr);\n      case types.AGGREGATE:\n        return AlgebraTransformer.transformAggregate(expr);\n      case types.WILDCARD:\n        return AlgebraTransformer.transformWildcard(expr);\n      default:\n        throw new Err.InvalidExpressionType(expr);\n    }\n  }\n\n  private static transformWildcard(term: Alg.WildcardExpression): E.Expression {\n    if (!term.wildcard) {\n      throw new Err.InvalidExpression(term);\n    }\n\n    return new E.NamedNode(term.wildcard.value);\n  }\n\n  private transformOperator(expr: Alg.OperatorExpression): E.OperatorExpression | E.SpecialOperatorExpression {\n    if (C.SpecialOperators.has(expr.operator)) {\n      const specialOp = <C.SpecialOperator>expr.operator;\n      const specialArgs = expr.args.map(arg => this.transformAlgebra(arg));\n      const specialFunc = specialFunctions[specialOp];\n      if (!specialFunc.checkArity(specialArgs)) {\n        throw new Err.InvalidArity(specialArgs, specialOp);\n      }\n      return new E.SpecialOperator(specialArgs, specialFunc.applyAsync, specialFunc.applySync);\n    }\n    if (!C.Operators.has(expr.operator)) {\n      throw new Err.UnknownOperator(expr.operator);\n    }\n    const regularOp = <C.RegularOperator>expr.operator;\n    const regularArgs = expr.args.map(arg => this.transformAlgebra(arg));\n    const regularFunc = regularFunctions[regularOp];\n    if (!AlgebraTransformer.hasCorrectArity(regularArgs, regularFunc.arity)) {\n      throw new Err.InvalidArity(regularArgs, regularOp);\n    }\n    return new E.Operator(regularArgs, args => regularFunc.apply(args, this.algebraConfig));\n  }\n\n  private wrapSyncFunction(func: SyncExtensionFunction, name: string): SimpleApplication {\n    return args => {\n      try {\n        const res = func(args.map(arg => arg.toRDF()));\n        return this.transformRDFTermUnsafe(res);\n      } catch (error: unknown) {\n        throw new ExtensionFunctionError(name, error);\n      }\n    };\n  }\n\n  private wrapAsyncFunction(func: AsyncExtensionFunction, name: string): AsyncExtensionApplication {\n    return async args => {\n      try {\n        const res = await func(args.map(arg => arg.toRDF()));\n        return this.transformRDFTermUnsafe(res);\n      } catch (error: unknown) {\n        throw new ExtensionFunctionError(name, error);\n      }\n    };\n  }\n\n  // TODO: Support passing functions to override default behaviour;\n  private transformNamed(expr: Alg.NamedExpression):\n  E.NamedExpression | E.AsyncExtensionExpression | E.SyncExtensionExpression {\n    const funcName = expr.name.value;\n    const namedArgs = expr.args.map(arg => this.transformAlgebra(arg));\n    if (C.NamedOperators.has(<C.NamedOperator>funcName)) {\n      // Return a basic named expression\n      const op = <C.NamedOperator>expr.name.value;\n      const namedFunc = namedFunctions[op];\n      return new E.Named(expr.name, namedArgs, args => namedFunc.apply(args, this.algebraConfig));\n    }\n    if (this.creatorConfig.type === 'sync') {\n      // Expression might be extension function, check this for the sync\n      const syncExtensionFunc = this.creatorConfig.creator(expr.name);\n      if (syncExtensionFunc) {\n        const simpleAppl = this.wrapSyncFunction(syncExtensionFunc, expr.name.value);\n        return new E.SyncExtension(expr.name, namedArgs, simpleAppl);\n      }\n    } else {\n      // The expression might be an extension function, check this for the async case\n      const asyncExtensionFunc = this.creatorConfig.creator(expr.name);\n      if (asyncExtensionFunc) {\n        const asyncAppl = this.wrapAsyncFunction(asyncExtensionFunc, expr.name.value);\n        return new E.AsyncExtension(expr.name, namedArgs, asyncAppl);\n      }\n    }\n    throw new Err.UnknownNamedOperator(expr.name.value);\n  }\n\n  private static hasCorrectArity(args: E.Expression[], arity: number | number[]): boolean {\n    // Infinity is used to represent var-args, so it's always correct.\n    if (arity === Number.POSITIVE_INFINITY) {\n      return true;\n    }\n\n    // If the function has overloaded arity, the actual arity needs to be present.\n    if (Array.isArray(arity)) {\n      return arity.includes(args.length);\n    }\n\n    return args.length === arity;\n  }\n\n  public static transformAggregate(expr: Alg.AggregateExpression): E.Aggregate {\n    const name = expr.aggregator;\n    return new E.Aggregate(name, expr);\n  }\n\n  public static transformExistence(expr: Alg.ExistenceExpression): E.Existence {\n    return new E.Existence(expr);\n  }\n}\n"]}
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AlgebraTransformer = void 0;
const sparqlalgebrajs_1 = require("sparqlalgebrajs");
const E = require("../expressions");
const functions_1 = require("../functions");
const C = require("../util/Consts");
const Err = require("../util/Errors");
const Errors_1 = require("../util/Errors");
const TermTransformer_1 = require("./TermTransformer");
class AlgebraTransformer extends TermTransformer_1.TermTransformer {
    constructor(algebraConfig) {
        super(algebraConfig.superTypeProvider, algebraConfig.enableExtendedXsdTypes);
        this.algebraConfig = algebraConfig;
        this.creatorConfig = { type: algebraConfig.type, creator: algebraConfig.creator };
    }
    transformAlgebra(expr) {
        if (!expr) {
            throw new Err.InvalidExpression(expr);
        }
        const types = sparqlalgebrajs_1.Algebra.expressionTypes;
        switch (expr.expressionType) {
            case types.TERM:
                return this.transformTerm(expr);
            case types.OPERATOR:
                return this.transformOperator(expr);
            case types.NAMED:
                return this.transformNamed(expr);
            case types.EXISTENCE:
                return AlgebraTransformer.transformExistence(expr);
            case types.AGGREGATE:
                return AlgebraTransformer.transformAggregate(expr);
            case types.WILDCARD:
                return AlgebraTransformer.transformWildcard(expr);
            default:
                throw new Err.InvalidExpressionType(expr);
        }
    }
    static transformWildcard(term) {
        if (!term.wildcard) {
            throw new Err.InvalidExpression(term);
        }
        return new E.NamedNode(term.wildcard.value);
    }
    transformOperator(expr) {
        if (C.SpecialOperators.has(expr.operator)) {
            const specialOp = expr.operator;
            const specialArgs = expr.args.map(arg => this.transformAlgebra(arg));
            const specialFunc = functions_1.specialFunctions[specialOp];
            if (!specialFunc.checkArity(specialArgs)) {
                throw new Err.InvalidArity(specialArgs, specialOp);
            }
            return new E.SpecialOperator(specialArgs, specialFunc.applyAsync, specialFunc.applySync);
        }
        if (!C.Operators.has(expr.operator)) {
            throw new Err.UnknownOperator(expr.operator);
        }
        const regularOp = expr.operator;
        const regularArgs = expr.args.map(arg => this.transformAlgebra(arg));
        const regularFunc = functions_1.regularFunctions[regularOp];
        if (!AlgebraTransformer.hasCorrectArity(regularArgs, regularFunc.arity)) {
            throw new Err.InvalidArity(regularArgs, regularOp);
        }
        return new E.Operator(regularArgs, args => regularFunc.apply(args, this.algebraConfig));
    }
    wrapSyncFunction(func, name) {
        return args => {
            try {
                const res = func(args.map(arg => arg.toRDF()));
                return this.transformRDFTermUnsafe(res);
            }
            catch (error) {
                throw new Errors_1.ExtensionFunctionError(name, error);
            }
        };
    }
    wrapAsyncFunction(func, name) {
        return async (args) => {
            try {
                const res = await func(args.map(arg => arg.toRDF()));
                return this.transformRDFTermUnsafe(res);
            }
            catch (error) {
                throw new Errors_1.ExtensionFunctionError(name, error);
            }
        };
    }
    // TODO: Support passing functions to override default behaviour;
    transformNamed(expr) {
        const funcName = expr.name.value;
        const namedArgs = expr.args.map(arg => this.transformAlgebra(arg));
        if (C.NamedOperators.has(funcName)) {
            // Return a basic named expression
            const op = expr.name.value;
            const namedFunc = functions_1.namedFunctions[op];
            return new E.Named(expr.name, namedArgs, args => namedFunc.apply(args, this.algebraConfig));
        }
        if (this.creatorConfig.type === 'sync') {
            // Expression might be extension function, check this for the sync
            const syncExtensionFunc = this.creatorConfig.creator(expr.name);
            if (syncExtensionFunc) {
                const simpleAppl = this.wrapSyncFunction(syncExtensionFunc, expr.name.value);
                return new E.SyncExtension(expr.name, namedArgs, simpleAppl);
            }
        }
        else {
            // The expression might be an extension function, check this for the async case
            const asyncExtensionFunc = this.creatorConfig.creator(expr.name);
            if (asyncExtensionFunc) {
                const asyncAppl = this.wrapAsyncFunction(asyncExtensionFunc, expr.name.value);
                return new E.AsyncExtension(expr.name, namedArgs, asyncAppl);
            }
        }
        throw new Err.UnknownNamedOperator(expr.name.value);
    }
    static hasCorrectArity(args, arity) {
        // Infinity is used to represent var-args, so it's always correct.
        if (arity === Number.POSITIVE_INFINITY) {
            return true;
        }
        // If the function has overloaded arity, the actual arity needs to be present.
        if (Array.isArray(arity)) {
            return arity.includes(args.length);
        }
        return args.length === arity;
    }
    static transformAggregate(expr) {
        const name = expr.aggregator;
        return new E.Aggregate(name, expr);
    }
    static transformExistence(expr) {
        return new E.Existence(expr);
    }
}
exports.AlgebraTransformer = AlgebraTransformer;
//# sourceMappingURL=AlgebraTransformer.js.map
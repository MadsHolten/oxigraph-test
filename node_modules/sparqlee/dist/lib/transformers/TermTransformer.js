"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TermTransformer = void 0;
const RDFString = require("rdf-string");
const sparqlalgebrajs_1 = require("sparqlalgebrajs");
const E = require("../expressions");
const Consts_1 = require("../util/Consts");
const Err = require("../util/Errors");
const P = require("../util/Parsing");
const TypeHandling_1 = require("../util/TypeHandling");
class TermTransformer {
    constructor(superTypeProvider, enableExtendedXSDTypes) {
        this.superTypeProvider = superTypeProvider;
        this.enableExtendedXSDTypes = enableExtendedXSDTypes;
    }
    /**
     * Transforms an RDF term to the internal representation of a term,
     * assuming it is not a variable, which would be an expression (internally).
     *
     * @param term RDF term to transform into internal representation of a term
     */
    transformRDFTermUnsafe(term) {
        return this.transformTerm({
            term,
            type: sparqlalgebrajs_1.Algebra.types.EXPRESSION,
            expressionType: sparqlalgebrajs_1.Algebra.expressionTypes.TERM,
        });
    }
    transformTerm(term) {
        if (!term.term) {
            throw new Err.InvalidExpression(term);
        }
        switch (term.term.termType) {
            case 'Variable':
                return new E.Variable(RDFString.termToString(term.term));
            case 'Literal':
                return this.transformLiteral(term.term);
            case 'NamedNode':
                return new E.NamedNode(term.term.value);
            case 'BlankNode':
                return new E.BlankNode(term.term.value);
            default:
                throw new Err.InvalidTermType(term);
        }
    }
    legacyTransformLiteral(lit) {
        // We transform to StringLiteral when we detect a simple literal being used.
        // Original issue regarding this behaviour: https://github.com/w3c/sparql-12/issues/112
        if (!lit.datatype) {
            return lit.language ?
                new E.LangStringLiteral(lit.value, lit.language) :
                new E.StringLiteral(lit.value);
        }
        const dataType = lit.datatype.value;
        switch (dataType) {
            case null:
            case undefined:
            case '': {
                return lit.language ?
                    new E.LangStringLiteral(lit.value, lit.language) :
                    new E.StringLiteral(lit.value);
            }
            case Consts_1.TypeURL.XSD_ANY_URI:
            case Consts_1.TypeURL.XSD_NORMALIZED_STRING:
            case Consts_1.TypeURL.XSD_TOKEN:
            case Consts_1.TypeURL.XSD_LANGUAGE:
            case Consts_1.TypeURL.XSD_NM_TOKEN:
            case Consts_1.TypeURL.XSD_NAME:
            case Consts_1.TypeURL.XSD_ENTITY:
            case Consts_1.TypeURL.XSD_ID:
            case Consts_1.TypeURL.XSD_ID_REF:
            case Consts_1.TypeURL.XSD_STRING: return new E.StringLiteral(lit.value, dataType);
            case Consts_1.TypeURL.RDF_LANG_STRING: return new E.LangStringLiteral(lit.value, lit.language);
            case Consts_1.TypeURL.XSD_DATE_TIME_STAMP:
            case Consts_1.TypeURL.XSD_DATE_TIME: {
                const dateVal = new Date(lit.value);
                if (Number.isNaN(dateVal.getTime())) {
                    return new E.NonLexicalLiteral(undefined, dataType, this.superTypeProvider, lit.value);
                }
                return new E.DateTimeLiteral(new Date(lit.value), lit.value, dataType);
            }
            case Consts_1.TypeURL.XSD_BOOLEAN: {
                if (lit.value !== 'true' && lit.value !== 'false' && lit.value !== '1' && lit.value !== '0') {
                    return new E.NonLexicalLiteral(undefined, dataType, this.superTypeProvider, lit.value);
                }
                return new E.BooleanLiteral(lit.value === 'true' || lit.value === '1', lit.value, dataType);
            }
            case Consts_1.TypeURL.XSD_DECIMAL: {
                const decimalVal = P.parseXSDDecimal(lit.value);
                if (decimalVal === undefined) {
                    return new E.NonLexicalLiteral(undefined, dataType, this.superTypeProvider, lit.value);
                }
                return new E.DecimalLiteral(decimalVal, dataType, lit.value);
            }
            case Consts_1.TypeURL.XSD_FLOAT: {
                const floatVal = P.parseXSDFloat(lit.value);
                if (floatVal === undefined) {
                    return new E.NonLexicalLiteral(undefined, dataType, this.superTypeProvider, lit.value);
                }
                return new E.FloatLiteral(floatVal, dataType, lit.value);
            }
            case Consts_1.TypeURL.XSD_DOUBLE: {
                const doubleVal = P.parseXSDFloat(lit.value);
                if (doubleVal === undefined) {
                    return new E.NonLexicalLiteral(undefined, dataType, this.superTypeProvider, lit.value);
                }
                return new E.DoubleLiteral(doubleVal, dataType, lit.value);
            }
            case Consts_1.TypeURL.XSD_NON_POSITIVE_INTEGER:
            case Consts_1.TypeURL.XSD_NEGATIVE_INTEGER:
            case Consts_1.TypeURL.XSD_LONG:
            case Consts_1.TypeURL.XSD_INT:
            case Consts_1.TypeURL.XSD_SHORT:
            case Consts_1.TypeURL.XSD_BYTE:
            case Consts_1.TypeURL.XSD_NON_NEGATIVE_INTEGER:
            case Consts_1.TypeURL.XSD_POSITIVE_INTEGER:
            case Consts_1.TypeURL.XSD_UNSIGNED_LONG:
            case Consts_1.TypeURL.XSD_UNSIGNED_INT:
            case Consts_1.TypeURL.XSD_UNSIGNED_SHORT:
            case Consts_1.TypeURL.XSD_UNSIGNED_BYTE:
            case Consts_1.TypeURL.XSD_INTEGER: {
                const intVal = P.parseXSDDecimal(lit.value);
                if (intVal === undefined) {
                    return new E.NonLexicalLiteral(undefined, dataType, this.superTypeProvider, lit.value);
                }
                return new E.IntegerLiteral(intVal, dataType, lit.value);
            }
            default: return new E.Literal(lit.value, dataType, lit.value);
        }
    }
    transformLiteral(lit) {
        return this.enableExtendedXSDTypes ? this.experimentalTransformLiteral(lit) : this.legacyTransformLiteral(lit);
    }
    /**
     * @param lit the rdf literal we want to transform to an internal Literal expression.
     */
    experimentalTransformLiteral(lit) {
        // Both here and within the switch we transform to LangStringLiteral or StringLiteral.
        // We do this when we detect a simple literal being used.
        // Original issue regarding this behaviour: https://github.com/w3c/sparql-12/issues/112
        if (!lit.datatype || [null, undefined, ''].includes(lit.datatype.value)) {
            return lit.language ?
                new E.LangStringLiteral(lit.value, lit.language) :
                new E.StringLiteral(lit.value);
        }
        const dataType = lit.datatype.value;
        const superTypeDict = (0, TypeHandling_1.getSuperTypeDict)(dataType, this.superTypeProvider);
        if (Consts_1.TypeURL.XSD_STRING in superTypeDict) {
            return new E.StringLiteral(lit.value, dataType);
        }
        if (Consts_1.TypeURL.RDF_LANG_STRING in superTypeDict) {
            return new E.LangStringLiteral(lit.value, lit.language);
        }
        if (Consts_1.TypeURL.XSD_DATE_TIME in superTypeDict) {
            // It should be noted how we don't care if its a XSD_DATE_TIME_STAMP or not.
            // This is because sparql functions don't care about the timezone.
            // It's also doesn't break the specs because we keep the string representation stored,
            // that way we can always give it back. There are also no sparql functions that alter a date.
            // (So the initial representation always stays valid)
            // https://github.com/comunica/sparqlee/pull/103#discussion_r688462368
            const dateVal = new Date(lit.value);
            if (Number.isNaN(dateVal.getTime())) {
                return new E.NonLexicalLiteral(undefined, dataType, this.superTypeProvider, lit.value);
            }
            return new E.DateTimeLiteral(new Date(lit.value), lit.value, dataType);
        }
        if (Consts_1.TypeURL.XSD_BOOLEAN in superTypeDict) {
            if (lit.value !== 'true' && lit.value !== 'false' && lit.value !== '1' && lit.value !== '0') {
                return new E.NonLexicalLiteral(undefined, dataType, this.superTypeProvider, lit.value);
            }
            return new E.BooleanLiteral(lit.value === 'true' || lit.value === '1', lit.value);
        }
        if (Consts_1.TypeURL.XSD_DECIMAL in superTypeDict) {
            const intVal = P.parseXSDDecimal(lit.value);
            if (intVal === undefined) {
                return new E.NonLexicalLiteral(undefined, dataType, this.superTypeProvider, lit.value);
            }
            if (Consts_1.TypeURL.XSD_INTEGER in superTypeDict) {
                return new E.IntegerLiteral(intVal, dataType, lit.value);
            }
            // If type is not an integer it's just a decimal.
            return new E.DecimalLiteral(intVal, dataType, lit.value);
        }
        const isFloat = Consts_1.TypeURL.XSD_FLOAT in superTypeDict;
        const isDouble = Consts_1.TypeURL.XSD_DOUBLE in superTypeDict;
        if (isFloat || isDouble) {
            const doubleVal = P.parseXSDFloat(lit.value);
            if (doubleVal === undefined) {
                return new E.NonLexicalLiteral(undefined, dataType, this.superTypeProvider, lit.value);
            }
            if (isFloat) {
                return new E.FloatLiteral(doubleVal, dataType, lit.value);
            }
            return new E.DoubleLiteral(doubleVal, dataType, lit.value);
        }
        return new E.Literal(lit.value, dataType, lit.value);
    }
}
exports.TermTransformer = TermTransformer;
//# sourceMappingURL=TermTransformer.js.map
{"version":3,"file":"TermTransformer.js","sourceRoot":"","sources":["../../../lib/transformers/TermTransformer.ts"],"names":[],"mappings":";;;AACA,wCAAwC;AAExC,qDAA0C;AAC1C,oCAAoC;AACpC,2CAAwD;AACxD,sCAAsC;AACtC,qCAAqC;AACrC,uDAAwD;AASxD,MAAa,eAAe;IAC1B,YAAsC,iBAAqC,EACtD,sBAA+B;QADd,sBAAiB,GAAjB,iBAAiB,CAAoB;QACtD,2BAAsB,GAAtB,sBAAsB,CAAS;IAAI,CAAC;IAEzD;;;;;OAKG;IACI,sBAAsB,CAAC,IAAc;QAC1C,OAAgB,IAAI,CAAC,aAAa,CAAC;YACjC,IAAI;YACJ,IAAI,EAAE,yBAAO,CAAC,KAAK,CAAC,UAAU;YAC9B,cAAc,EAAE,yBAAO,CAAC,eAAe,CAAC,IAAI;SAC7C,CAAC,CAAC;IACL,CAAC;IAES,aAAa,CAAC,IAAwB;QAC9C,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE;YACd,MAAM,IAAI,GAAG,CAAC,iBAAiB,CAAC,IAAI,CAAC,CAAC;SACvC;QAED,QAAQ,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE;YAC1B,KAAK,UAAU;gBACb,OAAO,IAAI,CAAC,CAAC,QAAQ,CAAC,SAAS,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;YAC3D,KAAK,SAAS;gBACZ,OAAO,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YAC1C,KAAK,WAAW;gBACd,OAAO,IAAI,CAAC,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;YAC1C,KAAK,WAAW;gBACd,OAAO,IAAI,CAAC,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;YAC1C;gBACE,MAAM,IAAI,GAAG,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;SACvC;IACH,CAAC;IAEO,sBAAsB,CAAC,GAAgB;QAC7C,4EAA4E;QAC5E,uFAAuF;QAEvF,IAAI,CAAC,GAAG,CAAC,QAAQ,EAAE;YACjB,OAAO,GAAG,CAAC,QAAQ,CAAC,CAAC;gBACnB,IAAI,CAAC,CAAC,iBAAiB,CAAC,GAAG,CAAC,KAAK,EAAE,GAAG,CAAC,QAAQ,CAAC,CAAC,CAAC;gBAClD,IAAI,CAAC,CAAC,aAAa,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;SAClC;QACD,MAAM,QAAQ,GAAG,GAAG,CAAC,QAAQ,CAAC,KAAK,CAAC;QACpC,QAAQ,QAAQ,EAAE;YAChB,KAAK,IAAI,CAAC;YACV,KAAK,SAAS,CAAC;YACf,KAAK,EAAE,CAAC,CAAC;gBACP,OAAO,GAAG,CAAC,QAAQ,CAAC,CAAC;oBACnB,IAAI,CAAC,CAAC,iBAAiB,CAAC,GAAG,CAAC,KAAK,EAAE,GAAG,CAAC,QAAQ,CAAC,CAAC,CAAC;oBAClD,IAAI,CAAC,CAAC,aAAa,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;aAClC;YACD,KAAK,gBAAO,CAAC,WAAW,CAAC;YACzB,KAAK,gBAAO,CAAC,qBAAqB,CAAC;YACnC,KAAK,gBAAO,CAAC,SAAS,CAAC;YACvB,KAAK,gBAAO,CAAC,YAAY,CAAC;YAC1B,KAAK,gBAAO,CAAC,YAAY,CAAC;YAC1B,KAAK,gBAAO,CAAC,QAAQ,CAAC;YACtB,KAAK,gBAAO,CAAC,UAAU,CAAC;YACxB,KAAK,gBAAO,CAAC,MAAM,CAAC;YACpB,KAAK,gBAAO,CAAC,UAAU,CAAC;YACxB,KAAK,gBAAO,CAAC,UAAU,CAAC,CAAC,OAAO,IAAI,CAAC,CAAC,aAAa,CAAC,GAAG,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;YAEzE,KAAK,gBAAO,CAAC,eAAe,CAAC,CAAC,OAAO,IAAI,CAAC,CAAC,iBAAiB,CAAC,GAAG,CAAC,KAAK,EAAE,GAAG,CAAC,QAAQ,CAAC,CAAC;YAEtF,KAAK,gBAAO,CAAC,mBAAmB,CAAC;YACjC,KAAK,gBAAO,CAAC,aAAa,CAAC,CAAC;gBAC1B,MAAM,OAAO,GAAS,IAAI,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;gBAC1C,IAAI,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,OAAO,EAAE,CAAC,EAAE;oBACnC,OAAO,IAAI,CAAC,CAAC,iBAAiB,CAAC,SAAS,EAAE,QAAQ,EAAE,IAAI,CAAC,iBAAiB,EAAE,GAAG,CAAC,KAAK,CAAC,CAAC;iBACxF;gBACD,OAAO,IAAI,CAAC,CAAC,eAAe,CAAC,IAAI,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE,GAAG,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;aACxE;YAED,KAAK,gBAAO,CAAC,WAAW,CAAC,CAAC;gBACxB,IAAI,GAAG,CAAC,KAAK,KAAK,MAAM,IAAI,GAAG,CAAC,KAAK,KAAK,OAAO,IAAI,GAAG,CAAC,KAAK,KAAK,GAAG,IAAI,GAAG,CAAC,KAAK,KAAK,GAAG,EAAE;oBAC3F,OAAO,IAAI,CAAC,CAAC,iBAAiB,CAAC,SAAS,EAAE,QAAQ,EAAE,IAAI,CAAC,iBAAiB,EAAE,GAAG,CAAC,KAAK,CAAC,CAAC;iBACxF;gBACD,OAAO,IAAI,CAAC,CAAC,cAAc,CAAC,GAAG,CAAC,KAAK,KAAK,MAAM,IAAI,GAAG,CAAC,KAAK,KAAK,GAAG,EAAE,GAAG,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;aAC7F;YAED,KAAK,gBAAO,CAAC,WAAW,CAAC,CAAC;gBACxB,MAAM,UAAU,GAAuB,CAAC,CAAC,eAAe,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;gBACpE,IAAI,UAAU,KAAK,SAAS,EAAE;oBAC5B,OAAO,IAAI,CAAC,CAAC,iBAAiB,CAAC,SAAS,EAAE,QAAQ,EAAE,IAAI,CAAC,iBAAiB,EAAE,GAAG,CAAC,KAAK,CAAC,CAAC;iBACxF;gBACD,OAAO,IAAI,CAAC,CAAC,cAAc,CAAC,UAAU,EAAE,QAAQ,EAAE,GAAG,CAAC,KAAK,CAAC,CAAC;aAC9D;YACD,KAAK,gBAAO,CAAC,SAAS,CAAC,CAAC;gBACtB,MAAM,QAAQ,GAAuB,CAAC,CAAC,aAAa,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;gBAChE,IAAI,QAAQ,KAAK,SAAS,EAAE;oBAC1B,OAAO,IAAI,CAAC,CAAC,iBAAiB,CAAC,SAAS,EAAE,QAAQ,EAAE,IAAI,CAAC,iBAAiB,EAAE,GAAG,CAAC,KAAK,CAAC,CAAC;iBACxF;gBACD,OAAO,IAAI,CAAC,CAAC,YAAY,CAAC,QAAQ,EAAE,QAAQ,EAAE,GAAG,CAAC,KAAK,CAAC,CAAC;aAC1D;YAED,KAAK,gBAAO,CAAC,UAAU,CAAC,CAAC;gBACvB,MAAM,SAAS,GAAuB,CAAC,CAAC,aAAa,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;gBACjE,IAAI,SAAS,KAAK,SAAS,EAAE;oBAC3B,OAAO,IAAI,CAAC,CAAC,iBAAiB,CAAC,SAAS,EAAE,QAAQ,EAAE,IAAI,CAAC,iBAAiB,EAAE,GAAG,CAAC,KAAK,CAAC,CAAC;iBACxF;gBACD,OAAO,IAAI,CAAC,CAAC,aAAa,CAAC,SAAS,EAAE,QAAQ,EAAE,GAAG,CAAC,KAAK,CAAC,CAAC;aAC5D;YAED,KAAK,gBAAO,CAAC,wBAAwB,CAAC;YACtC,KAAK,gBAAO,CAAC,oBAAoB,CAAC;YAClC,KAAK,gBAAO,CAAC,QAAQ,CAAC;YACtB,KAAK,gBAAO,CAAC,OAAO,CAAC;YACrB,KAAK,gBAAO,CAAC,SAAS,CAAC;YACvB,KAAK,gBAAO,CAAC,QAAQ,CAAC;YACtB,KAAK,gBAAO,CAAC,wBAAwB,CAAC;YACtC,KAAK,gBAAO,CAAC,oBAAoB,CAAC;YAClC,KAAK,gBAAO,CAAC,iBAAiB,CAAC;YAC/B,KAAK,gBAAO,CAAC,gBAAgB,CAAC;YAC9B,KAAK,gBAAO,CAAC,kBAAkB,CAAC;YAChC,KAAK,gBAAO,CAAC,iBAAiB,CAAC;YAC/B,KAAK,gBAAO,CAAC,WAAW,CAAC,CAAC;gBACxB,MAAM,MAAM,GAAuB,CAAC,CAAC,eAAe,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;gBAChE,IAAI,MAAM,KAAK,SAAS,EAAE;oBACxB,OAAO,IAAI,CAAC,CAAC,iBAAiB,CAAC,SAAS,EAAE,QAAQ,EAAE,IAAI,CAAC,iBAAiB,EAAE,GAAG,CAAC,KAAK,CAAC,CAAC;iBACxF;gBACD,OAAO,IAAI,CAAC,CAAC,cAAc,CAAC,MAAM,EAAE,QAAQ,EAAE,GAAG,CAAC,KAAK,CAAC,CAAC;aAC1D;YAED,OAAO,CAAC,CAAC,OAAO,IAAI,CAAC,CAAC,OAAO,CAAS,GAAG,CAAC,KAAK,EAAE,QAAQ,EAAE,GAAG,CAAC,KAAK,CAAC,CAAC;SACvE;IACH,CAAC;IAEM,gBAAgB,CAAC,GAAgB;QACtC,OAAO,IAAI,CAAC,sBAAsB,CAAC,CAAC,CAAC,IAAI,CAAC,4BAA4B,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,sBAAsB,CAAC,GAAG,CAAC,CAAC;IACjH,CAAC;IAED;;OAEG;IACK,4BAA4B,CAAC,GAAgB;QACnD,sFAAsF;QACtF,yDAAyD;QACzD,uFAAuF;QACvF,IAAI,CAAC,GAAG,CAAC,QAAQ,IAAI,CAAE,IAAI,EAAE,SAAS,EAAE,EAAE,CAAE,CAAC,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE;YACzE,OAAO,GAAG,CAAC,QAAQ,CAAC,CAAC;gBACnB,IAAI,CAAC,CAAC,iBAAiB,CAAC,GAAG,CAAC,KAAK,EAAE,GAAG,CAAC,QAAQ,CAAC,CAAC,CAAC;gBAClD,IAAI,CAAC,CAAC,aAAa,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;SAClC;QAED,MAAM,QAAQ,GAAG,GAAG,CAAC,QAAQ,CAAC,KAAK,CAAC;QACpC,MAAM,aAAa,GAAyB,IAAA,+BAAgB,EAAC,QAAQ,EAAE,IAAI,CAAC,iBAAiB,CAAC,CAAC;QAE/F,IAAI,gBAAO,CAAC,UAAU,IAAI,aAAa,EAAE;YACvC,OAAO,IAAI,CAAC,CAAC,aAAa,CAAC,GAAG,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;SACjD;QACD,IAAI,gBAAE,CAAC,eAAe,IAAI,aAAa,EAAE;YACvC,OAAO,IAAI,CAAC,CAAC,iBAAiB,CAAC,GAAG,CAAC,KAAK,EAAE,GAAG,CAAC,QAAQ,CAAC,CAAC;SACzD;QACD,IAAI,gBAAE,CAAC,aAAa,IAAI,aAAa,EAAE;YACrC,4EAA4E;YAC5E,kEAAkE;YAClE,sFAAsF;YACtF,6FAA6F;YAC7F,qDAAqD;YACrD,sEAAsE;YACtE,MAAM,OAAO,GAAS,IAAI,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;YAC1C,IAAI,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,OAAO,EAAE,CAAC,EAAE;gBACnC,OAAO,IAAI,CAAC,CAAC,iBAAiB,CAAC,SAAS,EAAE,QAAQ,EAAE,IAAI,CAAC,iBAAiB,EAAE,GAAG,CAAC,KAAK,CAAC,CAAC;aACxF;YACD,OAAO,IAAI,CAAC,CAAC,eAAe,CAAC,IAAI,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE,GAAG,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;SACxE;QACD,IAAI,gBAAE,CAAC,WAAW,IAAI,aAAa,EAAE;YACnC,IAAI,GAAG,CAAC,KAAK,KAAK,MAAM,IAAI,GAAG,CAAC,KAAK,KAAK,OAAO,IAAI,GAAG,CAAC,KAAK,KAAK,GAAG,IAAI,GAAG,CAAC,KAAK,KAAK,GAAG,EAAE;gBAC3F,OAAO,IAAI,CAAC,CAAC,iBAAiB,CAAC,SAAS,EAAE,QAAQ,EAAE,IAAI,CAAC,iBAAiB,EAAE,GAAG,CAAC,KAAK,CAAC,CAAC;aACxF;YACD,OAAO,IAAI,CAAC,CAAC,cAAc,CAAC,GAAG,CAAC,KAAK,KAAK,MAAM,IAAI,GAAG,CAAC,KAAK,KAAK,GAAG,EAAE,GAAG,CAAC,KAAK,CAAC,CAAC;SACnF;QACD,IAAI,gBAAE,CAAC,WAAW,IAAI,aAAa,EAAE;YACnC,MAAM,MAAM,GAAuB,CAAC,CAAC,eAAe,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;YAChE,IAAI,MAAM,KAAK,SAAS,EAAE;gBACxB,OAAO,IAAI,CAAC,CAAC,iBAAiB,CAAC,SAAS,EAAE,QAAQ,EAAE,IAAI,CAAC,iBAAiB,EAAE,GAAG,CAAC,KAAK,CAAC,CAAC;aACxF;YACD,IAAI,gBAAE,CAAC,WAAW,IAAI,aAAa,EAAE;gBACnC,OAAO,IAAI,CAAC,CAAC,cAAc,CAAC,MAAM,EAAE,QAAQ,EAAE,GAAG,CAAC,KAAK,CAAC,CAAC;aAC1D;YACD,iDAAiD;YACjD,OAAO,IAAI,CAAC,CAAC,cAAc,CAAC,MAAM,EAAE,QAAQ,EAAE,GAAG,CAAC,KAAK,CAAC,CAAC;SAC1D;QACD,MAAM,OAAO,GAAG,gBAAE,CAAC,SAAS,IAAI,aAAa,CAAC;QAC9C,MAAM,QAAQ,GAAG,gBAAE,CAAC,UAAU,IAAI,aAAa,CAAC;QAChD,IAAI,OAAO,IAAI,QAAQ,EAAE;YACvB,MAAM,SAAS,GAAuB,CAAC,CAAC,aAAa,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;YACjE,IAAI,SAAS,KAAK,SAAS,EAAE;gBAC3B,OAAO,IAAI,CAAC,CAAC,iBAAiB,CAAC,SAAS,EAAE,QAAQ,EAAE,IAAI,CAAC,iBAAiB,EAAE,GAAG,CAAC,KAAK,CAAC,CAAC;aACxF;YACD,IAAI,OAAO,EAAE;gBACX,OAAO,IAAI,CAAC,CAAC,YAAY,CAAC,SAAS,EAAE,QAAQ,EAAE,GAAG,CAAC,KAAK,CAAC,CAAC;aAC3D;YACD,OAAO,IAAI,CAAC,CAAC,aAAa,CAAC,SAAS,EAAE,QAAQ,EAAE,GAAG,CAAC,KAAK,CAAC,CAAC;SAC5D;QACD,OAAO,IAAI,CAAC,CAAC,OAAO,CAAS,GAAG,CAAC,KAAK,EAAE,QAAQ,EAAE,GAAG,CAAC,KAAK,CAAC,CAAC;IAC/D,CAAC;CACF;AAzMD,0CAyMC","sourcesContent":["import type * as RDF from '@rdfjs/types';\nimport * as RDFString from 'rdf-string';\nimport type { Algebra as Alg } from 'sparqlalgebrajs';\nimport { Algebra } from 'sparqlalgebrajs';\nimport * as E from '../expressions';\nimport { TypeURL as DT, TypeURL } from '../util/Consts';\nimport * as Err from '../util/Errors';\nimport * as P from '../util/Parsing';\nimport { getSuperTypeDict } from '../util/TypeHandling';\nimport type { ISuperTypeProvider,\n  GeneralSuperTypeDict } from '../util/TypeHandling';\n\nexport interface ITermTransformer {\n  transformRDFTermUnsafe: (term: RDF.Term) => E.Term;\n  transformLiteral: (lit: RDF.Literal) => E.Literal<any>;\n}\n\nexport class TermTransformer implements ITermTransformer {\n  public constructor(protected readonly superTypeProvider: ISuperTypeProvider,\n    protected readonly enableExtendedXSDTypes: boolean) { }\n\n  /**\n   * Transforms an RDF term to the internal representation of a term,\n   * assuming it is not a variable, which would be an expression (internally).\n   *\n   * @param term RDF term to transform into internal representation of a term\n   */\n  public transformRDFTermUnsafe(term: RDF.Term): E.Term {\n    return <E.Term> this.transformTerm({\n      term,\n      type: Algebra.types.EXPRESSION,\n      expressionType: Algebra.expressionTypes.TERM,\n    });\n  }\n\n  protected transformTerm(term: Alg.TermExpression): E.Expression {\n    if (!term.term) {\n      throw new Err.InvalidExpression(term);\n    }\n\n    switch (term.term.termType) {\n      case 'Variable':\n        return new E.Variable(RDFString.termToString(term.term));\n      case 'Literal':\n        return this.transformLiteral(term.term);\n      case 'NamedNode':\n        return new E.NamedNode(term.term.value);\n      case 'BlankNode':\n        return new E.BlankNode(term.term.value);\n      default:\n        throw new Err.InvalidTermType(term);\n    }\n  }\n\n  private legacyTransformLiteral(lit: RDF.Literal): E.Literal<any> {\n    // We transform to StringLiteral when we detect a simple literal being used.\n    // Original issue regarding this behaviour: https://github.com/w3c/sparql-12/issues/112\n\n    if (!lit.datatype) {\n      return lit.language ?\n        new E.LangStringLiteral(lit.value, lit.language) :\n        new E.StringLiteral(lit.value);\n    }\n    const dataType = lit.datatype.value;\n    switch (dataType) {\n      case null:\n      case undefined:\n      case '': {\n        return lit.language ?\n          new E.LangStringLiteral(lit.value, lit.language) :\n          new E.StringLiteral(lit.value);\n      }\n      case TypeURL.XSD_ANY_URI:\n      case TypeURL.XSD_NORMALIZED_STRING:\n      case TypeURL.XSD_TOKEN:\n      case TypeURL.XSD_LANGUAGE:\n      case TypeURL.XSD_NM_TOKEN:\n      case TypeURL.XSD_NAME:\n      case TypeURL.XSD_ENTITY:\n      case TypeURL.XSD_ID:\n      case TypeURL.XSD_ID_REF:\n      case TypeURL.XSD_STRING: return new E.StringLiteral(lit.value, dataType);\n\n      case TypeURL.RDF_LANG_STRING: return new E.LangStringLiteral(lit.value, lit.language);\n\n      case TypeURL.XSD_DATE_TIME_STAMP:\n      case TypeURL.XSD_DATE_TIME: {\n        const dateVal: Date = new Date(lit.value);\n        if (Number.isNaN(dateVal.getTime())) {\n          return new E.NonLexicalLiteral(undefined, dataType, this.superTypeProvider, lit.value);\n        }\n        return new E.DateTimeLiteral(new Date(lit.value), lit.value, dataType);\n      }\n\n      case TypeURL.XSD_BOOLEAN: {\n        if (lit.value !== 'true' && lit.value !== 'false' && lit.value !== '1' && lit.value !== '0') {\n          return new E.NonLexicalLiteral(undefined, dataType, this.superTypeProvider, lit.value);\n        }\n        return new E.BooleanLiteral(lit.value === 'true' || lit.value === '1', lit.value, dataType);\n      }\n\n      case TypeURL.XSD_DECIMAL: {\n        const decimalVal: number | undefined = P.parseXSDDecimal(lit.value);\n        if (decimalVal === undefined) {\n          return new E.NonLexicalLiteral(undefined, dataType, this.superTypeProvider, lit.value);\n        }\n        return new E.DecimalLiteral(decimalVal, dataType, lit.value);\n      }\n      case TypeURL.XSD_FLOAT: {\n        const floatVal: number | undefined = P.parseXSDFloat(lit.value);\n        if (floatVal === undefined) {\n          return new E.NonLexicalLiteral(undefined, dataType, this.superTypeProvider, lit.value);\n        }\n        return new E.FloatLiteral(floatVal, dataType, lit.value);\n      }\n\n      case TypeURL.XSD_DOUBLE: {\n        const doubleVal: number | undefined = P.parseXSDFloat(lit.value);\n        if (doubleVal === undefined) {\n          return new E.NonLexicalLiteral(undefined, dataType, this.superTypeProvider, lit.value);\n        }\n        return new E.DoubleLiteral(doubleVal, dataType, lit.value);\n      }\n\n      case TypeURL.XSD_NON_POSITIVE_INTEGER:\n      case TypeURL.XSD_NEGATIVE_INTEGER:\n      case TypeURL.XSD_LONG:\n      case TypeURL.XSD_INT:\n      case TypeURL.XSD_SHORT:\n      case TypeURL.XSD_BYTE:\n      case TypeURL.XSD_NON_NEGATIVE_INTEGER:\n      case TypeURL.XSD_POSITIVE_INTEGER:\n      case TypeURL.XSD_UNSIGNED_LONG:\n      case TypeURL.XSD_UNSIGNED_INT:\n      case TypeURL.XSD_UNSIGNED_SHORT:\n      case TypeURL.XSD_UNSIGNED_BYTE:\n      case TypeURL.XSD_INTEGER: {\n        const intVal: number | undefined = P.parseXSDDecimal(lit.value);\n        if (intVal === undefined) {\n          return new E.NonLexicalLiteral(undefined, dataType, this.superTypeProvider, lit.value);\n        }\n        return new E.IntegerLiteral(intVal, dataType, lit.value);\n      }\n\n      default: return new E.Literal<string>(lit.value, dataType, lit.value);\n    }\n  }\n\n  public transformLiteral(lit: RDF.Literal): E.Literal<any> {\n    return this.enableExtendedXSDTypes ? this.experimentalTransformLiteral(lit) : this.legacyTransformLiteral(lit);\n  }\n\n  /**\n   * @param lit the rdf literal we want to transform to an internal Literal expression.\n   */\n  private experimentalTransformLiteral(lit: RDF.Literal): E.Literal<any> {\n    // Both here and within the switch we transform to LangStringLiteral or StringLiteral.\n    // We do this when we detect a simple literal being used.\n    // Original issue regarding this behaviour: https://github.com/w3c/sparql-12/issues/112\n    if (!lit.datatype || [ null, undefined, '' ].includes(lit.datatype.value)) {\n      return lit.language ?\n        new E.LangStringLiteral(lit.value, lit.language) :\n        new E.StringLiteral(lit.value);\n    }\n\n    const dataType = lit.datatype.value;\n    const superTypeDict: GeneralSuperTypeDict = getSuperTypeDict(dataType, this.superTypeProvider);\n\n    if (TypeURL.XSD_STRING in superTypeDict) {\n      return new E.StringLiteral(lit.value, dataType);\n    }\n    if (DT.RDF_LANG_STRING in superTypeDict) {\n      return new E.LangStringLiteral(lit.value, lit.language);\n    }\n    if (DT.XSD_DATE_TIME in superTypeDict) {\n      // It should be noted how we don't care if its a XSD_DATE_TIME_STAMP or not.\n      // This is because sparql functions don't care about the timezone.\n      // It's also doesn't break the specs because we keep the string representation stored,\n      // that way we can always give it back. There are also no sparql functions that alter a date.\n      // (So the initial representation always stays valid)\n      // https://github.com/comunica/sparqlee/pull/103#discussion_r688462368\n      const dateVal: Date = new Date(lit.value);\n      if (Number.isNaN(dateVal.getTime())) {\n        return new E.NonLexicalLiteral(undefined, dataType, this.superTypeProvider, lit.value);\n      }\n      return new E.DateTimeLiteral(new Date(lit.value), lit.value, dataType);\n    }\n    if (DT.XSD_BOOLEAN in superTypeDict) {\n      if (lit.value !== 'true' && lit.value !== 'false' && lit.value !== '1' && lit.value !== '0') {\n        return new E.NonLexicalLiteral(undefined, dataType, this.superTypeProvider, lit.value);\n      }\n      return new E.BooleanLiteral(lit.value === 'true' || lit.value === '1', lit.value);\n    }\n    if (DT.XSD_DECIMAL in superTypeDict) {\n      const intVal: number | undefined = P.parseXSDDecimal(lit.value);\n      if (intVal === undefined) {\n        return new E.NonLexicalLiteral(undefined, dataType, this.superTypeProvider, lit.value);\n      }\n      if (DT.XSD_INTEGER in superTypeDict) {\n        return new E.IntegerLiteral(intVal, dataType, lit.value);\n      }\n      // If type is not an integer it's just a decimal.\n      return new E.DecimalLiteral(intVal, dataType, lit.value);\n    }\n    const isFloat = DT.XSD_FLOAT in superTypeDict;\n    const isDouble = DT.XSD_DOUBLE in superTypeDict;\n    if (isFloat || isDouble) {\n      const doubleVal: number | undefined = P.parseXSDFloat(lit.value);\n      if (doubleVal === undefined) {\n        return new E.NonLexicalLiteral(undefined, dataType, this.superTypeProvider, lit.value);\n      }\n      if (isFloat) {\n        return new E.FloatLiteral(doubleVal, dataType, lit.value);\n      }\n      return new E.DoubleLiteral(doubleVal, dataType, lit.value);\n    }\n    return new E.Literal<string>(lit.value, dataType, lit.value);\n  }\n}\n"]}
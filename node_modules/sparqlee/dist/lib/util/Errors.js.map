{"version":3,"file":"Errors.js","sourceRoot":"","sources":["../../../lib/util/Errors.ts"],"names":[],"mappings":"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","sourcesContent":["import type * as RDF from '@rdfjs/types';\nimport type { Algebra } from 'sparqlalgebrajs';\nimport type * as E from '../expressions';\nimport type * as C from './Consts';\n\n/**\n * This class of error will be thrown when an expression errors.\n * Various reasons this could happen are:\n *   - invalid types for the given operator\n *   - unbound variables\n *   - invalid lexical forms\n *   - ...\n *\n * The distinction is made so that one can catch this specific type\n * and handle it accordingly to the SPARQL spec (relevant for e.g. FILTER, EXTEND),\n * while others (programming errors) can be re-thrown.\n *\n * @see isExpressionError\n */\nexport class ExpressionError extends Error { }\n\n/**\n * Checks whether a given error is an {@link ExpressionError}.\n * Also useful for mocking in tests for covering all branches.\n *\n * @see ExpressionError\n */\nexport function isExpressionError(error: Error): boolean {\n  return error instanceof ExpressionError;\n}\n\n/**\n * A literal has an invalid lexical form for the datatype it is accompanied by.\n * This error is only thrown when the term is as function argument that requires\n * a valid lexical form.\n */\nexport class InvalidLexicalForm extends ExpressionError {\n  public constructor(public arg: RDF.Term) {\n    super(`Invalid lexical form '${pp(arg)}'`);\n  }\n}\n\n/**\n * A variable in the expression was not bound.\n */\nexport class UnboundVariableError extends ExpressionError {\n  public constructor(public variable: string, public bindings: RDF.Bindings) {\n    super(`Unbound variable '${pp(variable)}'`);\n  }\n}\n\n/**\n * An invalid term was being coerced to an Effective Boolean Value.\n *\n * See the {@link https://www.w3.org/TR/sparql11-query/#ebv | SPARQL docs}\n * on EBVs.\n */\nexport class EBVCoercionError extends ExpressionError {\n  public constructor(public arg: E.Term) {\n    super(`Cannot coerce term to EBV '${pp(arg)}'`);\n  }\n}\n\n/**\n * An equality test was done on literals with unsupported datatypes.\n *\n * See {@link https://www.w3.org/TR/sparql11-query/#func-RDFterm-equal | term equality spec}.\n */\nexport class RDFEqualTypeError extends ExpressionError {\n  public constructor(public args: E.Expression[]) {\n    super('Equality test for literals with unsupported datatypes');\n  }\n}\n\n/**\n * All the expressions in a COALESCE call threw errors.\n */\nexport class CoalesceError extends ExpressionError {\n  public constructor(public errors: Error[]) {\n    super('All COALESCE arguments threw errors');\n  }\n}\n\n/**\n * No arguments to an IN call where equal, and at least one threw an error.\n */\nexport class InError extends ExpressionError {\n  public constructor(public errors: (Error | false)[]) {\n    super(\n      `Some argument to IN errorred and none where equal. ${\n        // eslint-disable-next-line @typescript-eslint/no-base-to-string\n        errors.map(err => `(${err.toString()}) `).join('and ')}`,\n    );\n  }\n}\n\n/**\n * Literals were passed to an operator that doesn't support their datatypes.\n */\nexport class InvalidArgumentTypes extends ExpressionError {\n  public constructor(public args: E.Expression[], public op: C.Operator | C.NamedOperator) {\n    super(`Argument types not valid for operator: '${pp(op)}' with '${pp(args)}`);\n  }\n}\n\n/**\n * An invalid typecast happened.\n */\nexport class CastError<T> extends ExpressionError {\n  public constructor(public arg: T, cast: C.TypeURL) {\n    super(`Invalid cast: '${pp(arg)}' to '${pp(cast)}'`);\n  }\n}\n\nexport class InvalidTimezoneCall extends ExpressionError {\n  public constructor(public dateString: string) {\n    super(`TIMEZONE call on ${dateString} which has no timezone`);\n  }\n}\n\nexport class IncompatibleLanguageOperation extends ExpressionError {\n  public constructor(public arg1: E.LangStringLiteral, public arg2: E.LangStringLiteral) {\n    super(`Operation on incompatible language literals '${pp(arg1)}' and '${pp(arg2)}'`);\n  }\n}\n\nexport class EmptyAggregateError extends ExpressionError {\n  public constructor() {\n    super('Empty aggregate expression');\n  }\n}\n\n// Non Expression Errors ------------------------------------------------------\n\n/**\n * An error that arises when we detect a 'should-be-impossible' state.\n * Given that this error is thrown, it clearly wasn't impossible, and some\n * mistake has been made.\n */\nexport class UnexpectedError<T> extends Error {\n  public constructor(message: string, public payload?: T) {\n    super(`Programmer Error '${message}'`);\n  }\n}\n\n/**\n * An Error that signals a feature or function is yet unimplemented.\n */\nexport class UnimplementedError extends Error {\n  public constructor(feature: string) {\n    super(`Unimplemented feature '${feature}!'`);\n  }\n}\n\nexport class InvalidArity extends Error {\n  public constructor(public args: E.Expression[], public op: C.Operator) {\n    super(`The number of args does not match the arity of the operator '${pp(op)}'.`);\n  }\n}\n\nexport class InvalidExpression<T> extends Error {\n  public constructor(expr: T) {\n    super(`Invalid SPARQL Expression '${pp(expr)}'`);\n  }\n}\n\nexport class InvalidExpressionType<T> extends Error {\n  public constructor(public expr: T) {\n    super(`Invalid expression type for SPARQL Expression '${pp(expr)}'`);\n  }\n}\n\nexport class InvalidTermType extends Error {\n  public constructor(public term: Algebra.TermExpression) {\n    super(`Invalid term type for term '${pp(term)}'`);\n  }\n}\n\nexport class UnknownOperator extends Error {\n  public constructor(name: string) {\n    super(`Unknown operator: '${pp(name)}`);\n  }\n}\n\nexport class UnknownNamedOperator extends Error {\n  public constructor(name: string) {\n    super(`Unknown named operator: '${pp(name)}'`);\n  }\n}\n\nexport class ExtensionFunctionError extends Error {\n  public constructor(name: string, functionError: unknown) {\n    if (functionError instanceof Error) {\n      super(`Error thrown in ${name}: ${functionError.message}${functionError.stack ? `\\n${functionError.stack}` : ''}`);\n    } else {\n      super(`Error thrown in ${name}`);\n    }\n  }\n}\n\nexport class NoAggregator extends Error {\n  public constructor(name?: string) {\n    super(`Aggregate expression ${pp(name)} found, but no aggregate hook provided.`);\n  }\n}\n\nexport class NoExistenceHook extends Error {\n  public constructor() {\n    super('EXISTS found, but no existence hook provided.');\n  }\n}\n\nfunction pp<T>(object: T): string {\n  return JSON.stringify(object);\n}\n"]}
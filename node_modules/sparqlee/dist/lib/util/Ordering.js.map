{"version":3,"file":"Ordering.js","sourceRoot":"","sources":["../../../lib/util/Ordering.ts"],"names":[],"mappings":"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","sourcesContent":["import type * as RDF from '@rdfjs/types';\nimport * as LRUCache from 'lru-cache';\nimport { TermTransformer } from '../transformers/TermTransformer';\nimport type { MainSparqlType } from './Consts';\nimport type { ISuperTypeProvider, SuperTypeCallback, TypeCache } from './TypeHandling';\n\n// Determine the relative numerical order of the two given terms.\nexport function orderTypes(termA: RDF.Term | undefined, termB: RDF.Term | undefined, isAscending: boolean,\n  typeDiscoveryCallback?: SuperTypeCallback, typeCache?: TypeCache, enableExtendedXSDTypes?: boolean): -1 | 0 | 1 {\n  if (termA === termB) {\n    return 0;\n  }\n\n  // We handle undefined that is lower than everything else.\n  if (termA === undefined) {\n    return isAscending ? -1 : 1;\n  }\n  if (termB === undefined) {\n    return isAscending ? 1 : -1;\n  }\n\n  // We handle terms\n  if (termA.equals(termB)) {\n    return 0;\n  }\n  return isTermLowerThan(termA, termB, typeDiscoveryCallback, typeCache, enableExtendedXSDTypes) === isAscending ?\n    -1 :\n    1;\n}\n\nfunction isTermLowerThan(termA: RDF.Term, termB: RDF.Term,\n  typeDiscoveryCallback?: SuperTypeCallback, typeCache?: TypeCache, enableExtendedXSDTypes?: boolean): boolean {\n  if (termA.termType !== termB.termType) {\n    return _TERM_ORDERING_PRIORITY[termA.termType] < _TERM_ORDERING_PRIORITY[termB.termType];\n  }\n  return termA.termType === 'Literal' ?\n    isLiteralLowerThan(termA, <RDF.Literal>termB, typeDiscoveryCallback, typeCache, enableExtendedXSDTypes) :\n    termA.value < termB.value;\n}\n\nfunction isLiteralLowerThan(litA: RDF.Literal, litB: RDF.Literal,\n  typeDiscoveryCallback?: SuperTypeCallback, typeCache?: TypeCache, enableExtendedXSDTypes?: boolean): boolean {\n  const openWorldType: ISuperTypeProvider = {\n    discoverer: typeDiscoveryCallback || (() => 'term'),\n    cache: typeCache || new LRUCache(),\n  };\n  const termTransformer = new TermTransformer(openWorldType, enableExtendedXSDTypes || false);\n  const myLitA = termTransformer.transformLiteral(litA);\n  const myLitB = termTransformer.transformLiteral(litB);\n  const typeA = _SPARQL_TYPE_NORMALIZATION[myLitA.mainSparqlType];\n  const typeB = _SPARQL_TYPE_NORMALIZATION[myLitB.mainSparqlType];\n  if (typeA !== typeB) {\n    return typeA < typeB;\n  }\n  switch (typeA) {\n    case 'boolean':\n    case 'dateTime':\n    case 'decimal':\n    case 'integer':\n    case 'float':\n    case 'double':\n    case 'string':\n      return myLitA.typedValue < myLitB.typedValue;\n    case 'langString':\n      return myLitA.typedValue < myLitB.typedValue ||\n          (myLitA.typedValue === myLitB.typedValue && (myLitA.language || '') < (myLitB.language || ''));\n    case 'other':\n    case 'nonlexical':\n      return myLitA.dataType < myLitB.dataType ||\n          (myLitA.dataType === myLitB.dataType && myLitA.str() < myLitB.str());\n  }\n}\n\n// SPARQL specifies that blankNode < namedNode < literal.\nconst _TERM_ORDERING_PRIORITY = {\n  Variable: 0,\n  BlankNode: 1,\n  NamedNode: 2,\n  Literal: 3,\n  Quad: 4,\n  DefaultGraph: 5,\n};\n\nconst _SPARQL_TYPE_NORMALIZATION: {[key in MainSparqlType]: MainSparqlType } = {\n  string: 'string',\n  langString: 'langString',\n  dateTime: 'dateTime',\n  boolean: 'boolean',\n  integer: 'decimal',\n  decimal: 'decimal',\n  float: 'decimal',\n  double: 'decimal',\n  other: 'other',\n  nonlexical: 'other',\n};\n"]}
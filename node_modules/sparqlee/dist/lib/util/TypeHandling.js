"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isSubTypeOf = exports.getSuperTypeDict = exports.isInternalSubType = exports.asGeneralType = exports.asOverrideType = exports.asKnownLiteralType = exports.asTypeAlias = exports.typeAliasCheck = exports.extensionTableInit = exports.getSuperTypes = exports.superTypeDictTable = exports.extensionTableInput = exports.mainSparqlType = void 0;
const expressions_1 = require("../expressions");
const Consts_1 = require("./Consts");
/**
 * This function return a list of ArgumentTypes and the priority this list has.
 * This priority can be matched with other values returned by this function.
 * This function needs to be in line with the @see extensionTableInput.
 * @param typeURL This will most likely be a @see ExperimentalArgumentType
 */
function mainSparqlType(typeURL) {
    // We transform to StringLiteral when we detect a simple literal being used.
    // Original issue regarding this behaviour: https://github.com/w3c/sparql-12/issues/112
    switch (typeURL) {
        case 'term': return { types: ['term'], prio: 0 };
        case 'namedNode': return { types: ['namedNode'], prio: 1 };
        case 'literal': return { types: ['literal'], prio: 1 };
        case 'blankNode': return { types: ['blankNode'], prio: 1 };
        case Consts_1.TypeAlias.SPARQL_NON_LEXICAL: return { types: ['nonlexical'], prio: 2 };
        case null:
        case undefined:
        case '':
        case Consts_1.TypeURL.XSD_ANY_URI:
        case Consts_1.TypeURL.XSD_NORMALIZED_STRING:
        case Consts_1.TypeURL.XSD_TOKEN:
        case Consts_1.TypeURL.XSD_LANGUAGE:
        case Consts_1.TypeURL.XSD_NM_TOKEN:
        case Consts_1.TypeURL.XSD_NAME:
        case Consts_1.TypeURL.XSD_ENTITY:
        case Consts_1.TypeURL.XSD_ID:
        case Consts_1.TypeURL.XSD_ID_REF:
        case Consts_1.TypeURL.XSD_STRING: return { types: ['string'], prio: exports.superTypeDictTable[Consts_1.TypeURL.XSD_STRING].__depth + 2 };
        case Consts_1.TypeURL.RDF_LANG_STRING: return {
            types: ['langString'],
            prio: exports.superTypeDictTable[Consts_1.TypeURL.RDF_LANG_STRING].__depth + 2,
        };
        case Consts_1.TypeURL.XSD_DATE_TIME_STAMP:
        case Consts_1.TypeURL.XSD_DATE_TIME: return {
            types: ['dateTime'],
            prio: exports.superTypeDictTable[Consts_1.TypeURL.XSD_DATE_TIME].__depth + 2,
        };
        case Consts_1.TypeURL.XSD_BOOLEAN: return {
            types: ['boolean'],
            prio: exports.superTypeDictTable[Consts_1.TypeURL.XSD_BOOLEAN].__depth + 2,
        };
        case Consts_1.TypeURL.XSD_DECIMAL: return {
            types: ['decimal', 'integer'],
            prio: exports.superTypeDictTable[Consts_1.TypeURL.XSD_DECIMAL].__depth + 2,
        };
        case Consts_1.TypeURL.XSD_FLOAT: return { types: ['float'], prio: exports.superTypeDictTable[Consts_1.TypeURL.XSD_FLOAT].__depth + 2 };
        case Consts_1.TypeURL.XSD_DOUBLE: return { types: ['double'], prio: exports.superTypeDictTable[Consts_1.TypeURL.XSD_DOUBLE].__depth + 2 };
        case Consts_1.TypeURL.XSD_NON_POSITIVE_INTEGER:
        case Consts_1.TypeURL.XSD_NEGATIVE_INTEGER:
        case Consts_1.TypeURL.XSD_LONG:
        case Consts_1.TypeURL.XSD_INT:
        case Consts_1.TypeURL.XSD_SHORT:
        case Consts_1.TypeURL.XSD_BYTE:
        case Consts_1.TypeURL.XSD_NON_NEGATIVE_INTEGER:
        case Consts_1.TypeURL.XSD_POSITIVE_INTEGER:
        case Consts_1.TypeURL.XSD_UNSIGNED_LONG:
        case Consts_1.TypeURL.XSD_UNSIGNED_INT:
        case Consts_1.TypeURL.XSD_UNSIGNED_SHORT:
        case Consts_1.TypeURL.XSD_UNSIGNED_BYTE:
        case Consts_1.TypeURL.XSD_INTEGER: return {
            types: ['integer'],
            prio: exports.superTypeDictTable[Consts_1.TypeURL.XSD_INTEGER].__depth + 2,
        };
        case Consts_1.TypeAlias.SPARQL_STRINGLY: return {
            types: ['string', 'langString'],
            prio: exports.superTypeDictTable[Consts_1.TypeAlias.SPARQL_STRINGLY].__depth + 2,
        };
        case Consts_1.TypeAlias.SPARQL_NUMERIC: return {
            types: ['decimal', 'float', 'integer', 'double'],
            prio: exports.superTypeDictTable[Consts_1.TypeAlias.SPARQL_NUMERIC].__depth + 2,
        };
        default: return { types: ['other'], prio: 2 };
    }
}
exports.mainSparqlType = mainSparqlType;
/**
 * Types that are not mentioned just map to 'term'.
 * When editing this, make sure type promotion and substituion don't start interfering.
 * e.g. when saying something like string -> stringly -> anyUri -> term.
 * This would make substitution on types that promote to each other possible. We and the specs don't want that!
 * A DAG will be created based on this. Make sure it doesn't have any cycles!
 *
 * This needs to be in line with the @see mainSparqlType function.
 */
exports.extensionTableInput = {
    // Datetime types
    [Consts_1.TypeURL.XSD_DATE_TIME_STAMP]: Consts_1.TypeURL.XSD_DATE_TIME,
    // Duration types
    [Consts_1.TypeURL.XSD_DAYTIME_DURATION]: Consts_1.TypeURL.XSD_DURATION,
    [Consts_1.TypeURL.XSD_YEAR_MONTH_DURATION]: Consts_1.TypeURL.XSD_DURATION,
    // Stringly types
    [Consts_1.TypeURL.RDF_LANG_STRING]: Consts_1.TypeAlias.SPARQL_STRINGLY,
    [Consts_1.TypeURL.XSD_STRING]: Consts_1.TypeAlias.SPARQL_STRINGLY,
    // String types
    [Consts_1.TypeURL.XSD_NORMALIZED_STRING]: Consts_1.TypeURL.XSD_STRING,
    [Consts_1.TypeURL.XSD_TOKEN]: Consts_1.TypeURL.XSD_NORMALIZED_STRING,
    [Consts_1.TypeURL.XSD_LANGUAGE]: Consts_1.TypeURL.XSD_TOKEN,
    [Consts_1.TypeURL.XSD_NM_TOKEN]: Consts_1.TypeURL.XSD_TOKEN,
    [Consts_1.TypeURL.XSD_NAME]: Consts_1.TypeURL.XSD_TOKEN,
    [Consts_1.TypeURL.XSD_NC_NAME]: Consts_1.TypeURL.XSD_NAME,
    [Consts_1.TypeURL.XSD_ENTITY]: Consts_1.TypeURL.XSD_NC_NAME,
    [Consts_1.TypeURL.XSD_ID]: Consts_1.TypeURL.XSD_NC_NAME,
    [Consts_1.TypeURL.XSD_ID_REF]: Consts_1.TypeURL.XSD_NC_NAME,
    // Numeric types
    // https://www.w3.org/TR/sparql11-query/#operandDataTypes
    // > numeric denotes typed literals with datatypes xsd:integer, xsd:decimal, xsd:float, and xsd:double
    [Consts_1.TypeURL.XSD_DOUBLE]: Consts_1.TypeAlias.SPARQL_NUMERIC,
    [Consts_1.TypeURL.XSD_FLOAT]: Consts_1.TypeAlias.SPARQL_NUMERIC,
    [Consts_1.TypeURL.XSD_DECIMAL]: Consts_1.TypeAlias.SPARQL_NUMERIC,
    // Decimal types
    [Consts_1.TypeURL.XSD_INTEGER]: Consts_1.TypeURL.XSD_DECIMAL,
    [Consts_1.TypeURL.XSD_NON_POSITIVE_INTEGER]: Consts_1.TypeURL.XSD_INTEGER,
    [Consts_1.TypeURL.XSD_NEGATIVE_INTEGER]: Consts_1.TypeURL.XSD_NON_POSITIVE_INTEGER,
    [Consts_1.TypeURL.XSD_LONG]: Consts_1.TypeURL.XSD_INTEGER,
    [Consts_1.TypeURL.XSD_INT]: Consts_1.TypeURL.XSD_LONG,
    [Consts_1.TypeURL.XSD_SHORT]: Consts_1.TypeURL.XSD_INT,
    [Consts_1.TypeURL.XSD_BYTE]: Consts_1.TypeURL.XSD_SHORT,
    [Consts_1.TypeURL.XSD_NON_NEGATIVE_INTEGER]: Consts_1.TypeURL.XSD_INTEGER,
    [Consts_1.TypeURL.XSD_POSITIVE_INTEGER]: Consts_1.TypeURL.XSD_NON_NEGATIVE_INTEGER,
    [Consts_1.TypeURL.XSD_UNSIGNED_LONG]: Consts_1.TypeURL.XSD_NON_NEGATIVE_INTEGER,
    [Consts_1.TypeURL.XSD_UNSIGNED_INT]: Consts_1.TypeURL.XSD_UNSIGNED_LONG,
    [Consts_1.TypeURL.XSD_UNSIGNED_SHORT]: Consts_1.TypeURL.XSD_UNSIGNED_INT,
    [Consts_1.TypeURL.XSD_UNSIGNED_BYTE]: Consts_1.TypeURL.XSD_UNSIGNED_SHORT,
    [Consts_1.TypeURL.XSD_DATE_TIME]: 'term',
    [Consts_1.TypeURL.XSD_BOOLEAN]: 'term',
    [Consts_1.TypeURL.XSD_DATE]: 'term',
    [Consts_1.TypeURL.XSD_DURATION]: 'term',
    [Consts_1.TypeAlias.SPARQL_NUMERIC]: 'term',
    [Consts_1.TypeAlias.SPARQL_STRINGLY]: 'term',
    [Consts_1.TypeAlias.SPARQL_NON_LEXICAL]: 'term',
    [Consts_1.TypeURL.XSD_ANY_URI]: 'term',
};
/**
 * This will return the super types of a type and cache them.
 * @param type IRI we will decide the super types of.
 * @param openWorldType the enabler that provides a way to find super types.
 */
function getSuperTypes(type, openWorldType) {
    const cached = openWorldType.cache.get(type);
    if (cached) {
        return cached;
    }
    const value = openWorldType.discoverer(type);
    if (value === 'term') {
        const res = Object.create(null);
        res.__depth = 0;
        res[type] = 0;
        openWorldType.cache.set(type, res);
        return res;
    }
    let subExtension;
    const knownValue = asKnownLiteralType(value);
    if (knownValue) {
        subExtension = Object.assign({}, exports.superTypeDictTable[knownValue]);
    }
    else {
        subExtension = Object.assign({}, getSuperTypes(value, openWorldType));
    }
    subExtension.__depth++;
    subExtension[type] = subExtension.__depth;
    openWorldType.cache.set(type, subExtension);
    return subExtension;
}
exports.getSuperTypes = getSuperTypes;
// No circular structure allowed! & No other keys allowed!
function extensionTableInit() {
    const res = Object.create(null);
    for (const [_key, value] of Object.entries(exports.extensionTableInput)) {
        const key = _key;
        if (res[key]) {
            continue;
        }
        extensionTableBuilderInitKey(key, value, res);
    }
    exports.superTypeDictTable = res;
}
exports.extensionTableInit = extensionTableInit;
extensionTableInit();
function extensionTableBuilderInitKey(key, value, res) {
    if (value === 'term' || value === undefined) {
        const baseRes = Object.create(null);
        baseRes.__depth = 0;
        baseRes[key] = 0;
        res[key] = baseRes;
        return;
    }
    if (!res[value]) {
        extensionTableBuilderInitKey(value, exports.extensionTableInput[value], res);
    }
    res[key] = Object.assign(Object.assign({}, res[value]), { [key]: res[value].__depth + 1, __depth: res[value].__depth + 1 });
}
function initTypeAliasCheck() {
    exports.typeAliasCheck = Object.create(null);
    for (const val of Object.values(Consts_1.TypeAlias)) {
        exports.typeAliasCheck[val] = true;
    }
}
initTypeAliasCheck();
function asTypeAlias(type) {
    if (type in exports.typeAliasCheck) {
        return type;
    }
    return undefined;
}
exports.asTypeAlias = asTypeAlias;
function asKnownLiteralType(type) {
    if (type in exports.superTypeDictTable) {
        return type;
    }
    return undefined;
}
exports.asKnownLiteralType = asKnownLiteralType;
function asOverrideType(type) {
    if (asKnownLiteralType(type) || type === 'term') {
        return type;
    }
    return undefined;
}
exports.asOverrideType = asOverrideType;
function asGeneralType(type) {
    if (type === 'term' || (0, expressions_1.asTermType)(type)) {
        return type;
    }
    return undefined;
}
exports.asGeneralType = asGeneralType;
/**
 * Internal type of @see isSubTypeOf This only takes knownTypes but doesn't need an enabler
 */
function isInternalSubType(baseType, argumentType) {
    return baseType !== 'term' &&
        (exports.superTypeDictTable[baseType] && exports.superTypeDictTable[baseType][argumentType] !== undefined);
}
exports.isInternalSubType = isInternalSubType;
/**
 * This function can be used to check the base type is a restriction on a type in the dict.
 * If we want to check if type x is a restriction on string we do this by calling:
 * 'http://www.w3.org/2001/XMLSchema#string' in getSuperTypeDict(X, superTypeProvider)
 * @param baseType
 * @param superTypeProvider
 */
function getSuperTypeDict(baseType, superTypeProvider) {
    const concreteType = asKnownLiteralType(baseType);
    if (concreteType) {
        // Concrete dataType is known by sparqlee.
        return exports.superTypeDictTable[concreteType];
    }
    // Datatype is a custom datatype
    return getSuperTypes(baseType, superTypeProvider);
}
exports.getSuperTypeDict = getSuperTypeDict;
/**
 * This function needs do be O(1)! The execution time of this function is vital!
 * We define typeA isSubtypeOf typeA as true.
 * If you find yourself using this function a lot (e.g. in a case) please use getSuperTypeDict instead.
 * @param baseType type you want to provide.
 * @param argumentType type you want to provide @param baseType to.
 * @param superTypeProvider the enabler to discover super types of unknown types.
 */
function isSubTypeOf(baseType, argumentType, superTypeProvider) {
    if (baseType === 'term') {
        return false;
    }
    return getSuperTypeDict(baseType, superTypeProvider)[argumentType] !== undefined;
}
exports.isSubTypeOf = isSubTypeOf;
//# sourceMappingURL=TypeHandling.js.map
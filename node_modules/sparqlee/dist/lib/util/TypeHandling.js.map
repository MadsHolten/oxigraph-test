{"version":3,"file":"TypeHandling.js","sourceRoot":"","sources":["../../../lib/util/TypeHandling.ts"],"names":[],"mappings":"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","sourcesContent":["import type * as LRUCache from 'lru-cache';\nimport type { TermType } from '../expressions';\nimport { asTermType } from '../expressions';\nimport type { ArgumentType } from '../functions';\nimport type { KnownLiteralTypes } from './Consts';\nimport { TypeAlias, TypeURL } from './Consts';\n\nexport interface IMainTypeHolder {\n  types: (ArgumentType)[];\n  prio: number;\n}\n\n/**\n * This function return a list of ArgumentTypes and the priority this list has.\n * This priority can be matched with other values returned by this function.\n * This function needs to be in line with the @see extensionTableInput.\n * @param typeURL This will most likely be a @see ExperimentalArgumentType\n */\nexport function mainSparqlType(typeURL: string): IMainTypeHolder {\n  // We transform to StringLiteral when we detect a simple literal being used.\n  // Original issue regarding this behaviour: https://github.com/w3c/sparql-12/issues/112\n  switch (typeURL) {\n    case 'term': return { types: [ 'term' ], prio: 0 };\n    case 'namedNode': return { types: [ 'namedNode' ], prio: 1 };\n    case 'literal': return { types: [ 'literal' ], prio: 1 };\n    case 'blankNode': return { types: [ 'blankNode' ], prio: 1 };\n    case TypeAlias.SPARQL_NON_LEXICAL: return { types: [ 'nonlexical' ], prio: 2 };\n    case null:\n    case undefined:\n    case '':\n    case TypeURL.XSD_ANY_URI:\n    case TypeURL.XSD_NORMALIZED_STRING:\n    case TypeURL.XSD_TOKEN:\n    case TypeURL.XSD_LANGUAGE:\n    case TypeURL.XSD_NM_TOKEN:\n    case TypeURL.XSD_NAME:\n    case TypeURL.XSD_ENTITY:\n    case TypeURL.XSD_ID:\n    case TypeURL.XSD_ID_REF:\n    case TypeURL.XSD_STRING: return { types: [ 'string' ], prio: superTypeDictTable[TypeURL.XSD_STRING].__depth + 2 };\n\n    case TypeURL.RDF_LANG_STRING: return {\n      types: [ 'langString' ],\n      prio: superTypeDictTable[TypeURL.RDF_LANG_STRING].__depth + 2,\n    };\n\n    case TypeURL.XSD_DATE_TIME_STAMP:\n    case TypeURL.XSD_DATE_TIME: return {\n      types: [ 'dateTime' ],\n      prio: superTypeDictTable[TypeURL.XSD_DATE_TIME].__depth + 2,\n    };\n\n    case TypeURL.XSD_BOOLEAN: return {\n      types: [ 'boolean' ],\n      prio: superTypeDictTable[TypeURL.XSD_BOOLEAN].__depth + 2,\n    };\n\n    case TypeURL.XSD_DECIMAL: return {\n      types: [ 'decimal', 'integer' ],\n      prio: superTypeDictTable[TypeURL.XSD_DECIMAL].__depth + 2,\n    };\n    case TypeURL.XSD_FLOAT: return { types: [ 'float' ], prio: superTypeDictTable[TypeURL.XSD_FLOAT].__depth + 2 };\n    case TypeURL.XSD_DOUBLE: return { types: [ 'double' ], prio: superTypeDictTable[TypeURL.XSD_DOUBLE].__depth + 2 };\n\n    case TypeURL.XSD_NON_POSITIVE_INTEGER:\n    case TypeURL.XSD_NEGATIVE_INTEGER:\n    case TypeURL.XSD_LONG:\n    case TypeURL.XSD_INT:\n    case TypeURL.XSD_SHORT:\n    case TypeURL.XSD_BYTE:\n    case TypeURL.XSD_NON_NEGATIVE_INTEGER:\n    case TypeURL.XSD_POSITIVE_INTEGER:\n    case TypeURL.XSD_UNSIGNED_LONG:\n    case TypeURL.XSD_UNSIGNED_INT:\n    case TypeURL.XSD_UNSIGNED_SHORT:\n    case TypeURL.XSD_UNSIGNED_BYTE:\n    case TypeURL.XSD_INTEGER: return {\n      types: [ 'integer' ],\n      prio: superTypeDictTable[TypeURL.XSD_INTEGER].__depth + 2,\n    };\n    case TypeAlias.SPARQL_STRINGLY: return {\n      types: [ 'string', 'langString' ],\n      prio: superTypeDictTable[TypeAlias.SPARQL_STRINGLY].__depth + 2,\n    };\n    case TypeAlias.SPARQL_NUMERIC: return {\n      types: [ 'decimal', 'float', 'integer', 'double' ],\n      prio: superTypeDictTable[TypeAlias.SPARQL_NUMERIC].__depth + 2,\n    };\n    default: return { types: [ 'other' ], prio: 2 };\n  }\n}\n\n// ---------------------------------------------------------------------------------------------------------------------\n// ------------------------------------- experimental code -------------------------------------------------------------\n// ---------------------------------------------------------------------------------------------------------------------\n\nexport type OverrideType = KnownLiteralTypes | 'term';\n\n/**\n * Types that are not mentioned just map to 'term'.\n * When editing this, make sure type promotion and substituion don't start interfering.\n * e.g. when saying something like string -> stringly -> anyUri -> term.\n * This would make substitution on types that promote to each other possible. We and the specs don't want that!\n * A DAG will be created based on this. Make sure it doesn't have any cycles!\n *\n * This needs to be in line with the @see mainSparqlType function.\n */\nexport const extensionTableInput: Record<KnownLiteralTypes, OverrideType> = {\n  // Datetime types\n  [TypeURL.XSD_DATE_TIME_STAMP]: TypeURL.XSD_DATE_TIME,\n\n  // Duration types\n  [TypeURL.XSD_DAYTIME_DURATION]: TypeURL.XSD_DURATION,\n  [TypeURL.XSD_YEAR_MONTH_DURATION]: TypeURL.XSD_DURATION,\n\n  // Stringly types\n  [TypeURL.RDF_LANG_STRING]: TypeAlias.SPARQL_STRINGLY,\n  [TypeURL.XSD_STRING]: TypeAlias.SPARQL_STRINGLY,\n\n  // String types\n  [TypeURL.XSD_NORMALIZED_STRING]: TypeURL.XSD_STRING,\n  [TypeURL.XSD_TOKEN]: TypeURL.XSD_NORMALIZED_STRING,\n  [TypeURL.XSD_LANGUAGE]: TypeURL.XSD_TOKEN,\n  [TypeURL.XSD_NM_TOKEN]: TypeURL.XSD_TOKEN,\n  [TypeURL.XSD_NAME]: TypeURL.XSD_TOKEN,\n  [TypeURL.XSD_NC_NAME]: TypeURL.XSD_NAME,\n  [TypeURL.XSD_ENTITY]: TypeURL.XSD_NC_NAME,\n  [TypeURL.XSD_ID]: TypeURL.XSD_NC_NAME,\n  [TypeURL.XSD_ID_REF]: TypeURL.XSD_NC_NAME,\n\n  // Numeric types\n  // https://www.w3.org/TR/sparql11-query/#operandDataTypes\n  // > numeric denotes typed literals with datatypes xsd:integer, xsd:decimal, xsd:float, and xsd:double\n  [TypeURL.XSD_DOUBLE]: TypeAlias.SPARQL_NUMERIC,\n  [TypeURL.XSD_FLOAT]: TypeAlias.SPARQL_NUMERIC,\n  [TypeURL.XSD_DECIMAL]: TypeAlias.SPARQL_NUMERIC,\n\n  // Decimal types\n  [TypeURL.XSD_INTEGER]: TypeURL.XSD_DECIMAL,\n\n  [TypeURL.XSD_NON_POSITIVE_INTEGER]: TypeURL.XSD_INTEGER,\n  [TypeURL.XSD_NEGATIVE_INTEGER]: TypeURL.XSD_NON_POSITIVE_INTEGER,\n\n  [TypeURL.XSD_LONG]: TypeURL.XSD_INTEGER,\n  [TypeURL.XSD_INT]: TypeURL.XSD_LONG,\n  [TypeURL.XSD_SHORT]: TypeURL.XSD_INT,\n  [TypeURL.XSD_BYTE]: TypeURL.XSD_SHORT,\n\n  [TypeURL.XSD_NON_NEGATIVE_INTEGER]: TypeURL.XSD_INTEGER,\n  [TypeURL.XSD_POSITIVE_INTEGER]: TypeURL.XSD_NON_NEGATIVE_INTEGER,\n  [TypeURL.XSD_UNSIGNED_LONG]: TypeURL.XSD_NON_NEGATIVE_INTEGER,\n  [TypeURL.XSD_UNSIGNED_INT]: TypeURL.XSD_UNSIGNED_LONG,\n  [TypeURL.XSD_UNSIGNED_SHORT]: TypeURL.XSD_UNSIGNED_INT,\n  [TypeURL.XSD_UNSIGNED_BYTE]: TypeURL.XSD_UNSIGNED_SHORT,\n\n  [TypeURL.XSD_DATE_TIME]: 'term',\n  [TypeURL.XSD_BOOLEAN]: 'term',\n  [TypeURL.XSD_DATE]: 'term',\n  [TypeURL.XSD_DURATION]: 'term',\n  [TypeAlias.SPARQL_NUMERIC]: 'term',\n  [TypeAlias.SPARQL_STRINGLY]: 'term',\n  [TypeAlias.SPARQL_NON_LEXICAL]: 'term',\n  [TypeURL.XSD_ANY_URI]: 'term',\n};\ntype SuperTypeDict = Record<KnownLiteralTypes, number> & { __depth: number };\ntype SuperTypeDictTable = Record<KnownLiteralTypes, SuperTypeDict>;\n// The key 'term' is not included in these keys. Something that is just a term will map to number 0.\nexport type GeneralSuperTypeDict = Record<string, number> & { __depth: number };\nexport let superTypeDictTable: SuperTypeDictTable;\n\n/**\n * This will return the super types of a type and cache them.\n * @param type IRI we will decide the super types of.\n * @param openWorldType the enabler that provides a way to find super types.\n */\nexport function getSuperTypes(type: string, openWorldType: ISuperTypeProvider): GeneralSuperTypeDict {\n  const cached = openWorldType.cache.get(type);\n  if (cached) {\n    return cached;\n  }\n  const value = openWorldType.discoverer(type);\n  if (value === 'term') {\n    const res: GeneralSuperTypeDict = Object.create(null);\n    res.__depth = 0;\n    res[type] = 0;\n    openWorldType.cache.set(type, res);\n    return res;\n  }\n  let subExtension: GeneralSuperTypeDict;\n  const knownValue = asKnownLiteralType(value);\n  if (knownValue) {\n    subExtension = { ...superTypeDictTable[knownValue] };\n  } else {\n    subExtension = { ...getSuperTypes(value, openWorldType) };\n  }\n  subExtension.__depth++;\n  subExtension[type] = subExtension.__depth;\n  openWorldType.cache.set(type, subExtension);\n  return subExtension;\n}\n\n// No circular structure allowed! & No other keys allowed!\nexport function extensionTableInit(): void {\n  const res: SuperTypeDictTable = Object.create(null);\n  for (const [ _key, value ] of Object.entries(extensionTableInput)) {\n    const key = <KnownLiteralTypes>_key;\n    if (res[key]) {\n      continue;\n    }\n    extensionTableBuilderInitKey(key, value, res);\n  }\n  superTypeDictTable = res;\n}\nextensionTableInit();\n\nfunction extensionTableBuilderInitKey(key: KnownLiteralTypes, value: OverrideType, res: SuperTypeDictTable): void {\n  if (value === 'term' || value === undefined) {\n    const baseRes: SuperTypeDict = Object.create(null);\n    baseRes.__depth = 0;\n    baseRes[key] = 0;\n    res[key] = baseRes;\n    return;\n  }\n  if (!res[value]) {\n    extensionTableBuilderInitKey(value, extensionTableInput[value], res);\n  }\n  res[key] = { ...res[value], [key]: res[value].__depth + 1, __depth: res[value].__depth + 1 };\n}\n\nexport let typeAliasCheck: Record<TypeAlias, boolean>;\nfunction initTypeAliasCheck(): void {\n  typeAliasCheck = Object.create(null);\n  for (const val of Object.values(TypeAlias)) {\n    typeAliasCheck[val] = true;\n  }\n}\ninitTypeAliasCheck();\n\nexport function asTypeAlias(type: string): TypeAlias | undefined {\n  if (type in typeAliasCheck) {\n    return <TypeAlias> type;\n  }\n  return undefined;\n}\n\nexport function asKnownLiteralType(type: string): KnownLiteralTypes | undefined {\n  if (type in superTypeDictTable) {\n    return <KnownLiteralTypes> type;\n  }\n  return undefined;\n}\n\nexport function asOverrideType(type: string): OverrideType | undefined {\n  if (asKnownLiteralType(type) || type === 'term') {\n    return <OverrideType> type;\n  }\n  return undefined;\n}\n\nexport function asGeneralType(type: string): 'term' | TermType | undefined {\n  if (type === 'term' || asTermType(type)) {\n    return <'term' | TermType> type;\n  }\n  return undefined;\n}\n\nexport type TypeCache = LRUCache<string, GeneralSuperTypeDict>;\nexport type SuperTypeCallback = (unknownType: string) => string;\nexport interface ISuperTypeProvider {\n  cache: TypeCache;\n  discoverer: SuperTypeCallback;\n}\n\n/**\n * Internal type of @see isSubTypeOf This only takes knownTypes but doesn't need an enabler\n */\nexport function isInternalSubType(baseType: OverrideType, argumentType: KnownLiteralTypes): boolean {\n  return baseType !== 'term' &&\n    (superTypeDictTable[baseType] && superTypeDictTable[baseType][argumentType] !== undefined);\n}\n\n/**\n * This function can be used to check the base type is a restriction on a type in the dict.\n * If we want to check if type x is a restriction on string we do this by calling:\n * 'http://www.w3.org/2001/XMLSchema#string' in getSuperTypeDict(X, superTypeProvider)\n * @param baseType\n * @param superTypeProvider\n */\nexport function getSuperTypeDict(baseType: string, superTypeProvider: ISuperTypeProvider): GeneralSuperTypeDict {\n  const concreteType: KnownLiteralTypes | undefined = asKnownLiteralType(baseType);\n  if (concreteType) {\n    // Concrete dataType is known by sparqlee.\n    return superTypeDictTable[concreteType];\n  }\n  // Datatype is a custom datatype\n  return getSuperTypes(baseType, superTypeProvider);\n}\n\n/**\n * This function needs do be O(1)! The execution time of this function is vital!\n * We define typeA isSubtypeOf typeA as true.\n * If you find yourself using this function a lot (e.g. in a case) please use getSuperTypeDict instead.\n * @param baseType type you want to provide.\n * @param argumentType type you want to provide @param baseType to.\n * @param superTypeProvider the enabler to discover super types of unknown types.\n */\nexport function isSubTypeOf(baseType: string, argumentType: KnownLiteralTypes,\n  superTypeProvider: ISuperTypeProvider): boolean {\n  if (baseType === 'term') {\n    return false;\n  }\n  return getSuperTypeDict(baseType, superTypeProvider)[argumentType] !== undefined;\n}\n"]}
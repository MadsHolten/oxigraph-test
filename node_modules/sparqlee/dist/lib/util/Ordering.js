"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.orderTypes = void 0;
const LRUCache = require("lru-cache");
const TermTransformer_1 = require("../transformers/TermTransformer");
// Determine the relative numerical order of the two given terms.
function orderTypes(termA, termB, isAscending, typeDiscoveryCallback, typeCache, enableExtendedXSDTypes) {
    if (termA === termB) {
        return 0;
    }
    // We handle undefined that is lower than everything else.
    if (termA === undefined) {
        return isAscending ? -1 : 1;
    }
    if (termB === undefined) {
        return isAscending ? 1 : -1;
    }
    // We handle terms
    if (termA.equals(termB)) {
        return 0;
    }
    return isTermLowerThan(termA, termB, typeDiscoveryCallback, typeCache, enableExtendedXSDTypes) === isAscending ?
        -1 :
        1;
}
exports.orderTypes = orderTypes;
function isTermLowerThan(termA, termB, typeDiscoveryCallback, typeCache, enableExtendedXSDTypes) {
    if (termA.termType !== termB.termType) {
        return _TERM_ORDERING_PRIORITY[termA.termType] < _TERM_ORDERING_PRIORITY[termB.termType];
    }
    return termA.termType === 'Literal' ?
        isLiteralLowerThan(termA, termB, typeDiscoveryCallback, typeCache, enableExtendedXSDTypes) :
        termA.value < termB.value;
}
function isLiteralLowerThan(litA, litB, typeDiscoveryCallback, typeCache, enableExtendedXSDTypes) {
    const openWorldType = {
        discoverer: typeDiscoveryCallback || (() => 'term'),
        cache: typeCache || new LRUCache(),
    };
    const termTransformer = new TermTransformer_1.TermTransformer(openWorldType, enableExtendedXSDTypes || false);
    const myLitA = termTransformer.transformLiteral(litA);
    const myLitB = termTransformer.transformLiteral(litB);
    const typeA = _SPARQL_TYPE_NORMALIZATION[myLitA.mainSparqlType];
    const typeB = _SPARQL_TYPE_NORMALIZATION[myLitB.mainSparqlType];
    if (typeA !== typeB) {
        return typeA < typeB;
    }
    switch (typeA) {
        case 'boolean':
        case 'dateTime':
        case 'decimal':
        case 'integer':
        case 'float':
        case 'double':
        case 'string':
            return myLitA.typedValue < myLitB.typedValue;
        case 'langString':
            return myLitA.typedValue < myLitB.typedValue ||
                (myLitA.typedValue === myLitB.typedValue && (myLitA.language || '') < (myLitB.language || ''));
        case 'other':
        case 'nonlexical':
            return myLitA.dataType < myLitB.dataType ||
                (myLitA.dataType === myLitB.dataType && myLitA.str() < myLitB.str());
    }
}
// SPARQL specifies that blankNode < namedNode < literal.
const _TERM_ORDERING_PRIORITY = {
    Variable: 0,
    BlankNode: 1,
    NamedNode: 2,
    Literal: 3,
    Quad: 4,
    DefaultGraph: 5,
};
const _SPARQL_TYPE_NORMALIZATION = {
    string: 'string',
    langString: 'langString',
    dateTime: 'dateTime',
    boolean: 'boolean',
    integer: 'decimal',
    decimal: 'decimal',
    float: 'decimal',
    double: 'decimal',
    other: 'other',
    nonlexical: 'other',
};
//# sourceMappingURL=Ordering.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SparqlXmlParser = void 0;
const rdf_data_factory_1 = require("rdf-data-factory");
const saxes_1 = require("saxes");
const readable_stream_1 = require("readable-stream");
/**
 * Parser for the SPARQL Query Results XML format.
 * @see https://www.w3.org/TR/rdf-sparql-XMLres/
 */
class SparqlXmlParser {
    constructor(settings) {
        settings = settings || {};
        this.dataFactory = settings.dataFactory || new rdf_data_factory_1.DataFactory();
        this.prefixVariableQuestionMark = !!settings.prefixVariableQuestionMark;
    }
    /**
     * Convert a SPARQL XML bindings response stream to a stream of bindings objects.
     *
     * The bindings stream will emit a 'variables' event that will contain
     * the array of variables (as RDF.Variable[]), as defined in the response head.
     *
     * @param {NodeJS.ReadableStream} sparqlResponseStream A SPARQL XML response stream.
     * @return {NodeJS.ReadableStream} A stream of bindings.
     */
    parseXmlResultsStream(sparqlResponseStream) {
        const errorListener = (error) => resultStream.emit('error', error);
        sparqlResponseStream.on('error', errorListener);
        const parser = new saxes_1.SaxesParser();
        const stack = [];
        let variablesFound = false;
        let resultsFound = false;
        const variables = [];
        let currentBindings = {};
        let currentBindingName = '';
        let currentBindingType = '';
        let currentBindingAnnotation;
        let currentText = '';
        parser.on("error", errorListener);
        parser.on("opentag", tag => {
            if (tag.name === "variable" && this.stackEquals(stack, ['sparql', 'head'])) {
                variables.push(this.dataFactory.variable(tag.attributes.name));
            }
            else if (tag.name === "results" && this.stackEquals(stack, ['sparql'])) {
                resultsFound = true;
            }
            else if (tag.name === 'result' && this.stackEquals(stack, ['sparql', 'results'])) {
                currentBindings = {};
            }
            else if (tag.name === 'binding' && this.stackEquals(stack, ['sparql', 'results', 'result'])) {
                currentBindingName = tag.attributes.name || '';
                currentBindingType = '';
                currentBindingAnnotation = '';
                currentText = '';
            }
            else if (this.stackEquals(stack, ['sparql', 'results', 'result', 'binding'])) {
                currentBindingType = tag.name;
                if ('xml:lang' in tag.attributes) {
                    currentBindingAnnotation = tag.attributes['xml:lang'];
                }
                else if ('datatype' in tag.attributes) {
                    currentBindingAnnotation = this.dataFactory.namedNode(tag.attributes.datatype);
                }
                else {
                    currentBindingAnnotation = undefined;
                }
            }
            stack.push(tag.name);
        });
        parser.on("closetag", tag => {
            if (this.stackEquals(stack, ['sparql', 'head'])) {
                resultStream.emit("variables", variables);
                variablesFound = true;
            }
            if (this.stackEquals(stack, ['sparql', 'results', 'result'])) {
                resultStream.push(currentBindings);
            }
            if (this.stackEquals(stack, ['sparql', 'results', 'result', 'binding'])) {
                const key = this.prefixVariableQuestionMark ? ('?' + currentBindingName) : currentBindingName;
                if (!currentBindingName && currentBindingType) {
                    errorListener(new Error(`Terms should have a name on line ${parser.line + 1}`));
                }
                else if (currentBindingType === 'uri') {
                    currentBindings[key] = this.dataFactory.namedNode(currentText);
                }
                else if (currentBindingType === 'bnode') {
                    currentBindings[key] = this.dataFactory.blankNode(currentText);
                }
                else if (currentBindingType === 'literal') {
                    currentBindings[key] = this.dataFactory.literal(currentText, currentBindingAnnotation);
                }
                else if (currentBindingType) {
                    errorListener(new Error(`Invalid term type '${currentBindingType}' on line ${parser.line + 1}`));
                }
            }
            stack.pop();
        });
        parser.on("text", text => {
            if (this.stackEquals(stack, ['sparql', 'results', 'result', 'binding', currentBindingType])) {
                currentText = text;
            }
        });
        const resultStream = sparqlResponseStream
            .on("end", _ => {
            if (!resultsFound) {
                resultStream.emit("error", new Error("No valid SPARQL query results were found."));
            }
            else if (!variablesFound) {
                resultStream.emit('variables', []);
            }
        })
            .pipe(new readable_stream_1.Transform({
            objectMode: true,
            transform(chunk, encoding, callback) {
                parser.write(chunk);
                callback();
            }
        }));
        return resultStream;
    }
    /**
     * Convert a SPARQL XML boolean response stream to a promise resolving to a boolean.
     * This will reject if the given response was not a valid boolean response.
     * @param {NodeJS.ReadableStream} sparqlResponseStream A SPARQL XML response stream.
     * @return {Promise<boolean>} The response boolean.
     */
    parseXmlBooleanStream(sparqlResponseStream) {
        return new Promise((resolve, reject) => {
            const parser = new saxes_1.SaxesParser();
            const stack = [];
            parser.on("error", reject);
            parser.on("opentag", tag => {
                stack.push(tag.name);
            });
            parser.on("closetag", _ => {
                stack.pop();
            });
            parser.on("text", text => {
                if (this.stackEquals(stack, ['sparql', 'boolean'])) {
                    resolve(text === 'true');
                }
            });
            sparqlResponseStream
                .on('error', reject)
                .on('data', d => parser.write(d))
                .on('end', () => reject(new Error('No valid ASK response was found.')));
        });
    }
    stackEquals(a, b) {
        return a.length === b.length && a.every((v, i) => b[i] === v);
    }
}
exports.SparqlXmlParser = SparqlXmlParser;
//# sourceMappingURL=SparqlXmlParser.js.map
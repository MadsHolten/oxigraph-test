"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RdfObjectLoader = void 0;
const jsonld_context_parser_1 = require("jsonld-context-parser");
const rdf_data_factory_1 = require("rdf-data-factory");
const rdf_string_1 = require("rdf-string");
const RdfListMaterializer_1 = require("./RdfListMaterializer");
const Resource_1 = require("./Resource");
/**
 * Take a stream or array of RDF quads and loads them as linked resources.
 */
class RdfObjectLoader {
    constructor(args) {
        this.resources = {};
        this.dataFactory = (args === null || args === void 0 ? void 0 : args.dataFactory) || new rdf_data_factory_1.DataFactory();
        this.normalizeLists = !args || !('normalizeLists' in args) || Boolean(args.normalizeLists);
        this.context = new jsonld_context_parser_1.ContextParser().parse(args && args.context || {})
            .then(contextResolved => {
            this.contextResolved = contextResolved;
        }).catch(error => {
            // Save our error so that we can optionally throw it in .import
            this.contextError = error;
        });
    }
    /**
     * Get the resource object for the given term.
     * If it does not exist, one will be created.
     * @param {Term} term An RDF term.
     * @return {Resource} A resource.
     */
    getOrMakeResource(term) {
        const termString = rdf_string_1.termToString(term);
        let resource = this.resources[termString];
        if (!resource) {
            resource = new Resource_1.Resource({ term, context: this.contextResolved });
            this.resources[termString] = resource;
        }
        return resource;
    }
    /**
     * Create a resource for the given hash,
     * where all fields in the given hash are considered to be compacted properties that will be appended.
     *
     * Special field cases:
     * * '@id' represents the IRI identifier.
     * * 'list' is considered an RDF list.
     *
     * Values can be nested hashes, for which other Resources will be created.
     * String values will be converted into term sources following the semantics of rdf-string.js.
     * Values can also be Resources.
     *
     * @param hash A hash containing compacted properties.
     */
    createCompactedResource(hash) {
        // Create resource for string value
        if (typeof hash !== 'object') {
            if (typeof hash === 'string') {
                hash = this.contextResolved.expandTerm(hash);
                if (!hash) {
                    return this.getOrMakeResource(this.dataFactory.blankNode());
                }
            }
            else {
                hash = `"${hash}"`;
            }
            return this.getOrMakeResource(rdf_string_1.stringToTerm(hash, this.dataFactory));
        }
        // Return resource as-is
        if (hash instanceof Resource_1.Resource) {
            return hash;
        }
        // Wrap terms in resources
        if ('termType' in hash && 'equals' in hash) {
            return this.getOrMakeResource(hash);
        }
        // Create resource for named node term by @id value, or blank node
        let term;
        if (hash['@id']) {
            const expandedId = this.contextResolved.expandTerm(hash['@id']);
            if (expandedId) {
                term = this.dataFactory.namedNode(expandedId);
            }
            else {
                term = this.dataFactory.blankNode();
            }
        }
        else {
            term = this.dataFactory.blankNode();
        }
        const resource = this.getOrMakeResource(term);
        // Iterate over all entries in the hash
        for (const [key, value] of Object.entries(hash)) {
            // Skip keys starting with '@'
            if (key === '@type') {
                for (const subValue of Array.isArray(value) ? value : [value]) {
                    let typeResource;
                    if (typeof subValue === 'string') {
                        const expandedId = this.contextResolved.expandTerm(subValue, true);
                        let termType;
                        if (expandedId) {
                            termType = this.dataFactory.namedNode(expandedId);
                        }
                        else {
                            termType = this.dataFactory.blankNode();
                        }
                        typeResource = this.getOrMakeResource(termType);
                    }
                    else {
                        typeResource = this.createCompactedResource(subValue);
                    }
                    resource.properties['http://www.w3.org/1999/02/22-rdf-syntax-ns#type'].push(typeResource);
                }
            }
            else if (!key.startsWith('@')) {
                if (key === 'list') {
                    // Handle RDF list entries
                    resource.list = [];
                    for (const subValue of Array.isArray(value) ? value : [value]) {
                        resource.list.push(this.createCompactedResource(subValue));
                    }
                }
                else {
                    // Handle compacted properties
                    for (const subValue of Array.isArray(value) ? value : [value]) {
                        if (subValue !== undefined) {
                            resource.properties[key].push(this.createCompactedResource(subValue));
                        }
                    }
                }
            }
        }
        return resource;
    }
    /**
     * Create resources for the given hash or array by delegating array entries to {@link createCompactedResource}.
     * @param hashOrArray A hash or array of hashes containing compacted properties.
     */
    createCompactedResources(hashOrArray) {
        if (Array.isArray(hashOrArray)) {
            return hashOrArray.map(hash => this.createCompactedResource(hash));
        }
        return [this.createCompactedResource(hashOrArray)];
    }
    /**
     * Import the given stream of RDF quads.
     * Resources will be created and linked for all passed terms.
     * @param {Stream} stream A stream of RDF quads.
     * @return {Promise<void>} A promise that resolves when the stream has ended.
     * @template Q The type of quad, defaults to RDF.Quad.
     */
    async import(stream) {
        await this.context;
        const listMaterializer = new RdfListMaterializer_1.RdfListMaterializer();
        let listMaterializerPromise;
        if (this.normalizeLists) {
            listMaterializerPromise = listMaterializer.import(stream);
        }
        // Wait until stream has been handled completely
        const streamPromise = new Promise((resolve, reject) => {
            stream.on('data', (quad) => {
                const subject = this.getOrMakeResource(quad.subject);
                const predicate = this.getOrMakeResource(quad.predicate);
                const object = this.getOrMakeResource(quad.object);
                // Handle empty RDF lists
                if (this.normalizeLists && object.term.equals(RdfListMaterializer_1.RdfListMaterializer.RDF_NIL)) {
                    object.list = [];
                }
                subject.addProperty(predicate, object);
            });
            stream.on('error', reject);
            stream.on('end', () => {
                if (this.normalizeLists) {
                    for (const listRoot of listMaterializer.getRoots()) {
                        const listTerms = listMaterializer.getList(listRoot);
                        this.resources[rdf_string_1.termToString(listRoot)].list = listTerms.map(term => this.resources[rdf_string_1.termToString(term)]);
                    }
                }
                resolve();
            });
        });
        // Catches errors from stream and list materialization
        await Promise.all([streamPromise, listMaterializerPromise]);
        if (this.contextError) {
            throw this.contextError;
        }
    }
    /**
     * Import the given array of RDF quads.
     * Resources will be created and linked for all passed terms.
     * @param {Q[]} quads An array of RDF quads.
     * @return {Promise<void>} A promise that resolves when the array has been fully imported.
     * @template Q The type of quad, defaults to RDF.Quad.
     */
    importArray(quads) {
        return this.import(require('streamify-array')(quads));
    }
}
exports.RdfObjectLoader = RdfObjectLoader;
//# sourceMappingURL=RdfObjectLoader.js.map
import type * as RDF from '@rdfjs/types';
import { JsonLdContextNormalized } from 'jsonld-context-parser';
/**
 * A resource is identified by a URI and has property links to other resources.
 */
export declare class Resource {
    private readonly context;
    readonly term: RDF.Term;
    readonly predicates: Resource[];
    readonly propertiesUri: Record<string, Resource[]>;
    readonly properties: Record<string, Resource[]>;
    readonly property: Record<string, Resource>;
    list: Resource[] | undefined;
    constructor(args: IResourceArgs);
    /**
     * Get the term type of this resource.
     * @return {"NamedNode" | "BlankNode" | "Literal" | "Variable" | "DefaultGraph"}
     */
    get type(): string;
    /**
     * @return {string} The URI, blank node label, literal value or variable name of this resource.
     */
    get value(): string;
    /**
     * Check if this resource is of the given type.
     *
     * This will be true if at least one of the following conditions is true.
     * 1. This resource equals `type`.
     * 2. This resource has the rdf:type `type`.
     * 3. This resource is a subclass of `type`.
     * 4. This resource is a subtype or subclass of a resource that is of the given type.
     *
     * @param {RDF.Term | string} type An RDF term or a compacted term string.
     * @return {boolean} If this resource is of the given type.
     */
    isA(type: RDF.Term | string): boolean;
    /**
     * Add a property to the given resource.
     * @param {Resource} predicate Predicate resource of the property link.
     * @param {Resource} object Object resource of the property link.
     */
    addProperty(predicate: Resource, object: Resource): void;
    /**
     * @return {string} The string representation of a Resource
     */
    toString(): string;
    /**
     * Create a convenient JSON representation of a Resource.
     */
    toJSON(maxDepth?: number): any;
    /**
     * Convert this resource into an array of RDF quads.
     */
    toQuads(quads?: RDF.BaseQuad[], dataFactory?: RDF.DataFactory<RDF.BaseQuad>, excludeResources?: Record<string, boolean>): RDF.BaseQuad[];
}
export interface IResourceArgs {
    term: RDF.Term;
    context?: JsonLdContextNormalized;
}

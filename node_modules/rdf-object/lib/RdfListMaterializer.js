"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RdfListMaterializer = void 0;
const rdf_data_factory_1 = require("rdf-data-factory");
const rdf_string_1 = require("rdf-string");
const DF = new rdf_data_factory_1.DataFactory();
/**
 * A helper class for converting RDF lists to JavaScript RDF term term lists
 */
class RdfListMaterializer {
    constructor() {
        this.chains = {};
    }
    static addChain(chains, subject, object, type) {
        const hash = rdf_string_1.termToString(subject);
        if (!chains[hash]) {
            chains[hash] = {};
        }
        chains[hash][type] = object;
    }
    static materializeChain(root, chains, array) {
        if (!array) {
            array = [];
        }
        const hash = rdf_string_1.termToString(root);
        const chain = chains[hash];
        if (chain && chain.first && chain.rest) {
            array.push(chain.first);
            if (!chain.rest.equals(RdfListMaterializer.RDF_NIL)) {
                return RdfListMaterializer.materializeChain(chain.rest, chains, array);
            }
            return array;
        }
    }
    /**
     * Import the given RDF stream.
     * @param {Stream} stream An RDF stream.
     * @return {Promise<void>} A promise that resolves once the stream has ended.
     * @template Q The type of quad, defaults to RDF.Quad.
     */
    import(stream) {
        return new Promise((resolve, reject) => {
            stream.on('data', (quad) => {
                if (quad.predicate.equals(RdfListMaterializer.RDF_FIRST)) {
                    RdfListMaterializer.addChain(this.chains, quad.subject, quad.object, 'first');
                }
                else if (quad.predicate.equals(RdfListMaterializer.RDF_REST)) {
                    RdfListMaterializer.addChain(this.chains, quad.subject, quad.object, 'rest');
                }
            });
            stream.on('error', reject);
            stream.on('end', resolve);
        });
    }
    /**
     * Get the list identified by the given starting term.
     * @param {Term} root A root RDF term that identifies an RDF list.
     * @return {Term[]} A list of terms, or undefined if the given root is not a list.
     */
    getList(root) {
        return RdfListMaterializer.materializeChain(root, this.chains);
    }
    /**
     * @return {Term[]} All available list roots.
     */
    getRoots() {
        return Object.keys(this.chains)
            .filter(key => this.chains[key].first && this.chains[key].rest)
            .map(key => rdf_string_1.stringToTerm(key));
    }
}
exports.RdfListMaterializer = RdfListMaterializer;
RdfListMaterializer.RDF_FIRST = DF.namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#first');
RdfListMaterializer.RDF_REST = DF.namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#rest');
RdfListMaterializer.RDF_NIL = DF.namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#nil');
//# sourceMappingURL=RdfListMaterializer.js.map
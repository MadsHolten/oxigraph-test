"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Resource = void 0;
const jsonld_context_parser_1 = require("jsonld-context-parser");
const rdf_data_factory_1 = require("rdf-data-factory");
const rdf_string_1 = require("rdf-string");
const RdfListMaterializer_1 = require("./RdfListMaterializer");
const ShortcutPropertyHandler_1 = require("./ShortcutPropertyHandler");
const SingularPropertyHandler_1 = require("./SingularPropertyHandler");
/**
 * A resource is identified by a URI and has property links to other resources.
 */
class Resource {
    constructor(args) {
        this.context = args.context || new jsonld_context_parser_1.JsonLdContextNormalized({});
        this.term = args.term;
        this.predicates = [];
        this.propertiesUri = {};
        this.properties = new Proxy(this.propertiesUri, new ShortcutPropertyHandler_1.ShortcutPropertyHandler(this.context));
        this.property = new Proxy(this.properties, new SingularPropertyHandler_1.SingularPropertyHandler());
    }
    /**
     * Get the term type of this resource.
     * @return {"NamedNode" | "BlankNode" | "Literal" | "Variable" | "DefaultGraph"}
     */
    get type() {
        return this.term.termType;
    }
    /**
     * @return {string} The URI, blank node label, literal value or variable name of this resource.
     */
    get value() {
        return this.term.value;
    }
    /**
     * Check if this resource is of the given type.
     *
     * This will be true if at least one of the following conditions is true.
     * 1. This resource equals `type`.
     * 2. This resource has the rdf:type `type`.
     * 3. This resource is a subclass of `type`.
     * 4. This resource is a subtype or subclass of a resource that is of the given type.
     *
     * @param {RDF.Term | string} type An RDF term or a compacted term string.
     * @return {boolean} If this resource is of the given type.
     */
    isA(type) {
        // Consider strings compacted terms
        if (typeof type === 'string') {
            const typeExpanded = this.context.expandTerm(type, true);
            if (!typeExpanded) {
                return false;
            }
            type = rdf_string_1.stringToTerm(typeExpanded);
        }
        if (type.equals(this.term)) {
            return true;
        }
        return [
            ...this.propertiesUri['http://www.w3.org/1999/02/22-rdf-syntax-ns#type'] || [],
            ...this.propertiesUri['http://www.w3.org/2000/01/rdf-schema#subClassOf'] || [],
        ].reduce((acc, superType) => acc || superType.isA(type), false);
    }
    /**
     * Add a property to the given resource.
     * @param {Resource} predicate Predicate resource of the property link.
     * @param {Resource} object Object resource of the property link.
     */
    addProperty(predicate, object) {
        const propertyUri = rdf_string_1.termToString(predicate.term);
        let properties = this.propertiesUri[propertyUri];
        if (!properties) {
            this.propertiesUri[propertyUri] = properties = [];
        }
        properties.push(object);
        this.predicates.push(predicate);
    }
    /**
     * @return {string} The string representation of a Resource
     */
    toString() {
        return this.value;
    }
    /**
     * Create a convenient JSON representation of a Resource.
     */
    toJSON(maxDepth = -1) {
        if (Object.keys(this.properties).length === 0 && !this.list) {
            return rdf_string_1.termToString(this.term);
        }
        return Object.assign(Object.assign({ '@id': rdf_string_1.termToString(this.term) }, maxDepth !== 0 && Object.keys(this.properties).length > 0 ?
            {
                properties: Object.keys(this.properties).reduce((acc, key) => {
                    acc[key] = this.properties[key].map(resource => resource.toJSON(maxDepth - 1));
                    return acc;
                }, {}),
            } :
            {}), maxDepth !== 0 && this.list ? { list: this.list.map(resource => resource.toJSON(maxDepth - 1)) } : {});
    }
    /**
     * Convert this resource into an array of RDF quads.
     */
    toQuads(quads = [], dataFactory = new rdf_data_factory_1.DataFactory(), excludeResources = {}) {
        // Circumvent infinite recursion by checking and maintaining emittedResources
        const resourceId = rdf_string_1.termToString(this.term);
        if (excludeResources[resourceId]) {
            return [];
        }
        excludeResources[resourceId] = true;
        // Handle predicates
        for (const [property, resources] of Object.entries(this.propertiesUri)) {
            const subject = this.term;
            const predicate = dataFactory.namedNode(property);
            for (const resource of resources) {
                const object = resource.list && resource.list.length === 0 ? RdfListMaterializer_1.RdfListMaterializer.RDF_NIL : resource.term;
                quads.push(dataFactory.quad(subject, predicate, object));
                resource.toQuads(quads, dataFactory, excludeResources);
            }
        }
        // Handle RDF lists
        if (this.list) {
            let chain = this.term;
            let chainPrev;
            for (const element of this.list) {
                if (chainPrev) {
                    quads.push(dataFactory.quad(chainPrev, RdfListMaterializer_1.RdfListMaterializer.RDF_REST, chain));
                }
                quads.push(dataFactory.quad(chain, RdfListMaterializer_1.RdfListMaterializer.RDF_FIRST, element.term));
                element.toQuads(quads, dataFactory, excludeResources);
                chainPrev = chain;
                chain = dataFactory.blankNode();
            }
            if (chainPrev) {
                quads.push(dataFactory.quad(chainPrev, RdfListMaterializer_1.RdfListMaterializer.RDF_REST, RdfListMaterializer_1.RdfListMaterializer.RDF_NIL));
            }
        }
        return quads;
    }
}
exports.Resource = Resource;
//# sourceMappingURL=Resource.js.map
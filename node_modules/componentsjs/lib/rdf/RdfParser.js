"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RdfParser = void 0;
const fs_1 = require("fs");
const rdf_parse_1 = require("rdf-parse");
const PrefetchedDocumentLoader_1 = require("./PrefetchedDocumentLoader");
const RdfStreamIncluder_1 = require("./RdfStreamIncluder");
// Import syntax only works in Node > 12
const fs = require('fs').promises;
/**
 * Parses a data stream to a triple stream.
 */
class RdfParser {
    /**
     * Parses the given stream into RDF quads.
     * @param textStream A text stream.
     * @param options Parsing options.
     */
    parse(textStream, options) {
        // Parsing libraries don't work as expected if path contains backslashes
        options.path = options.path.replace(/\\+/gu, '/');
        if (!options.baseIRI) {
            // Try converting path to URL using defined import paths
            if (options.importPaths) {
                for (const [url, file] of Object.entries(options.importPaths)) {
                    if (options.path.startsWith(file)) {
                        options.baseIRI = `${url}${options.path.slice(file.length)}`;
                        break;
                    }
                }
            }
            // Fallback to a baseIRI using the file scheme
            if (!options.baseIRI) {
                options.baseIRI = options.path;
                // Windows paths always contain a ':'
                if (!options.baseIRI.includes(':') || /^[A-Za-z]:[/\\][^/]/u.test(options.baseIRI)) {
                    options.baseIRI = `file://${options.baseIRI}`;
                }
            }
        }
        // Set JSON-LD parser options
        options['@comunica/actor-rdf-parse-jsonld:parserOptions'] = {
            // Override the JSON-LD document loader
            documentLoader: new PrefetchedDocumentLoader_1.PrefetchedDocumentLoader({
                contexts: options.contexts || {},
                logger: options.logger,
                path: options.path,
            }),
            // Enable strict parsing of JSON-LD to error on potential user config errors
            strictValues: true,
            // If JSON-LD context validation should be skipped
            skipContextValidation: options.skipContextValidation,
        };
        // Execute parsing
        const quadStream = rdf_parse_1.default.parse(textStream, options);
        const includedQuadStream = quadStream.pipe(new RdfStreamIncluder_1.RdfStreamIncluder(options));
        quadStream.on('error', (error) => includedQuadStream
            .emit('error', RdfParser.addPathToError(error, options.path)));
        return includedQuadStream;
    }
    /**
     * Get the file contents from a file path or URL.
     * @param pathOrUrl The file path or url.
     * @returns {Promise<T>} A promise resolving to the data stream.
     */
    static async fetchFileOrUrl(pathOrUrl) {
        if (pathOrUrl.startsWith('http://') || pathOrUrl.startsWith('https://')) {
            return (await fetch(pathOrUrl)).body;
        }
        if (pathOrUrl.startsWith('file://')) {
            pathOrUrl = pathOrUrl.slice(7);
        }
        if (!(await fs.stat(pathOrUrl)).isFile()) {
            throw new Error(`Path does not refer to a valid file: ${pathOrUrl}`);
        }
        return (0, fs_1.createReadStream)(pathOrUrl);
    }
    /**
     * Add the path to an error message.
     * @param error The original error message.
     * @param path The file path or URL.
     * @returns {Error} The new error with file path context.
     */
    static addPathToError(error, path) {
        return new Error(`Error while parsing file "${path}": ${error.message}`);
    }
}
exports.RdfParser = RdfParser;
//# sourceMappingURL=RdfParser.js.map
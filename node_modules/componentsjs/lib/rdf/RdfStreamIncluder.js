"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RdfStreamIncluder = void 0;
const Path = require("path");
const stream_1 = require("stream");
const rdf_terms_1 = require("rdf-terms");
const Iris_1 = require("./Iris");
const RdfParser_1 = require("./RdfParser");
/**
 * A RdfStreamIncluder takes a triple stream and detects owl:includes to automatically include other files.
 */
class RdfStreamIncluder extends stream_1.Transform {
    constructor(parserOptions) {
        super({ objectMode: true });
        this.runningImporters = 1;
        this._readableState.objectMode = true;
        this.parserOptions = parserOptions;
    }
    _transform(quad, encoding, callback) {
        this.handleImports(quad);
        this.validateIris(quad);
        callback(null, quad);
        return true;
    }
    _flush(callback) {
        if (--this.runningImporters === 0) {
            // eslint-disable-next-line callback-return
            callback();
        }
        else {
            this.flushCallback = callback;
        }
    }
    /**
     * Follow all import links in the given quad.
     * @param quad A quad.
     */
    handleImports(quad) {
        if (!this.parserOptions.ignoreImports && quad.predicate.value === Iris_1.IRIS_RDFS.seeAlso) {
            this.runningImporters++;
            let relativeFilePath = decodeURI(quad.object.value);
            // Try overriding path using defined import paths
            if (this.parserOptions.importPaths) {
                for (const prefix of Object.keys(this.parserOptions.importPaths)) {
                    if (relativeFilePath.startsWith(prefix)) {
                        relativeFilePath = Path.join(this.parserOptions.importPaths[prefix], relativeFilePath.slice(prefix.length));
                        break;
                    }
                }
            }
            // Recursively call the parser
            RdfParser_1.RdfParser.fetchFileOrUrl(relativeFilePath)
                .then((rawStream) => {
                const data = new RdfParser_1.RdfParser().parse(rawStream, Object.assign(Object.assign({}, this.parserOptions), { baseIRI: undefined, path: relativeFilePath, importedFromPath: this.parserOptions.path }));
                data
                    .on('data', (subData) => this.push(subData))
                    .on('error', (error) => this.emit('error', error))
                    .on('end', () => {
                    if (this.flushCallback && --this.runningImporters === 0) {
                        this.flushCallback();
                    }
                });
            })
                .catch((error) => this.emit('error', RdfParser_1.RdfParser.addPathToError(error, this.parserOptions.path)));
        }
    }
    /**
     * Emit a warning for all named nodes in the given quad that may be invalid.
     * @param quad A quad.
     */
    validateIris(quad) {
        if (this.parserOptions.logger) {
            for (const term of (0, rdf_terms_1.getNamedNodes)((0, rdf_terms_1.getTerms)(quad))) {
                if (!RdfStreamIncluder.isValidIri(term.value)) {
                    this.parserOptions.logger.warn(`Detected potentially invalid IRI '${term.value}' in ${this.parserOptions.path}`);
                }
            }
        }
    }
    /**
     * Check if the given IRI is valid.
     * @param iri A potential IRI.
     */
    static isValidIri(iri) {
        return Boolean(/:((\/\/)|(.*:))/u.exec(iri));
    }
}
exports.RdfStreamIncluder = RdfStreamIncluder;
//# sourceMappingURL=RdfStreamIncluder.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConfigConstructor = void 0;
const ErrorResourcesContext_1 = require("../util/ErrorResourcesContext");
const ArgumentConstructorHandlerArray_1 = require("./argument/ArgumentConstructorHandlerArray");
const ArgumentConstructorHandlerHash_1 = require("./argument/ArgumentConstructorHandlerHash");
const ArgumentConstructorHandlerList_1 = require("./argument/ArgumentConstructorHandlerList");
const ArgumentConstructorHandlerPrimitive_1 = require("./argument/ArgumentConstructorHandlerPrimitive");
const ArgumentConstructorHandlerReference_1 = require("./argument/ArgumentConstructorHandlerReference");
const ArgumentConstructorHandlerUndefined_1 = require("./argument/ArgumentConstructorHandlerUndefined");
const ArgumentConstructorHandlerValue_1 = require("./argument/ArgumentConstructorHandlerValue");
/**
 * Creates instances of raw configs using the configured creation strategy.
 *
 * A raw config MUST adhere to the following shape:
 * * requireName: required
 * * requireElement: optional
 * * arguments: optional
 *
 * Arguments will recursively be converted to instances using {@link IArgumentConstructorHandler}'s.
 *
 * This will always create unique instances of configs.
 * If you want to make sure that instances are reused,
 * be sure to call {@link ConfigConstructorPool} instead.
 */
class ConfigConstructor {
    constructor(options) {
        this.objectLoader = options.objectLoader;
        this.configConstructorPool = options.configConstructorPool;
        this.constructionStrategy = options.constructionStrategy;
        this.moduleState = options.moduleState;
    }
    async getArgumentValues(values, settings) {
        if (values.length === 0) {
            return this.constructionStrategy.createUndefined();
        }
        if (values.length > 1) {
            throw new ErrorResourcesContext_1.ErrorResourcesContext(`Detected multiple values for an argument. RDF lists should be used for defining multiple values.`, {
                arguments: values,
            });
        }
        return this.getArgumentValue(values[0], settings);
    }
    async getArgumentValue(value, settings) {
        // Check if this args resource can be handled by one of the built-in handlers.
        for (const handler of ConfigConstructor.ARGS_HANDLERS) {
            if (handler.canHandle(value, settings, this)) {
                return handler.handle(value, settings, this);
            }
        }
        // Error if no handlers can handle this argument
        throw new ErrorResourcesContext_1.ErrorResourcesContext('Unsupported argument value during config construction', { value });
    }
    /**
     * Create constructor arguments for the given config's constructor.
     * @param config The config to instantiate.
     * @param settings The settings for creating the instance.
     * @returns New instantiations of the provided arguments.
     */
    async createArguments(config, settings) {
        if (config.property.arguments) {
            if (!config.property.arguments.list) {
                throw new ErrorResourcesContext_1.ErrorResourcesContext('Detected non-RDF-list as value for config arguments', { config });
            }
            return await Promise.all(config.property.arguments.list
                .map((resource) => this.getArgumentValue(resource, settings)));
        }
        return [];
    }
    /**
     * Create an instance based on the given config.
     * @param config The config to instantiate.
     * @param settings The settings for creating the instance.
     * @returns A new instance of the component.
     */
    async createInstance(config, settings) {
        var _a;
        const args = await this.createArguments(config, settings);
        return this.constructionStrategy.createInstance({
            settings,
            moduleState: this.moduleState,
            requireName: config.property.requireName.value,
            requireElement: (_a = config.property.requireElement) === null || _a === void 0 ? void 0 : _a.value,
            callConstructor: !config.isA('Instance') &&
                (!config.property.requireNoConstructor || config.property.requireNoConstructor.value !== 'true'),
            instanceId: (config.property.originalInstance || config).value,
            args,
        });
    }
}
exports.ConfigConstructor = ConfigConstructor;
ConfigConstructor.ARGS_HANDLERS = [
    new ArgumentConstructorHandlerUndefined_1.ArgumentConstructorHandlerUndefined(),
    new ArgumentConstructorHandlerHash_1.ArgumentConstructorHandlerHash(),
    new ArgumentConstructorHandlerArray_1.ArgumentConstructorHandlerArray(),
    new ArgumentConstructorHandlerList_1.ArgumentConstructorHandlerList(),
    new ArgumentConstructorHandlerValue_1.ArgumentConstructorHandlerValue(),
    new ArgumentConstructorHandlerReference_1.ArgumentConstructorHandlerReference(),
    new ArgumentConstructorHandlerPrimitive_1.ArgumentConstructorHandlerPrimitive(),
];
//# sourceMappingURL=ConfigConstructor.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConstructionStrategyCommonJs = void 0;
const Path = require("path");
/**
 * A creation strategy for creating instances with CommonJS.
 */
class ConstructionStrategyCommonJs {
    // eslint-disable-next-line unicorn/no-object-as-default-parameter
    constructor(options = { req: require }) {
        this.overrideRequireNames = options.overrideRequireNames || {};
        this.req = options.req;
    }
    createInstance(options) {
        // Call require()
        options.requireName = this.overrideRequireNames[options.requireName] || options.requireName;
        // First try requiring current module, and fallback to a plain require
        let object;
        const currentResult = this.requireCurrentRunningModuleIfCurrent(options.moduleState, options.requireName);
        object = currentResult !== false ?
            currentResult.value :
            this.req(options.requireName.startsWith('.') ?
                Path.join(process.cwd(), options.requireName) :
                this.req.resolve(options.requireName, { paths: [options.moduleState.mainModulePath] }));
        // Determine the child of the require'd element
        let subObject;
        if (options.requireElement) {
            const requireElementPath = options.requireElement.split('.');
            try {
                subObject = requireElementPath.reduce((acc, subRequireElement) => acc[subRequireElement], object);
            }
            catch (_a) {
                throw new Error(`Failed to get module element ${options.requireElement} from module ${options.requireName}`);
            }
        }
        else {
            subObject = object;
        }
        if (!subObject) {
            throw new Error(`Failed to get module element ${options.requireElement} from module ${options.requireName}`);
        }
        // Call the constructor of the element
        object = subObject;
        if (options.callConstructor) {
            if (typeof object !== 'function') {
                throw new Error(`Attempted to construct ${options.requireElement} from module ${options.requireName} that does not have a constructor`);
            }
            object = new (Function.prototype.bind.apply(object, [{}].concat(options.args)))();
        }
        return object;
    }
    /**
     * Require the given module iff the module is the current main module.
     * This is done by looking for the nearest package.json.
     * @param moduleState The module state.
     * @param requireName The module name that should be required.
     * @returns {any} The require() result
     */
    requireCurrentRunningModuleIfCurrent(moduleState, requireName) {
        const pckg = moduleState.packageJsons[moduleState.mainModulePath];
        if (pckg) {
            if (requireName === pckg.name) {
                const mainPath = Path.posix.join(moduleState.mainModulePath, pckg.main);
                const required = this.req(mainPath);
                if (required) {
                    return { value: required };
                }
            }
        }
        return false;
    }
    createHash(options) {
        return options.entries.reduce((data, entry) => {
            if (entry) {
                data[entry.key] = entry.value;
            }
            return data;
        }, {});
    }
    createArray(options) {
        return options.elements;
    }
    async createLazySupplier(options) {
        return options.supplier;
    }
    createPrimitive(options) {
        return options.value;
    }
    getVariableValue(options) {
        const value = options.settings.variables ? options.settings.variables[options.variableName] : undefined;
        if (value === undefined) {
            throw new Error(`Undefined variable: ${options.variableName}`);
        }
        return value;
    }
    createUndefined() {
        // Return undefined
    }
}
exports.ConstructionStrategyCommonJs = ConstructionStrategyCommonJs;
//# sourceMappingURL=ConstructionStrategyCommonJs.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ArgumentConstructorHandlerHash = void 0;
const ErrorResourcesContext_1 = require("../../util/ErrorResourcesContext");
/**
 * Handles arguments with fields as hashes.
 */
class ArgumentConstructorHandlerHash {
    canHandle(value, settings, argsCreator) {
        return Boolean(value.property.fields);
    }
    async handle(argument, settings, argsCreator) {
        const fields = argument.property.fields.list || [];
        // Determine all key-value pairs
        const entries = await Promise.all(fields.map(async (entry) => {
            // Validate entry
            if (!entry.property.key) {
                throw new ErrorResourcesContext_1.ErrorResourcesContext(`Missing key in fields entry`, { entry, argument });
            }
            if (entry.property.key.type !== 'Literal') {
                throw new ErrorResourcesContext_1.ErrorResourcesContext(`Illegal non-literal key (${entry.property.key.value} as ${entry.property.key.type}) in fields entry`, { entry, argument });
            }
            // Recursively get value arg value
            if (entry.property.value) {
                const subValue = await argsCreator.getArgumentValues(entry.properties.value, settings);
                return { key: entry.property.key.value, value: subValue };
            }
            // Ignore cases where value may not be set, because params may be optional
        }));
        // Create a hash containing the key-value pairs
        return argsCreator.constructionStrategy.createHash({ settings, entries });
    }
}
exports.ArgumentConstructorHandlerHash = ArgumentConstructorHandlerHash;
//# sourceMappingURL=ArgumentConstructorHandlerHash.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConfigConstructorPool = void 0;
const rdf_string_1 = require("rdf-string");
const ErrorResourcesContext_1 = require("../util/ErrorResourcesContext");
const ConfigConstructor_1 = require("./ConfigConstructor");
/**
 * Manages and creates instances of components based on a given config.
 *
 * This accepts different config variants, as supported by the configured {@link IConfigPreprocessor}'s.
 *
 * This will make sure that configs with the same id will only be instantiated once,
 * and multiple references to configs will always reuse the same instance.
 */
class ConfigConstructorPool {
    constructor(options) {
        this.instances = {};
        this.configPreprocessors = options.configPreprocessors;
        this.configConstructor = new ConfigConstructor_1.ConfigConstructor({
            objectLoader: options.objectLoader,
            configConstructorPool: this,
            constructionStrategy: options.constructionStrategy,
            moduleState: options.moduleState,
        });
        this.constructionStrategy = options.constructionStrategy;
    }
    instantiate(configResource, settings) {
        // Check if this resource is required as argument in its own chain,
        // if so, return a dummy value, to avoid infinite recursion.
        const resourceBlacklist = settings.resourceBlacklist || {};
        const configResourceId = (0, rdf_string_1.termToString)(configResource.term);
        if (resourceBlacklist[configResourceId]) {
            return Promise.reject(new ErrorResourcesContext_1.ErrorResourcesContext(`Circular dependency was detected on ${configResource.value}`, { config: configResource }));
        }
        // Before instantiating, first check if the resource is a variable
        if (configResource.isA('Variable')) {
            return Promise.resolve(this.constructionStrategy
                .getVariableValue({ settings, variableName: configResource.value }));
        }
        // Instantiate only once
        if (!(configResourceId in this.instances)) {
            // The blacklist avoids infinite recursion for self-referencing configs
            const subBlackList = Object.assign({}, resourceBlacklist);
            subBlackList[configResourceId] = true;
            // Prepare instance parameters
            let rawConfig;
            try {
                rawConfig = this.getRawConfig(configResource);
            }
            catch (syncError) {
                this.instances[configResourceId] = Promise.reject(syncError);
                return this.instances[configResourceId];
            }
            const subSettings = Object.assign(Object.assign({}, settings), { resourceBlacklist: subBlackList });
            // Invoke instance creation
            this.instances[configResourceId] = this.configConstructor.createInstance(rawConfig, subSettings);
        }
        return this.instances[configResourceId];
    }
    /**
     * Determine the raw config of the given config.
     * As such, the config can be transformd by zero or more {@link IConfigPreprocessor}'s.
     *
     * @param config Config to possibly transform.
     * @returns The raw config data.
     */
    getRawConfig(config) {
        // Try to preprocess the config
        for (const rawConfigFactory of this.configPreprocessors) {
            const handleResponse = rawConfigFactory.canHandle(config);
            if (handleResponse) {
                const { rawConfig, finishTransformation } = rawConfigFactory.transform(config, handleResponse);
                if (finishTransformation) {
                    this.validateRawConfig(rawConfig);
                    return rawConfig;
                }
                config = rawConfig;
            }
        }
        // If none can handle it, just return the original config
        this.validateRawConfig(config);
        return config;
    }
    /**
     * Check if the given config is valid.
     * Will throw an error if it is invalid.
     * @param rawConfig The config resource to validate.
     */
    validateRawConfig(rawConfig) {
        this.validateParam(rawConfig, 'requireName', 'Literal');
        this.validateParam(rawConfig, 'requireElement', 'Literal', true);
        this.validateParam(rawConfig, 'requireNoConstructor', 'Literal', true);
    }
    /**
     * Check if the given field of given type exists in the given resource.
     * @param config A resource to look in.
     * @param field A field name to look for.
     * @param type The term type to expect.
     * @param optional If the field is optional.
     */
    validateParam(config, field, type, optional) {
        if (!config.property[field]) {
            if (!optional) {
                throw new ErrorResourcesContext_1.ErrorResourcesContext(`Invalid config: Missing ${field}`, { config });
            }
            else {
                return;
            }
        }
        if (config.property[field].type !== type) {
            throw new ErrorResourcesContext_1.ErrorResourcesContext(`Invalid config: ${field} "${config.property[field].value}" must be a ${type}, but got ${config.property[field].type}`, { config });
        }
    }
    /**
     * Returns the instance registry.
     */
    getInstanceRegistry() {
        return this.instances;
    }
    /**
     * Resets all preprocessors and clears the cached instances.
     */
    reset() {
        this.instances = {};
        for (const preprocessor of this.configPreprocessors) {
            preprocessor.reset();
        }
    }
}
exports.ConfigConstructorPool = ConfigConstructorPool;
//# sourceMappingURL=ConfigConstructorPool.js.map
import type * as RDF from '@rdfjs/types';
import type { Resource, RdfObjectLoader } from 'rdf-object';
import type { IParamValueConflict } from './parameterproperty/ParameterPropertyHandlerRange';
/**
 * Context for binding generic types to a concrete range value.
 */
export declare class GenericsContext {
    private static readonly XSD_INHERITANCE_TABLE;
    private readonly objectLoader;
    /**
     * Set of generic type ids.
     * @private
     */
    genericTypeIds: Record<string, boolean>;
    /**
     * Mapping of generic type id to the resolved range.
     * @private
     */
    bindings: Record<string, Resource>;
    constructor(objectLoader: RdfObjectLoader, genericTypeParameters: Resource[]);
    /**
     * Try to to bind the given value to the given generic.
     * @param genericTypeId IRI of the generic to bind.
     * @param value The value to bind to.
     * @param valueTypeValidator Callback for validating values against types.
     * @param typeTypeValidator Callback for validating sub-types against super-types.
     * @return boolean True if the binding was valid and took place.
     */
    bindGenericTypeToValue(genericTypeId: string, value: Resource | undefined, valueTypeValidator: (subValue: Resource | undefined, subType: Resource) => IParamValueConflict | undefined, typeTypeValidator: (subValue: Resource, subType: Resource) => IParamValueConflict | undefined): IParamValueConflict | undefined;
    /**
     * Try to bind the given range to the given generic.
     * @param genericTypeId IRI of the generic to bind.
     * @param range The range to bind to.
     * @param typeTypeValidator Callback for validating sub-types against super-types.
     * @return boolean True if the binding was valid and took place.
     */
    bindGenericTypeToRange(genericTypeId: string, range: Resource, typeTypeValidator: (subType: Resource, superType: Resource) => IParamValueConflict | undefined): IParamValueConflict | undefined;
    /**
     * Infer the parameter range of the given value.
     * @param value A value.
     */
    inferValueRange(value: Resource | undefined): Resource | undefined;
    /**
     * Merge the given ranges into a new range.
     * This will return undefined in the ranges are incompatible.
     *
     * If one type is more specific than the other, it will return the narrowest type.
     *
     * @param rangeA A first range.
     * @param rangeB A second range.
     * @param typeTypeValidator Callback for validating sub-types against super-types.
     */
    mergeRanges(rangeA: Resource, rangeB: Resource, typeTypeValidator: (subType: Resource, superType: Resource) => IParamValueConflict | undefined): Resource | undefined;
    protected mergeUnion(rangeUnion: Resource, rangeOther: Resource, typeValidator: (subType: Resource, superType: Resource) => IParamValueConflict | undefined): Resource | undefined;
    /**
     * Check if the given type is a subtype of the given super type.
     * @param type A type node.
     * @param potentialSuperType A potential super type node.
     */
    isXsdSubType(type: RDF.Term, potentialSuperType: RDF.Term): boolean;
    /**
     * Apply the give generic type instances for the given component's generic type parameters.
     *
     * This will throw if the number of passed instances does not match with
     * the number of generic type parameters on the component.
     *
     * @param component The component
     * @param genericTypeInstances The generic type instances to apply.
     * @param errorContext The context for error reporting.
     * @param typeTypeValidator Callback for validating sub-types against super-types.
     * @return boolean False if the application failed due to a binding error. True otherwise
     */
    bindComponentGenericTypes(component: Resource, genericTypeInstances: Resource[], errorContext: Record<string, Resource | Resource[] | string>, typeTypeValidator: (subValue: Resource, subType: Resource) => IParamValueConflict | undefined): IParamValueConflict | undefined;
}

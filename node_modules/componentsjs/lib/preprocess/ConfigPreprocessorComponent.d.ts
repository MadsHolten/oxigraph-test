import type { Resource, RdfObjectLoader } from 'rdf-object';
import type { Logger } from 'winston';
import { GenericsContext } from './GenericsContext';
import type { IConfigPreprocessorTransform, IConfigPreprocessor } from './IConfigPreprocessor';
import type { ParameterHandler } from './ParameterHandler';
/**
 * Handles config that refer to a component as type.
 * The component may have parameters that can be applied on the config.
 */
export declare class ConfigPreprocessorComponent implements IConfigPreprocessor<IComponentConfigPreprocessorHandleResponse> {
    readonly objectLoader: RdfObjectLoader;
    protected readonly componentResources: Record<string, Resource>;
    protected readonly runTypeConfigs: Record<string, Resource[]>;
    protected readonly parameterHandler: ParameterHandler;
    protected readonly logger: Logger;
    constructor(options: IComponentConfigPreprocessorOptions);
    canHandle(config: Resource): IComponentConfigPreprocessorHandleResponse | undefined;
    transform(config: Resource, handleResponse: IComponentConfigPreprocessorHandleResponse): IConfigPreprocessorTransform;
    protected createGenericsContext(handleResponse: IComponentConfigPreprocessorHandleResponse, config: Resource): GenericsContext;
    /**
     * Determine the constructor arguments of the given config.
     * @param config A config.
     * @param handleResponse Return value of the {#canHandle}.
     */
    transformConstructorArguments(config: Resource, handleResponse: IComponentConfigPreprocessorHandleResponse): Resource;
    /**
     * Let this config inherit parameter values from previously instantiated configs.
     * This will check for inheritanceValues that are defined on the component,
     * which can refer to parameters from other components.
     *
     * For example, assume we had previously instantiated a component X with param P set to 'value'.
     * If we instantiate component Y, which is defined to inherit values from param P of X,
     * then it will automatically inherit this param P set to 'value'.
     *
     * This can effectively mutate the given config resource.
     * @param config The config
     * @param component The component
     */
    inheritParameterValues(config: Resource, component: Resource): void;
    /**
     * Run checks to see if the given config is valid.
     * @param config The original config.
     * @param handleResponse The handle response.
     */
    validateConfig(config: Resource, handleResponse: IComponentConfigPreprocessorHandleResponse): void;
    reset(): void;
}
export interface IComponentConfigPreprocessorOptions {
    objectLoader: RdfObjectLoader;
    componentResources: Record<string, Resource>;
    runTypeConfigs: Record<string, Resource[]>;
    parameterHandler: ParameterHandler;
    logger: Logger;
}
export interface IComponentConfigPreprocessorHandleResponse {
    module: Resource;
    component: Resource;
}

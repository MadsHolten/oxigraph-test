"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ParameterHandler = void 0;
const ErrorResourcesContext_1 = require("../util/ErrorResourcesContext");
const ParameterPropertyHandlerDefault_1 = require("./parameterproperty/ParameterPropertyHandlerDefault");
const ParameterPropertyHandlerDefaultScoped_1 = require("./parameterproperty/ParameterPropertyHandlerDefaultScoped");
const ParameterPropertyHandlerFixed_1 = require("./parameterproperty/ParameterPropertyHandlerFixed");
const ParameterPropertyHandlerLazy_1 = require("./parameterproperty/ParameterPropertyHandlerLazy");
const ParameterPropertyHandlerRange_1 = require("./parameterproperty/ParameterPropertyHandlerRange");
/**
 * Handles component parameters in the context of a config.
 */
class ParameterHandler {
    constructor(options) {
        this.objectLoader = options.objectLoader;
        this.parameterPropertyHandlers = [
            new ParameterPropertyHandlerDefaultScoped_1.ParameterPropertyHandlerDefaultScoped(this.objectLoader),
            new ParameterPropertyHandlerDefault_1.ParameterPropertyHandlerDefault(this.objectLoader),
            new ParameterPropertyHandlerFixed_1.ParameterPropertyHandlerFixed(this.objectLoader),
            this.parameterPropertyHandlerRange = new ParameterPropertyHandlerRange_1.ParameterPropertyHandlerRange(this.objectLoader, options.typeChecking),
            new ParameterPropertyHandlerLazy_1.ParameterPropertyHandlerLazy(),
        ];
    }
    /**
     * Obtain the values of the given parameter in the context of the given config.
     * @param configRoot The root config resource that we are working in.
     * @param parameter The parameter resource to get the value for.
     * @param configElement Part of the config resource to look for parameter instantiations as predicates.
     * @param genericsContext Context for generic types.
     * @return - The parameter value
     */
    applyParameterValues(configRoot, parameter, configElement, genericsContext) {
        // Make sure that we always have a single value with list elements in it.
        const values = configElement.properties[parameter.value];
        let value;
        if (values.length === 1) {
            value = values[0];
        }
        else if (values.length > 0) {
            if (values.some(subValue => !subValue.list)) {
                throw new ErrorResourcesContext_1.ErrorResourcesContext(`Detected multiple values for parameter ${parameter.value} in ${configElement.value}. RDF lists should be used for defining multiple values.`, {
                    arguments: values,
                });
            }
            value = this.objectLoader.createCompactedResource({
                list: values.flatMap(subValue => subValue.list),
            });
        }
        // Run the value through all applicable parameters property handlers.
        for (const handler of this.parameterPropertyHandlers) {
            if (handler.canHandle(value, configRoot, parameter, configElement, genericsContext)) {
                value = handler.handle(value, configRoot, parameter, configElement, genericsContext);
            }
        }
        return value;
    }
}
exports.ParameterHandler = ParameterHandler;
//# sourceMappingURL=ParameterHandler.js.map
import type { RdfObjectLoader, Resource } from 'rdf-object';
import type { IErrorContext } from '../../util/ErrorResourcesContext';
import { GenericsContext } from '../GenericsContext';
import type { IParameterPropertyHandler } from './IParameterPropertyHandler';
/**
 * If a param range is defined, apply the type and validate the range.
 */
export declare class ParameterPropertyHandlerRange implements IParameterPropertyHandler {
    private readonly objectLoader;
    private readonly typeChecking;
    constructor(objectLoader: RdfObjectLoader, typeChecking: boolean);
    canHandle(value: Resource | undefined, configRoot: Resource, parameter: Resource): boolean;
    handle(value: Resource | undefined, configRoot: Resource, parameter: Resource, configElement: Resource, genericsContext: GenericsContext): Resource | undefined;
    /**
     * Apply the given datatype to the given literal.
     * Checks if the datatype is correct and casts to the correct js type.
     * Will throw an error if the type has an invalid value.
     * Will be ignored if the value is not a literal or the type is not recognized.
     * @param value The value.
     * @param param The parameter.
     * @param genericsContext Context for generic types.
     */
    captureType(value: Resource | undefined, param: Resource, genericsContext: GenericsContext): Resource | undefined;
    /**
     * Check if the given value is of the given type.
     *
     * For valid literals, the `valueRaw` field will be set.
     *
     * @param value The value.
     * @param type The parameter's range.
     * @param genericsContext Context for generic types.
     * @param errorContext The context for error reporting.
     * @return IParamValueConflict A conflict value if there was an error, or undefined if there was no error
     */
    hasValueType(value: Resource | undefined, type: Resource | undefined, errorContext: IErrorContext, genericsContext: GenericsContext): IParamValueConflict | undefined;
    /**
     * Utility function for handling Literals.
     * If the provided value represents a valid Literal, the `valueRaw` field will be set.
     */
    private interpretValueAsType;
    static throwIncorrectTypeError(value: Resource | undefined, parameter: Resource, genericsContext: GenericsContext, conflict: IParamValueConflict): never;
    /**
     * Check if the given value is of the given type.
     * @param value A value.
     * @param type A type.
     * @param genericsContext The current generics context.
     * @param genericTypeInstancesComponentScope
     * @param genericTypeInstances
     * @param errorContext
     */
    hasType(value: Resource, type: Resource, genericsContext: GenericsContext, genericTypeInstancesComponentScope: Resource | undefined, genericTypeInstances: Resource[], errorContext: IErrorContext): IParamValueConflict | undefined;
    static rangeToDisplayString(paramRange: Resource | undefined, genericsContext: GenericsContext): string;
}
/**
 * Represents a conflict between a value and a type.
 */
export interface IParamValueConflict {
    description: string;
    context: IErrorContext;
    causes?: IParamValueConflict[];
}
/**
 * Represents the result of an interpretValuesAsType operation.
 */
export interface ILiteralAsTypeInterpretationResult {
    /**
     * Value is true if a matching literal type was found.
     */
    match: boolean;
    value?: IParamValueConflict;
}

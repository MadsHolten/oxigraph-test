"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConfigPreprocessorComponentMapped = void 0;
const Iris_1 = require("../rdf/Iris");
const ConfigPreprocessorComponent_1 = require("./ConfigPreprocessorComponent");
const ConstructorArgumentsElementMappingHandlerCollectEntries_1 = require("./constructorargumentsmapping/ConstructorArgumentsElementMappingHandlerCollectEntries");
const ConstructorArgumentsElementMappingHandlerElements_1 = require("./constructorargumentsmapping/ConstructorArgumentsElementMappingHandlerElements");
const ConstructorArgumentsElementMappingHandlerFields_1 = require("./constructorargumentsmapping/ConstructorArgumentsElementMappingHandlerFields");
const ConstructorArgumentsElementMappingHandlerKeyValue_1 = require("./constructorargumentsmapping/ConstructorArgumentsElementMappingHandlerKeyValue");
const ConstructorArgumentsElementMappingHandlerList_1 = require("./constructorargumentsmapping/ConstructorArgumentsElementMappingHandlerList");
/**
 * Handles config that refer to a component as type.
 * The component may have parameters that can be applied on the config.
 * Additionally, the component applies a custom constructor arguments mapping for its parameters.
 */
class ConfigPreprocessorComponentMapped extends ConfigPreprocessorComponent_1.ConfigPreprocessorComponent {
    constructor() {
        super(...arguments);
        this.mappingHandlers = [
            new ConstructorArgumentsElementMappingHandlerKeyValue_1.ConstructorArgumentsElementMappingHandlerKeyValue(),
            new ConstructorArgumentsElementMappingHandlerCollectEntries_1.ConstructorArgumentsElementMappingHandlerCollectEntries(this.parameterHandler),
            new ConstructorArgumentsElementMappingHandlerFields_1.ConstructorArgumentsElementMappingHandlerFields(),
            new ConstructorArgumentsElementMappingHandlerElements_1.ConstructorArgumentsElementMappingHandlerElements(),
            new ConstructorArgumentsElementMappingHandlerList_1.ConstructorArgumentsElementMappingHandlerList(),
        ];
    }
    canHandle(config) {
        const handleResponse = super.canHandle(config);
        if (handleResponse && !handleResponse.component.property.constructorArguments) {
            return;
        }
        return handleResponse;
    }
    transformConstructorArguments(config, handleResponse) {
        const constructorArgs = handleResponse.component.property.constructorArguments;
        const genericsContext = this.createGenericsContext(handleResponse, config);
        return this.applyConstructorArgumentsParameters(config, constructorArgs, config, genericsContext);
    }
    applyConstructorArgumentsParameters(configRoot, constructorArgs, configElement, genericsContext) {
        // Check if this constructor args resource can be handled by one of the built-in handlers.
        for (const handler of this.mappingHandlers) {
            if (handler.canHandle(configRoot, constructorArgs, configElement, this, genericsContext)) {
                return handler.handle(configRoot, constructorArgs, configElement, this, genericsContext);
            }
        }
        // Fallback to original constructor args
        return constructorArgs;
    }
    getParameterValue(configRoot, parameter, configElement, rawValue, genericsContext) {
        let valueOut;
        if (parameter.type === 'NamedNode' && parameter.value === Iris_1.IRIS_RDF.subject) {
            valueOut = this.objectLoader.createCompactedResource(`"${configElement.value}"`);
        }
        else if (parameter.type === 'NamedNode' && !parameter.property.fields) {
            valueOut = this.parameterHandler
                .applyParameterValues(configRoot, parameter, configElement, genericsContext);
        }
        else {
            valueOut = this.applyConstructorArgumentsParameters(configRoot, parameter, configElement, genericsContext);
        }
        // If the referenced IRI should become a plain string
        if (rawValue) {
            valueOut = (valueOut === null || valueOut === void 0 ? void 0 : valueOut.list) ?
                this.objectLoader.createCompactedResource({
                    list: valueOut.list.map(valueOutSub => `"${valueOutSub.value}"`),
                }) :
                this.objectLoader.createCompactedResource(`"${valueOut ? valueOut.value : 'undefined'}"`);
        }
        return valueOut;
    }
}
exports.ConfigPreprocessorComponentMapped = ConfigPreprocessorComponentMapped;
//# sourceMappingURL=ConfigPreprocessorComponentMapped.js.map
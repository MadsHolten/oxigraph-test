"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConfigPreprocessorOverride = void 0;
const Iris_1 = require("../rdf/Iris");
const ResourceUtil_1 = require("../rdf/ResourceUtil");
const ErrorResourcesContext_1 = require("../util/ErrorResourcesContext");
/**
 * An {@link IConfigPreprocessor} that handles the overriding of parameters.
 * Values in the given {@link Resource}s will be replaced if any overriding object is found,
 * targeting this resource.
 */
class ConfigPreprocessorOverride {
    constructor(options) {
        this.objectLoader = options.objectLoader;
        this.componentResources = options.componentResources;
        this.logger = options.logger;
    }
    /**
     * Checks if there are any overrides targeting the given resource.
     * @param config - Resource to find overrides for.
     *
     * @returns A key/value object with keys being the properties that have an override.
     */
    canHandle(config) {
        if (!this.overrides) {
            this.overrides = this.createOverrideObjects();
        }
        return this.overrides[config.value];
    }
    /**
     * Override the resource with the stored values.
     * @param config - The resource to override.
     * @param handleResponse - Override values that were found for this resource.
     */
    transform(config, handleResponse) {
        for (const id of Object.keys(config.properties)) {
            const overrideValue = handleResponse[id];
            if (overrideValue) {
                config.properties[id] = [overrideValue];
            }
        }
        return { rawConfig: config, finishTransformation: false };
    }
    /**
     * Clear all cached overrides so they will be calculated again on the next call.
     */
    reset() {
        this.overrides = undefined;
    }
    /**
     * Generates a cache of all overrides found in the object loader.
     * Keys of the object are the identifiers of the resources that need to be modified,
     * values are key/value maps listing all parameters with their new values.
     */
    createOverrideObjects() {
        const overrides = [...this.findOverrideTargets()];
        const chains = this.createOverrideChains(overrides);
        this.validateChains(chains);
        const overrideObjects = {};
        for (const chain of chains) {
            const { target, values } = this.chainToOverrideObject(chain);
            if (Object.keys(values).length > 0) {
                overrideObjects[target] = values;
            }
        }
        return overrideObjects;
    }
    /**
     * Finds all Override resources in the object loader and links them to their target resource.
     */
    *findOverrideTargets() {
        for (const [id, resource] of Object.entries(this.objectLoader.resources)) {
            if (resource.isA(Iris_1.IRIS_OO.Override) && resource.value !== Iris_1.IRIS_OO.Override) {
                const targets = resource.properties[Iris_1.IRIS_OO.overrideInstance];
                if (!targets || targets.length === 0) {
                    this.logger.warn(`Missing overrideInstance for ${id}. This Override will be ignored.`);
                    continue;
                }
                if (targets.length > 1) {
                    throw new ErrorResourcesContext_1.ErrorResourcesContext(`Detected multiple overrideInstance targets for ${id}`, {
                        override: resource,
                    });
                }
                yield { override: resource, target: targets[0] };
            }
        }
    }
    /**
     * Chains all Overrides together if they reference each other.
     * E.g., if the input is a list of Overrides A -> B, B -> C, D -> E,
     * the result wil be [[ A, B, C ], [ D, E ]].
     *
     * @param overrides - All Overrides that have to be combined.
     */
    createOverrideChains(overrides) {
        // Start by creating small chains: from each override to its immediate target
        const overrideChains = Object.fromEntries(overrides.map(({ override, target }) => [override.value, [override, target]]));
        // Then keep combining those smaller chains into bigger chains until they are complete.
        // If there is an override cycle (A -> B -> ... -> A) it will delete itself from the list of chains here.
        let change = true;
        while (change) {
            change = false;
            for (const [id, chain] of Object.entries(overrideChains)) {
                let next = chain[chain.length - 1];
                // If the next part of the chain is found in `overrideChains` we can merge them and remove the tail entry
                while (overrideChains[next.value]) {
                    change = true;
                    const nextChain = overrideChains[next.value];
                    // First element of nextChain will be equal to last element of this chain
                    overrideChains[id].push(...nextChain.slice(1));
                    // In case of a cycle there will be a point where next equals the first element,
                    // at which point it will delete itself.
                    delete overrideChains[next.value];
                    next = chain[chain.length - 1];
                }
                // Reset the loop since we are modifying the object we are iterating over
                if (change) {
                    break;
                }
            }
        }
        return Object.values(overrideChains);
    }
    /**
     * Throws an error in case there are 2 chains targeting the same resource.
     * @param chains - The override chains to check.
     */
    validateChains(chains) {
        const targets = chains.map((chain) => chain[chain.length - 1].value);
        for (let i = 0; i < targets.length; ++i) {
            const duplicateIdx = targets.findIndex((target, idx) => idx > i && target === targets[i]);
            if (duplicateIdx > 0) {
                const target = chains[i][chains[i].length - 1];
                const duplicate1 = chains[i][chains[i].length - 2];
                const duplicate2 = chains[duplicateIdx][chains[duplicateIdx].length - 2];
                throw new ErrorResourcesContext_1.ErrorResourcesContext(`Found multiple Overrides targeting ${targets[i]}`, {
                    target,
                    overrides: [duplicate1, duplicate2],
                });
            }
        }
    }
    /**
     * Merges all Overrides in a chain to create a single override object
     * containing replacement values for all relevant parameters of the final entry in the chain.
     *
     * @param chain - The chain of Overrides, with a normal resource as the last entry in the array.
     */
    chainToOverrideObject(chain) {
        const { target, type } = this.getChainTarget(chain);
        // Apply all overrides sequentially, starting from the one closest to the target.
        // This ensures the most recent override has priority.
        const parameters = this.componentResources[type.value].properties.parameters;
        const mergedOverride = {};
        for (let i = chain.length - 2; i >= 0; --i) {
            const filteredObject = this.filterOverrideObject(chain[i], target, parameters);
            Object.assign(mergedOverride, filteredObject);
        }
        return { target: target.value, values: mergedOverride };
    }
    /**
     * Finds the final target and its type in an override chain.
     * @param chain - The chain to find the target of.
     */
    getChainTarget(chain) {
        const target = chain[chain.length - 1];
        const types = (0, ResourceUtil_1.uniqueTypes)(target, this.componentResources);
        if (!types || types.length === 0) {
            throw new ErrorResourcesContext_1.ErrorResourcesContext(`Missing type for override target ${target.value} of Override ${chain[chain.length - 2].value}`, {
                target,
                override: chain[chain.length - 2],
            });
        }
        if (types.length > 1) {
            throw new ErrorResourcesContext_1.ErrorResourcesContext(`Found multiple types for override target ${target.value} of Override ${chain[chain.length - 2].value}`, {
                target,
                override: chain[chain.length - 2],
            });
        }
        return { target, type: types[0] };
    }
    /**
     * Extracts all relevant parameters of an Override with their corresponding new value.
     * @param override - The Override to apply.
     * @param target - The target resource to apply the Override to.
     * @param parameters - The parameters that are relevant for the target.
     */
    filterOverrideObject(override, target, parameters) {
        const overrideObjects = override.properties[Iris_1.IRIS_OO.overrideParameters];
        if (!overrideObjects || overrideObjects.length === 0) {
            this.logger.warn(`No overrideParameters found for ${override.value}.`);
            return {};
        }
        if (overrideObjects.length > 1) {
            throw new ErrorResourcesContext_1.ErrorResourcesContext(`Detected multiple values for overrideParameters in Override ${override.value}`, {
                override,
            });
        }
        const overrideObject = overrideObjects[0];
        // Only keep the parameters that are known to the type of the target object
        const filteredObject = {};
        for (const parameter of parameters) {
            const overrideValues = overrideObject.properties[parameter.value];
            if (!overrideValues || overrideValues.length === 0) {
                continue;
            }
            if (overrideValues.length > 1) {
                throw new ErrorResourcesContext_1.ErrorResourcesContext(`Detected multiple values for override parameter ${parameter.value} in Override ${override.value}. RDF lists should be used for defining multiple values.`, {
                    arguments: overrideValues,
                    target,
                    override,
                });
            }
            filteredObject[parameter.value] = overrideValues[0];
        }
        return filteredObject;
    }
}
exports.ConfigPreprocessorOverride = ConfigPreprocessorOverride;
//# sourceMappingURL=ConfigPreprocessorOverride.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ModuleStateBuilder = void 0;
const Path = require("path");
const semverGt = require("semver/functions/gt");
const semverMajor = require("semver/functions/major");
const semverValid = require("semver/functions/valid");
// Import syntax only works in Node > 12
const fs = require('fs').promises;
/**
 * Collects the paths to all available modules and components.
 */
class ModuleStateBuilder {
    constructor(logger) {
        this.logger = logger;
    }
    /**
     * Build the module state.
     * @param req The `require` instance.
     * @param mainModulePathIn An optional path to the main module from which the search should start.
     */
    async buildModuleState(req, mainModulePathIn) {
        const mainModulePath = await fs.realpath(mainModulePathIn || this.buildDefaultMainModulePath(req));
        const nodeModuleImportPaths = this.buildNodeModuleImportPaths(mainModulePath);
        const nodeModulePaths = await this.buildNodeModulePaths(nodeModuleImportPaths);
        const packageJsons = await this.buildPackageJsons(nodeModulePaths);
        await this.preprocessPackageJsons(packageJsons);
        const componentModules = await this.buildComponentModules(packageJsons);
        const contexts = await this.buildComponentContexts(packageJsons);
        const importPaths = await this.buildComponentImportPaths(packageJsons);
        return {
            mainModulePath,
            nodeModuleImportPaths,
            nodeModulePaths,
            packageJsons,
            componentModules,
            contexts,
            importPaths,
        };
    }
    /**
     * Determine the default main module path based on the current directory.
     * @param req The `require` instance.
     */
    buildDefaultMainModulePath(req) {
        if (!req.main) {
            throw new Error(`Corrupt Node.js state: Could not find a main module.`);
        }
        for (const nodeModulesPath of req.main.paths) {
            const path = nodeModulesPath.replace(/node_modules$/u, 'package.json');
            try {
                req(path);
                return path.replace(/package.json$/u, '');
            }
            catch (_a) {
                // Do nothing
            }
        }
        throw new Error(`Corrupt Node.js state: None of the main module paths are valid.`);
    }
    /**
     * All paths that need to be considered when handling imports from the current main module path.
     */
    buildNodeModuleImportPaths(mainModulePath) {
        // Since Windows paths can have `/` or `\` depending on the operations done so far
        // it is safest to split on both possible separators.
        const sections = mainModulePath.split(/[/\\]/u);
        const paths = [];
        for (let i = sections.length; i > 1; i--) {
            // Slash is valid on both platforms and keeps results consistent
            paths.push(sections.slice(0, i).join('/'));
        }
        return paths;
    }
    /**
     * Get all currently available node module paths.
     * @param nodeModuleImportPaths The main module paths to start from.
     */
    async buildNodeModulePaths(nodeModuleImportPaths) {
        const nodeModulePaths = [];
        const ignorePaths = {};
        await Promise.all(nodeModuleImportPaths.map(async (path) => this
            .buildNodeModulePathsInner(path, nodeModulePaths, ignorePaths)));
        return nodeModulePaths;
    }
    /**
     * Get all currently available node module paths.
     * @param path The path to start from.
     * @param nodeModulePaths The array of node module paths to append to.
     * @param ignorePaths The paths that should be ignored.
     */
    async buildNodeModulePathsInner(path, nodeModulePaths, ignorePaths) {
        // Make sure we're working with an absolute paths without symlinks
        path = await fs.realpath(path);
        // Avoid infinite loops
        if (ignorePaths[path]) {
            return;
        }
        ignorePaths[path] = true;
        try {
            // Check if the path is a Node module
            if (await this.fileExists(Path.posix.join(path, 'package.json')) ||
                await this.fileExists(Path.posix.join(path, 'node_modules'), false)) {
                nodeModulePaths.push(path);
                // Recursively handle all the Node modules of this valid Node module
                const dependenciesPath = Path.posix.join(path, 'node_modules');
                for (const dependency of await fs.readdir(dependenciesPath)) {
                    // Ignore hidden folders, such as .bin
                    if (!dependency.startsWith('.')) {
                        const dependencyPath = Path.posix.join(dependenciesPath, dependency);
                        if (dependency.startsWith('@')) {
                            // Iterate one level deeper when we find scoped Node modules
                            const scopedModules = await fs.readdir(dependencyPath);
                            await Promise.all(scopedModules.map(async (scopedModule) => this.buildNodeModulePathsInner(Path.posix.join(dependencyPath, scopedModule), nodeModulePaths, ignorePaths)));
                        }
                        else {
                            await this.buildNodeModulePathsInner(dependencyPath, nodeModulePaths, ignorePaths);
                        }
                    }
                }
            }
        }
        catch (_a) {
            // Ignore invalid paths
        }
    }
    async fileExists(path, file = true) {
        try {
            const stat = await fs.stat(path);
            return file ? stat.isFile() : stat.isDirectory();
        }
        catch (_a) {
            return false;
        }
    }
    /**
     * Read the package.json files from all the given Node modules.
     * @param nodeModulePaths An array of node module paths.
     */
    async buildPackageJsons(nodeModulePaths) {
        const packageJsons = {};
        await Promise.all(nodeModulePaths.map(async (modulePath) => {
            const path = Path.posix.join(modulePath, 'package.json');
            if (await this.fileExists(path)) {
                packageJsons[modulePath] = JSON.parse(await fs.readFile(path, 'utf8'));
            }
        }));
        return packageJsons;
    }
    /**
     * Expand `lsd:module` inside package.json's.
     * @param packageJsons Package.json files.
     */
    async preprocessPackageJsons(packageJsons) {
        await Promise.all(Object.entries(packageJsons)
            .map(([packagePath, packageJson]) => ModuleStateBuilder.preprocessPackageJson(packagePath, packageJson)));
    }
    /**
     * Expand `lsd:module` inside the given package.json.
     * @param packagePath Full path to the given package root.
     * @param packageJson Package.json contents.
     * @returns If the package has been preprocessed.
     */
    static async preprocessPackageJson(packagePath, packageJson) {
        if (packageJson['lsd:module'] === true) {
            packageJson['lsd:module'] = `https://linkedsoftwaredependencies.org/bundles/npm/${packageJson.name}`;
            const basePath = packageJson['lsd:basePath'] || '';
            try {
                if ((await fs.stat(Path.posix.join(packagePath, basePath, 'components/components.jsonld'))).isFile()) {
                    packageJson['lsd:components'] = `${basePath}components/components.jsonld`;
                }
            }
            catch (_a) {
                // Ignore errors
            }
            const baseIri = `${packageJson['lsd:module']}/^${semverMajor(packageJson.version)}.0.0/`;
            try {
                if ((await fs.stat(Path.posix.join(packagePath, basePath, 'components/context.jsonld'))).isFile()) {
                    packageJson['lsd:contexts'] = {
                        [`${baseIri}components/context.jsonld`]: `${basePath}components/context.jsonld`,
                    };
                }
            }
            catch (_b) {
                // Ignore errors
            }
            packageJson['lsd:importPaths'] = {};
            try {
                if ((await fs.stat(Path.posix.join(packagePath, basePath, 'components'))).isDirectory()) {
                    packageJson['lsd:importPaths'][`${baseIri}components/`] = `${basePath}components/`;
                }
            }
            catch (_c) {
                // Ignore errors
            }
            try {
                if ((await fs.stat(Path.posix.join(packagePath, basePath, 'config'))).isDirectory()) {
                    packageJson['lsd:importPaths'][`${baseIri}config/`] = `${basePath}config/`;
                }
            }
            catch (_d) {
                // Ignore errors
            }
            return true;
        }
        return false;
    }
    shouldOverrideVersion(version, key, componentVersions, warningSuffix) {
        if (key in componentVersions) {
            if (semverMajor(version) !== semverMajor(componentVersions[key])) {
                this.warn(`Detected multiple incompatible occurrences of '${key}'${warningSuffix}`);
            }
            if (semverGt(version, componentVersions[key])) {
                return true;
            }
            return false;
        }
        return true;
    }
    /**
     * Get all Components.js modules from the given package.json files.
     * @param packageJsons A hash of Node module path to package.json contents.
     * @return A hash of module id (`lsd:module`) to absolute component paths (`lsd:components`).
     */
    async buildComponentModules(packageJsons) {
        const componentModules = {};
        const componentVersions = {};
        for (const [modulePath, pckg] of Object.entries(packageJsons)) {
            const currentModuleUri = pckg['lsd:module'];
            const relativePath = pckg['lsd:components'];
            const version = pckg.version;
            if (version && currentModuleUri && relativePath && semverValid(version)) {
                const absolutePath = Path.posix.join(modulePath, relativePath);
                if (this.shouldOverrideVersion(version, currentModuleUri, componentVersions, `, in '${componentModules[currentModuleUri]}'@${componentVersions[currentModuleUri]} and '${absolutePath}'@${version}`)) {
                    componentModules[currentModuleUri] = absolutePath;
                    componentVersions[currentModuleUri] = version;
                }
            }
        }
        return componentModules;
    }
    /**
     * Get all Components.js contexts from the given package.json files.
     * @param packageJsons A hash of Node module path to package.json contents.
     * @return A hash of context id (key of `lsd:contexts`) to absolute context paths (value of `lsd:contexts`).
     */
    async buildComponentContexts(packageJsons) {
        const componentContexts = {};
        const componentVersions = {};
        await Promise.all(Object.entries(packageJsons).map(async ([modulePath, pckg]) => {
            const contexts = pckg['lsd:contexts'];
            const version = pckg.version;
            if (version && contexts && semverValid(version)) {
                for (const [key, value] of Object.entries(contexts)) {
                    const filePath = Path.posix.join(modulePath, value);
                    const fileContents = JSON.parse(await fs.readFile(filePath, 'utf8'));
                    if (this.shouldOverrideVersion(version, key, componentVersions, ` for version ${componentVersions[key]} and '${filePath}'@${version}`)) {
                        componentContexts[key] = fileContents;
                        componentVersions[key] = version;
                    }
                }
            }
        }));
        return componentContexts;
    }
    /**
     * Get all Components.js modules from the given package.json files.
     * @param packageJsons A hash of Node module path to package.json contents.
     * @return A hash of context id (key of `lsd:importPaths`) to absolute context paths (value of `lsd:importPaths`).
     */
    async buildComponentImportPaths(packageJsons) {
        const componentImportPaths = {};
        const componentVersions = {};
        await Promise.all(Object.entries(packageJsons).map(async ([modulePath, pckg]) => {
            const importPaths = pckg['lsd:importPaths'];
            const version = pckg.version;
            if (version && importPaths && semverValid(version)) {
                for (const [key, value] of Object.entries(importPaths)) {
                    const filePath = Path.posix.join(modulePath, value);
                    if (this.shouldOverrideVersion(version, key, componentVersions, ` for version ${componentVersions[key]} and '${filePath}'@${version}`)) {
                        componentImportPaths[key] = filePath;
                        componentVersions[key] = version;
                        // Crash when the context prefix target does not exist
                        let stat;
                        try {
                            stat = await fs.stat(componentImportPaths[key]);
                        }
                        catch (_a) {
                            throw new Error(`Error while parsing import path '${key}' in ${modulePath}: ${componentImportPaths[key]} does not exist.`);
                        }
                        if (!stat.isDirectory()) {
                            throw new Error(`Error while parsing import path '${key}' in ${modulePath}: ${componentImportPaths[key]} is not a directory.`);
                        }
                    }
                }
            }
        }));
        return componentImportPaths;
    }
    warn(message) {
        if (this.logger) {
            this.logger.warn(message);
        }
    }
}
exports.ModuleStateBuilder = ModuleStateBuilder;
//# sourceMappingURL=ModuleStateBuilder.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ComponentRegistry = void 0;
const RdfParser_1 = require("../rdf/RdfParser");
/**
 * Accepts component registrations and modules containing zero or more components.
 *
 * This class will populate the given {@link componentResources} hash.
 * Before the {@link componentResources} hash is used anywhere else,
 * the {@link ComponentRegistryFinalizer} should be invoked on this
 * to make sure that all modules have properly been registered.
 */
class ComponentRegistry {
    constructor(options) {
        this.moduleState = options.moduleState;
        this.objectLoader = options.objectLoader;
        this.logger = options.logger;
        this.componentResources = options.componentResources;
        this.skipContextValidation = options.skipContextValidation;
    }
    /**
     * Register all modules and their components that are available in the {@link IModuleState}.
     *
     * Effectively, this will load in all components that are available in the main package and its dependencies.
     */
    async registerAvailableModules() {
        await Promise.all(Object.values(this.moduleState.componentModules)
            .map((moduleResourceUrl) => this.registerModule(moduleResourceUrl)));
    }
    /**
     * Register a module based on a config URL or local file path.
     * @param urlOrPath An RDF document URL or local file path.
     */
    async registerModule(urlOrPath) {
        const data = await RdfParser_1.RdfParser.fetchFileOrUrl(urlOrPath);
        await this.registerModuleStream(new RdfParser_1.RdfParser().parse(data, {
            path: urlOrPath,
            contexts: this.moduleState.contexts,
            importPaths: this.moduleState.importPaths,
            logger: this.logger,
            skipContextValidation: this.skipContextValidation,
        }));
    }
    /**
     * Register a module stream.
     * @param stream A triple stream containing a module.
     */
    async registerModuleStream(stream) {
        await this.objectLoader.import(stream);
    }
    /**
     * Register a module resource.
     * @param moduleResource A module resource.
     */
    registerModuleResource(moduleResource) {
        if (moduleResource.property.components) {
            for (const component of moduleResource.properties.components) {
                component.properties.module.push(moduleResource);
                this.registerComponent(component);
            }
        }
        else {
            this.logger.debug(`Registered a module ${moduleResource.value} without components.`);
        }
    }
    /**
     * Register a component resource.
     * @param component A component resource.
     */
    registerComponent(component) {
        this.requireValidComponent(component);
        if (component.term.termType !== 'NamedNode') {
            this.logger.warn(`Registered a component that is identified by a ${component.term.termType} (${component.value}) instead of an IRI identifier.`);
        }
        this.componentResources[component.value] = component;
    }
    /**
     * Check if the given resource is a valid component.
     * A valid component is either an abstract class, a class, or an instance.
     * @param componentResource A resource.
     * @returns {boolean} If the resource is a valid component.
     */
    isValidComponent(componentResource) {
        return componentResource.isA('AbstractClass') ||
            componentResource.isA('Class') ||
            componentResource.isA('Instance');
    }
    /**
     * Require that the given resource is a valid component, otherwise and error is thrown.
     * @param componentResource A resource.
     * @param referencingComponent The optional component referencing the given component.
     */
    requireValidComponent(componentResource, referencingComponent) {
        if (!this.isValidComponent(componentResource)) {
            throw new Error(`Resource ${componentResource.value} is not a valid component, either it is not defined, has no type, or is incorrectly referenced${referencingComponent ? ` by ${referencingComponent.value}` : ''}.`);
        }
    }
}
exports.ComponentRegistry = ComponentRegistry;
//# sourceMappingURL=ComponentRegistry.js.map
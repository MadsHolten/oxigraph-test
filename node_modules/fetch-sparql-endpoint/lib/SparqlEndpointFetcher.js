"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SparqlEndpointFetcher = void 0;
require("cross-fetch/polyfill");
const abort_controller_1 = require("abort-controller");
const sparqljs_1 = require("sparqljs");
const sparqljson_parse_1 = require("sparqljson-parse");
const sparqlxml_parse_1 = require("sparqlxml-parse");
const stringifyStream = require("stream-to-string");
const readable_web_to_node_stream_1 = require("readable-web-to-node-stream");
// tslint:disable:no-var-requires
const n3 = require('n3');
const isStream = require('is-stream');
/**
 * A SparqlEndpointFetcher can send queries to SPARQL endpoints,
 * and retrieve and parse the results.
 */
class SparqlEndpointFetcher {
    constructor(args) {
        args = args || {};
        this.method = args.method || 'POST';
        this.additionalUrlParams = args.additionalUrlParams || new URLSearchParams();
        this.fetchCb = args.fetch;
        this.sparqlJsonParser = new sparqljson_parse_1.SparqlJsonParser(args);
        this.sparqlXmlParser = new sparqlxml_parse_1.SparqlXmlParser(args);
        this.sparqlParsers = {
            [SparqlEndpointFetcher.CONTENTTYPE_SPARQL_JSON]: {
                parseBooleanStream: (sparqlResponseStream) => this.sparqlJsonParser.parseJsonBooleanStream(sparqlResponseStream),
                parseResultsStream: (sparqlResponseStream) => this.sparqlJsonParser.parseJsonResultsStream(sparqlResponseStream),
            },
            [SparqlEndpointFetcher.CONTENTTYPE_SPARQL_XML]: {
                parseBooleanStream: (sparqlResponseStream) => this.sparqlXmlParser.parseXmlBooleanStream(sparqlResponseStream),
                parseResultsStream: (sparqlResponseStream) => this.sparqlXmlParser.parseXmlResultsStream(sparqlResponseStream),
            },
        };
    }
    /**
     * Get the query type of the given query.
     *
     * This will parse the query and thrown an exception on syntax errors.
     *
     * @param {string} query A query.
     * @return {"SELECT" | "ASK" | "CONSTRUCT" | "UNKNOWN"} The query type.
     */
    getQueryType(query) {
        const parsedQuery = new sparqljs_1.Parser().parse(query);
        return parsedQuery.type === 'query'
            ? (parsedQuery.queryType === 'DESCRIBE' ? 'CONSTRUCT' : parsedQuery.queryType) : "UNKNOWN";
    }
    /**
     * Get the query type of the given update query.
     *
     * This will parse the update query and thrown an exception on syntax errors.
     *
     * @param {string} query An update query.
     * @return {'UNKNOWN' | UpdateTypes} The included update operations.
     */
    getUpdateTypes(query) {
        const parsedQuery = new sparqljs_1.Parser().parse(query);
        if (parsedQuery.type === 'update') {
            const operations = {};
            for (const update of parsedQuery.updates) {
                if ('type' in update) {
                    operations[update.type] = true;
                }
                else {
                    operations[update.updateType] = true;
                }
            }
            return operations;
        }
        else {
            return "UNKNOWN";
        }
        ;
    }
    ;
    /**
     * Send a SELECT query to the given endpoint URL and return the resulting bindings stream.
     * @see IBindings
     * @param {string} endpoint A SPARQL endpoint URL. (without the `?query=` suffix).
     * @param {string} query    A SPARQL query string.
     * @return {Promise<NodeJS.ReadableStream>} A stream of {@link IBindings}.
     */
    async fetchBindings(endpoint, query) {
        const [contentType, responseStream] = await this
            .fetchRawStream(endpoint, query, SparqlEndpointFetcher.CONTENTTYPE_SPARQL);
        const parser = this.sparqlParsers[contentType];
        if (!parser) {
            throw new Error('Unknown SPARQL results content type: ' + contentType);
        }
        return parser.parseResultsStream(responseStream);
    }
    /**
     * Send an ASK query to the given endpoint URL and return a promise resolving to the boolean answer.
     * @param {string} endpoint A SPARQL endpoint URL. (without the `?query=` suffix).
     * @param {string} query    A SPARQL query string.
     * @return {Promise<boolean>} A boolean resolving to the answer.
     */
    async fetchAsk(endpoint, query) {
        const [contentType, responseStream] = await this
            .fetchRawStream(endpoint, query, SparqlEndpointFetcher.CONTENTTYPE_SPARQL);
        const parser = this.sparqlParsers[contentType];
        if (!parser) {
            throw new Error('Unknown SPARQL results content type: ' + contentType);
        }
        return parser.parseBooleanStream(responseStream);
    }
    /**
     * Send a CONSTRUCT/DESCRIBE query to the given endpoint URL and return the resulting triple stream.
     * @param {string} endpoint A SPARQL endpoint URL. (without the `?query=` suffix).
     * @param {string} query    A SPARQL query string.
     * @return {Promise<Stream>} A stream of triples.
     */
    async fetchTriples(endpoint, query) {
        const rawStream = (await this.fetchRawStream(endpoint, query, SparqlEndpointFetcher.CONTENTTYPE_TURTLE))[1];
        return rawStream.pipe(new n3.StreamParser({ format: SparqlEndpointFetcher.CONTENTTYPE_TURTLE }));
    }
    /**
     * Send an update query to the given endpoint URL using POST.
     *
     * @param {string} endpoint     A SPARQL endpoint URL. (without the `?query=` suffix).
     * @param {string} query        A SPARQL query string.
     */
    async fetchUpdate(endpoint, query) {
        const abortController = new abort_controller_1.default();
        const init = {
            method: 'POST',
            headers: {
                'content-type': 'application/sparql-update',
            },
            body: query,
            signal: abortController.signal,
        };
        await this.handleFetchCall(endpoint, init, { ignoreBody: true });
        abortController.abort();
    }
    /**
     * Send a query to the given endpoint URL and return the resulting stream.
     *
     * This will only accept responses with the application/sparql-results+json content type.
     *
     * @param {string} endpoint     A SPARQL endpoint URL. (without the `?query=` suffix).
     * @param {string} query        A SPARQL query string.
     * @param {string} acceptHeader The HTTP accept to use.
     * @return {Promise<[string, NodeJS.ReadableStream]>} The content type and SPARQL endpoint response stream.
     */
    async fetchRawStream(endpoint, query, acceptHeader) {
        let url = this.method === 'POST' ? endpoint : endpoint + '?query=' + encodeURIComponent(query);
        // Initiate request
        const headers = new Headers();
        let body;
        headers.append('Accept', acceptHeader);
        if (this.method === 'POST') {
            headers.append('Content-Type', 'application/x-www-form-urlencoded');
            body = new URLSearchParams();
            body.set('query', query);
            this.additionalUrlParams.forEach((value, key) => {
                body.set(key, value);
            });
            headers.append('Content-Length', body.toString().length.toString());
        }
        else if (this.additionalUrlParams.toString() !== '') {
            url += `&${this.additionalUrlParams.toString()}`;
        }
        return this.handleFetchCall(url, { headers, method: this.method, body });
    }
    /**
     * Helper function to generalize internal fetch calls.
     *
     * @param {string}      url     The URL to call.
     * @param {RequestInit} init    Options to pass along to the fetch call.
     * @param {any}         options Other specific fetch options.
     * @return {Promise<[string, NodeJS.ReadableStream]>} The content type and SPARQL endpoint response stream.
     */
    async handleFetchCall(url, init, options = {}) {
        const httpResponse = await (this.fetchCb || fetch)(url, init);
        let responseStream;
        // Handle response body
        if (!options.ignoreBody) {
            // Wrap WhatWG readable stream into a Node.js readable stream
            // If the body already is a Node.js stream (in the case of node-fetch), don't do explicit conversion.
            responseStream = isStream(httpResponse.body)
                ? httpResponse.body : new readable_web_to_node_stream_1.ReadableWebToNodeStream(httpResponse.body);
        }
        // Determine the content type and emit it to the stream
        let contentType = httpResponse.headers.get('Content-Type') || '';
        if (contentType.indexOf(';') > 0) {
            contentType = contentType.substr(0, contentType.indexOf(';'));
        }
        // Emit an error if the server returned an invalid response
        if (!httpResponse.ok) {
            const simpleUrl = /^[^?]*/u.exec(url)[0];
            let bodyString = 'empty response';
            if (responseStream) {
                bodyString = await stringifyStream(responseStream);
            }
            throw new Error(`Invalid SPARQL endpoint response from ${simpleUrl} (HTTP status ${httpResponse.status}):\n${bodyString}`);
        }
        return [contentType, responseStream];
    }
}
exports.SparqlEndpointFetcher = SparqlEndpointFetcher;
SparqlEndpointFetcher.CONTENTTYPE_SPARQL_JSON = 'application/sparql-results+json';
SparqlEndpointFetcher.CONTENTTYPE_SPARQL_XML = 'application/sparql-results+xml';
SparqlEndpointFetcher.CONTENTTYPE_SPARQL = `${SparqlEndpointFetcher.CONTENTTYPE_SPARQL_JSON};q=1.0,${SparqlEndpointFetcher.CONTENTTYPE_SPARQL_XML};q=0.7`;
SparqlEndpointFetcher.CONTENTTYPE_TURTLE = 'text/turtle';
//# sourceMappingURL=SparqlEndpointFetcher.js.map
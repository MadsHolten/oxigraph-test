"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GroupsState = void 0;
const bindings_factory_1 = require("@comunica/bindings-factory");
const rdf_data_factory_1 = require("rdf-data-factory");
const sparqlee_1 = require("sparqlee");
const DF = new rdf_data_factory_1.DataFactory();
const BF = new bindings_factory_1.BindingsFactory();
/**
 * A state manager for the groups constructed by consuming the bindings-stream.
 */
class GroupsState {
    constructor(hashFunction, pattern, sparqleeConfig) {
        this.hashFunction = hashFunction;
        this.pattern = pattern;
        this.sparqleeConfig = sparqleeConfig;
        this.groups = new Map();
        this.groupsInitializer = new Map();
        this.groupVariables = new Set(this.pattern.variables.map(x => x.value));
        this.distinctHashes = pattern.aggregates.some(({ distinct }) => distinct) ?
            new Map() :
            null;
        this.waitCounter = 1;
        this.resultHasBeenCalled = false;
    }
    /**
     * - Consumes a stream binding
     * - Find the corresponding group and create one if need be
     * - Feeds the binding to the group's aggregators
     *
     * @param {Bindings} bindings - The Bindings to consume
     */
    consumeBindings(bindings) {
        const check = this.resultCheck();
        if (check) {
            return check;
        }
        // We increment the counter and decrement him when put action is performed.
        this.waitCounter++;
        // Select the bindings on which we group
        const grouper = bindings
            .filter((_, variable) => this.groupVariables.has(variable.value));
        const groupHash = this.hashBindings(grouper);
        // First member of group -> create new group
        let groupInitializer = this.groupsInitializer.get(groupHash);
        let res;
        if (!groupInitializer) {
            // Initialize state for all aggregators for new group
            groupInitializer = (async () => {
                const aggregators = {};
                await Promise.all(this.pattern.aggregates.map(async (aggregate) => {
                    const key = aggregate.variable.value;
                    aggregators[key] = new sparqlee_1.AsyncAggregateEvaluator(aggregate, this.sparqleeConfig);
                    await aggregators[key].put(bindings);
                }));
                if (this.distinctHashes) {
                    const bindingsHash = this.hashBindings(bindings);
                    this.distinctHashes.set(groupHash, new Set([bindingsHash]));
                }
                const group = { aggregators, bindings: grouper };
                this.groups.set(groupHash, group);
                this.subtractWaitCounterAndCollect();
                return group;
            })();
            this.groupsInitializer.set(groupHash, groupInitializer);
            res = groupInitializer;
        }
        else {
            const groupInitializerDefined = groupInitializer;
            res = (async () => {
                const group = await groupInitializerDefined;
                await Promise.all(this.pattern.aggregates.map(async (aggregate) => {
                    // If distinct, check first whether we have inserted these values already
                    if (aggregate.distinct) {
                        const hash = this.hashBindings(bindings);
                        if (this.distinctHashes.get(groupHash).has(hash)) {
                            return;
                        }
                        this.distinctHashes.get(groupHash).add(hash);
                    }
                    const variable = aggregate.variable.value;
                    await group.aggregators[variable].put(bindings);
                }));
            })().then(() => {
                this.subtractWaitCounterAndCollect();
            });
        }
        return res;
    }
    subtractWaitCounterAndCollect() {
        if (--this.waitCounter === 0) {
            this.handleResultCollection();
        }
    }
    handleResultCollection() {
        // Collect groups
        let rows = [...this.groups].map(([_, group]) => {
            const { bindings: groupBindings, aggregators } = group;
            // Collect aggregator bindings
            // If the aggregate errorred, the result will be undefined
            let returnBindings = groupBindings;
            for (const variable in aggregators) {
                const value = aggregators[variable].result();
                if (value) {
                    // Filter undefined
                    returnBindings = returnBindings.set(DF.variable(variable), value);
                }
            }
            // Merge grouping bindings and aggregator bindings
            return returnBindings;
        });
        // Case: No Input
        // Some aggregators still define an output on the empty input
        // Result is a single Bindings
        if (rows.length === 0 && this.groupVariables.size === 0) {
            const single = [];
            for (const aggregate of this.pattern.aggregates) {
                const key = aggregate.variable;
                const value = sparqlee_1.AsyncAggregateEvaluator.emptyValue(aggregate);
                if (value !== undefined) {
                    single.push([key, value]);
                }
            }
            rows = [BF.bindings(single)];
        }
        this.waitResolver(rows);
    }
    resultCheck() {
        if (this.resultHasBeenCalled) {
            return Promise.reject(new Error('Calling any function after calling collectResult is invalid.'));
        }
    }
    /**
     * Collect the result of the final state. This returns a Bindings per group,
     * and a (possibly empty) Bindings in case no Bindings have been consumed yet.
     * You can only call this method once, after calling this method,
     * calling any function on this will result in an error being thrown.
     */
    collectResults() {
        const check = this.resultCheck();
        if (check) {
            return check;
        }
        this.resultHasBeenCalled = true;
        const res = new Promise(resolve => {
            this.waitResolver = resolve;
        });
        this.subtractWaitCounterAndCollect();
        return res;
    }
    /**
     * @param {Bindings} bindings - Bindings to hash
     */
    hashBindings(bindings) {
        return this.hashFunction(bindings);
    }
}
exports.GroupsState = GroupsState;
//# sourceMappingURL=GroupsState.js.map
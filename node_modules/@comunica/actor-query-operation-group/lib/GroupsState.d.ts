import type { HashFunction } from '@comunica/bus-hash-bindings';
import type { Bindings } from '@comunica/types';
import type { Algebra } from 'sparqlalgebrajs';
import { AsyncAggregateEvaluator } from 'sparqlee';
import type { AsyncEvaluatorConfig } from 'sparqlee';
/**
 * A simple type alias for strings that should be hashes of Bindings
 */
export declare type BindingsHash = string;
/**
 * A state container for a single group
 *
 * @property {Bindings} bindings - The binding entries on which we group
 */
export interface IGroup {
    bindings: Bindings;
    aggregators: Record<string, AsyncAggregateEvaluator>;
}
/**
 * A state manager for the groups constructed by consuming the bindings-stream.
 */
export declare class GroupsState {
    private readonly hashFunction;
    private readonly pattern;
    private readonly sparqleeConfig;
    private readonly groups;
    private readonly groupsInitializer;
    private readonly groupVariables;
    private readonly distinctHashes;
    private waitCounter;
    private waitResolver;
    private resultHasBeenCalled;
    constructor(hashFunction: HashFunction, pattern: Algebra.Group, sparqleeConfig: AsyncEvaluatorConfig);
    /**
     * - Consumes a stream binding
     * - Find the corresponding group and create one if need be
     * - Feeds the binding to the group's aggregators
     *
     * @param {Bindings} bindings - The Bindings to consume
     */
    consumeBindings(bindings: Bindings): Promise<void>;
    private subtractWaitCounterAndCollect;
    private handleResultCollection;
    private resultCheck;
    /**
     * Collect the result of the final state. This returns a Bindings per group,
     * and a (possibly empty) Bindings in case no Bindings have been consumed yet.
     * You can only call this method once, after calling this method,
     * calling any function on this will result in an error being thrown.
     */
    collectResults(): Promise<Bindings[]>;
    /**
     * @param {Bindings} bindings - Bindings to hash
     */
    private hashBindings;
}

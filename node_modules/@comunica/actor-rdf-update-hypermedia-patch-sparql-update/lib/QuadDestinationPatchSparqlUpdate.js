"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.QuadDestinationPatchSparqlUpdate = void 0;
const bus_http_1 = require("@comunica/bus-http");
const bus_rdf_update_quads_1 = require("@comunica/bus-rdf-update-quads");
const cross_fetch_1 = require("cross-fetch");
const rdf_string_ttl_1 = require("rdf-string-ttl");
const readable_stream_1 = require("readable-stream");
/**
 * A quad destination that represents a resource that is patchable via SPARQL Update.
 */
class QuadDestinationPatchSparqlUpdate {
    constructor(url, context, mediatorHttp) {
        this.url = url;
        this.context = context;
        this.mediatorHttp = mediatorHttp;
    }
    insert(quads) {
        return this.wrapSparqlUpdateRequest('INSERT', quads);
    }
    async delete(quads) {
        return this.wrapSparqlUpdateRequest('DELETE', quads);
    }
    async wrapSparqlUpdateRequest(type, quads) {
        // Wrap triples in DATA block
        const dataWrapped = quads
            .map((quad) => {
            let stringQuad = `${(0, rdf_string_ttl_1.termToString)(quad.subject)} ${(0, rdf_string_ttl_1.termToString)(quad.predicate)} ${(0, rdf_string_ttl_1.termToString)(quad.object)} .`;
            if (quad.graph.termType !== 'DefaultGraph') {
                stringQuad = `  GRAPH ${(0, rdf_string_ttl_1.termToString)(quad.graph)} { ${stringQuad} }\n`;
            }
            else {
                stringQuad = `  ${stringQuad}\n`;
            }
            return stringQuad;
        })
            .prepend([`${type} DATA {\n`])
            .append(['}']);
        const readable = new readable_stream_1.Readable();
        readable._read = () => true;
        dataWrapped.on('data', (quad) => readable.push(quad));
        dataWrapped.on('end', () => readable.push(null));
        // Send data in PUT request
        const headers = new cross_fetch_1.Headers({ 'content-type': 'application/sparql-update' });
        const httpResponse = await this.mediatorHttp.mediate({
            context: this.context,
            init: {
                headers,
                method: 'PATCH',
                body: bus_http_1.ActorHttp.toWebReadableStream(readable),
            },
            input: this.url,
        });
        await (0, bus_rdf_update_quads_1.validateHttpResponse)(this.url, httpResponse);
    }
    async deleteGraphs(graphs, requireExistence, dropGraphs) {
        throw new Error(`Patch-based SPARQL Update destinations don't support named graphs`);
    }
    async createGraphs(graphs, requireNonExistence) {
        throw new Error(`Patch-based SPARQL Update destinations don't support named graphs`);
    }
}
exports.QuadDestinationPatchSparqlUpdate = QuadDestinationPatchSparqlUpdate;
//# sourceMappingURL=QuadDestinationPatchSparqlUpdate.js.map
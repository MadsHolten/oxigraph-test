import type { MediatorRdfJoinSelectivity } from '@comunica/bus-rdf-join-selectivity';
import type { IAction, IActorArgs, Mediate } from '@comunica/core';
import { Actor } from '@comunica/core';
import type { IMediatorTypeJoinCoefficients } from '@comunica/mediatortype-join-coefficients';
import type { IQueryOperationResultBindings, MetadataBindings, Bindings, IActionContext, IJoinEntry, IJoinEntryWithMetadata } from '@comunica/types';
import type * as RDF from '@rdfjs/types';
/**
 * A comunica actor for joining 2 binding streams.
 *
 * Actor types:
 * * Input:  IActionRdfJoin:                The streams that need to be joined.
 * * Test:   IMediatorTypeJoinCoefficients: Join coefficients.
 * * Output: IActorRdfJoinOutput:           The resulting joined stream.
 *
 * @see IActionRdfJoin
 * @see IActorQueryOperationOutput
 */
export declare abstract class ActorRdfJoin extends Actor<IActionRdfJoin, IMediatorTypeJoinCoefficients, IQueryOperationResultBindings> {
    readonly mediatorJoinSelectivity: MediatorRdfJoinSelectivity;
    /**
     * If this actor will be logged in the debugger and physical query plan logger
     */
    includeInLogs: boolean;
    readonly logicalType: LogicalJoinType;
    readonly physicalName: string;
    /**
     * Can be used by subclasses to indicate the max or min number of streams that can be joined.
     * 0 for infinity.
     * By default, this indicates the max number, but can be inverted by setting limitEntriesMin to true.
     */
    protected readonly limitEntries: number;
    /**
     * If true, the limitEntries field is a lower limit,
     * otherwise, it is an upper limit.
     */
    protected readonly limitEntriesMin: boolean;
    /**
     * If this actor can handle undefs in the bindings.
     */
    protected readonly canHandleUndefs: boolean;
    /**
     * @param args - @defaultNested {<default_bus> a <cc:components/Bus.jsonld#Bus>} bus
     * @param options - Actor-specific join options.
     */
    constructor(args: IActorRdfJoinArgs, options: IActorRdfJoinInternalOptions);
    /**
     * Creates a hash of the given bindings by concatenating the results of the given variables.
     * This function will not sort the variables and expects them to be in the same order for every call.
     * @param {Bindings} bindings
     * @param {string[]} variables
     * @returns {string}
     */
    static hash(bindings: Bindings, variables: RDF.Variable[]): string;
    /**
     * Returns an array containing all the variable names that occur in all bindings streams.
     * @param {MetadataBindings[]} metadatas An array of optional metadata objects for the entries.
     * @returns {string[]}
     */
    static overlappingVariables(metadatas: MetadataBindings[]): RDF.Variable[];
    /**
     * Returns the variables that will occur in the joined bindings.
     * @param {MetadataBindings[]} metadatas An array of metadata objects for the entries.
     * @returns {string[]}
     */
    static joinVariables(metadatas: MetadataBindings[]): RDF.Variable[];
    /**
     * Returns the result of joining bindings, or `null` if no join is possible.
     * @param {Bindings[]} bindings
     * @returns {Bindings}
     */
    static joinBindings(...bindings: Bindings[]): Bindings | null;
    /**
     * Get the estimated number of items from the given metadata.
     * @param {Record<string, any>} metadata A metadata object.
     * @return {number} The estimated number of items, or `Infinity` if cardinality is falsy.
     */
    static getCardinality(metadata: MetadataBindings): RDF.QueryResultCardinality;
    /**
     * Obtain the metadata from all given join entries.
     * @param entries Join entries.
     */
    static getMetadatas(entries: IJoinEntry[]): Promise<MetadataBindings[]>;
    /**
     * Obtain the join entries witt metadata from all given join entries.
     * @param entries Join entries.
     */
    static getEntriesWithMetadatas(entries: IJoinEntry[]): Promise<IJoinEntryWithMetadata[]>;
    /**
     * Calculate the time to initiate a request for the given metadata entries.
     * @param metadatas An array of checked metadata.
     */
    static getRequestInitialTimes(metadatas: MetadataBindings[]): number[];
    /**
     * Calculate the time to receive a single item for the given metadata entries.
     * @param metadatas An array of checked metadata.
     */
    static getRequestItemTimes(metadatas: MetadataBindings[]): number[];
    /**
     * Helper function to create a new metadata object for the join result.
     * For required metadata entries that are not provided, sane defaults are calculated.
     * @param entries Join entries.
     * @param metadatas Metadata of the join entries.
     * @param context The action context.
     * @param partialMetadata Partial metadata entries.
     */
    constructResultMetadata(entries: IJoinEntry[], metadatas: MetadataBindings[], context: IActionContext, partialMetadata?: Partial<MetadataBindings>): Promise<MetadataBindings>;
    /**
     * Default test function for join actors.
     * Checks whether all iterators have metadata.
     * If yes: call the abstract getIterations method, if not: return Infinity.
     * @param {IActionRdfJoin} action The input action containing the relevant iterators
     * @returns {Promise<IMediatorTypeJoinCoefficients>} The join coefficients.
     */
    test(action: IActionRdfJoin): Promise<IMediatorTypeJoinCoefficients>;
    /**
     * Returns default input for 0 or 1 entries. Calls the getOutput function otherwise
     * @param {IActionRdfJoin} action
     * @returns {Promise<IActorQueryOperationOutput>}
     */
    run(action: IActionRdfJoin): Promise<IQueryOperationResultBindings>;
    /**
     * Returns the resulting output for joining the given entries.
     * This is called after removing the trivial cases in run.
     * @param {IActionRdfJoin} action
     * @returns {Promise<IActorRdfJoinOutputInner>}
     */
    protected abstract getOutput(action: IActionRdfJoin): Promise<IActorRdfJoinOutputInner>;
    /**
     * Calculate the join coefficients.
     * @param {IActionRdfJoin} action Join action
     * @param metadatas Array of resolved metadata objects.
     * @returns {IMediatorTypeJoinCoefficients} The join coefficient estimates.
     */
    protected abstract getJoinCoefficients(action: IActionRdfJoin, metadatas: MetadataBindings[]): Promise<IMediatorTypeJoinCoefficients>;
}
export interface IActorRdfJoinArgs extends IActorArgs<IActionRdfJoin, IMediatorTypeJoinCoefficients, IQueryOperationResultBindings> {
    mediatorJoinSelectivity: MediatorRdfJoinSelectivity;
}
export interface IActorRdfJoinInternalOptions {
    /**
     * The logical join type this actor can handle.
     */
    logicalType: LogicalJoinType;
    /**
     * The physical name of join operation this actor implements.
     * This is used for debug and query plan logs.
     */
    physicalName: string;
    /**
     * Can be used by subclasses to indicate the max or min number of streams that can be joined.
     * 0 for infinity.
     * By default, this indicates the max number, but can be inverted by setting limitEntriesMin to true.
     */
    limitEntries?: number;
    /**
     * If true, the limitEntries field is a lower limit,
     * otherwise, it is an upper limit.
     * Defaults to false.
     */
    limitEntriesMin?: boolean;
    /**
     * If this actor can handle undefs in the bindings.
     * Defaults to false.
     */
    canHandleUndefs?: boolean;
}
/**
 * Represents a logical join type.
 */
export declare type LogicalJoinType = 'inner' | 'optional' | 'minus';
export interface IActionRdfJoin extends IAction {
    /**
     * The logical join type.
     */
    type: LogicalJoinType;
    /**
     * The array of streams to join.
     */
    entries: IJoinEntry[];
}
export interface IActorRdfJoinOutputInner {
    /**
     * The join result.
     */
    result: IQueryOperationResultBindings;
    /**
     * Optional metadata that will be included as metadata within the physical query plan output.
     */
    physicalPlanMetadata?: any;
}
export declare type MediatorRdfJoin = Mediate<IActionRdfJoin, IQueryOperationResultBindings, IMediatorTypeJoinCoefficients>;

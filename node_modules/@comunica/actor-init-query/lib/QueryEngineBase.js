"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.QueryEngineBase = void 0;
const bus_query_operation_1 = require("@comunica/bus-query-operation");
const context_entries_1 = require("@comunica/context-entries");
const core_1 = require("@comunica/core");
const MemoryPhysicalQueryPlanLogger_1 = require("./MemoryPhysicalQueryPlanLogger");
/**
 * Base implementation of a Comunica query engine.
 */
class QueryEngineBase {
    constructor(actorInitQuery) {
        this.actorInitQuery = actorInitQuery;
    }
    async queryBindings(query, context) {
        return this.queryOfType(query, context, 'bindings');
    }
    async queryQuads(query, context) {
        return this.queryOfType(query, context, 'quads');
    }
    async queryBoolean(query, context) {
        return this.queryOfType(query, context, 'boolean');
    }
    async queryVoid(query, context) {
        return this.queryOfType(query, context, 'void');
    }
    async queryOfType(query, context, expectedType) {
        const result = await this.query(query, context);
        if (result.resultType === expectedType) {
            return result.execute();
        }
        throw new Error(`Query result type '${expectedType}' was expected, while '${result.resultType}' was found.`);
    }
    /**
     * Evaluate the given query
     * @param query A query string or algebra.
     * @param context An optional query context.
     * @return {Promise<QueryType>} A promise that resolves to the query output.
     */
    async query(query, context) {
        const output = await this.queryOrExplain(query, context);
        if ('explain' in output) {
            throw new Error(`Tried to explain a query when in query-only mode`);
        }
        return output;
    }
    /**
     * Explain the given query
     * @param {string | Algebra.Operation} query A query string or algebra.
     * @param context An optional query context.
     * @param explainMode The explain mode.
     * @return {Promise<QueryType | IQueryExplained>} A promise that resolves to
     *                                                               the query output or explanation.
     */
    async explain(query, context, explainMode) {
        context.explain = explainMode;
        const output = await this.queryOrExplain(query, context);
        return output;
    }
    /**
     * Evaluate or explain the given query
     * @param {string | Algebra.Operation} query A query string or algebra.
     * @param context An optional query context.
     * @return {Promise<QueryType | IQueryExplained>} A promise that resolves to
     *                                                               the query output or explanation.
     */
    async queryOrExplain(query, context) {
        context = context || {};
        // Expand shortcuts
        for (const key in context) {
            if (this.actorInitQuery.contextKeyShortcuts[key]) {
                context[this.actorInitQuery.contextKeyShortcuts[key]] = context[key];
                delete context[key];
            }
        }
        // Prepare context
        let actionContext = new core_1.ActionContext(context);
        let queryFormat = { language: 'sparql', version: '1.1' };
        if (actionContext.has(context_entries_1.KeysInitQuery.queryFormat)) {
            queryFormat = actionContext.get(context_entries_1.KeysInitQuery.queryFormat);
            actionContext = actionContext.delete(context_entries_1.KeysInitQuery.queryFormat);
            if (queryFormat.language === 'graphql') {
                actionContext = actionContext.setDefault(context_entries_1.KeysInitQuery.graphqlSingularizeVariables, {});
            }
        }
        const baseIRI = actionContext.get(context_entries_1.KeysInitQuery.baseIRI);
        actionContext = actionContext
            .setDefault(context_entries_1.KeysInitQuery.queryTimestamp, new Date())
            .setDefault(context_entries_1.KeysRdfResolveQuadPattern.sourceIds, new Map())
            // Set the default logger if none is provided
            .setDefault(context_entries_1.KeysCore.log, this.actorInitQuery.logger);
        // Pre-processing the context
        actionContext = (await this.actorInitQuery.mediatorContextPreprocess.mediate({ context: actionContext })).context;
        // Determine explain mode
        const explainMode = actionContext.get(context_entries_1.KeysInitQuery.explain);
        // Parse query
        let operation;
        if (typeof query === 'string') {
            // Save the original query string in the context
            actionContext = actionContext.set(context_entries_1.KeysInitQuery.queryString, query);
            const queryParseOutput = await this.actorInitQuery.mediatorQueryParse
                .mediate({ context: actionContext, query, queryFormat, baseIRI });
            operation = queryParseOutput.operation;
            // Update the baseIRI in the context if the query modified it.
            if (queryParseOutput.baseIRI) {
                actionContext = actionContext.set(context_entries_1.KeysInitQuery.baseIRI, queryParseOutput.baseIRI);
            }
        }
        else {
            operation = query;
        }
        // Print parsed query
        if (explainMode === 'parsed') {
            return {
                explain: true,
                type: explainMode,
                data: operation,
            };
        }
        // Apply initial bindings in context
        if (actionContext.has(context_entries_1.KeysInitQuery.initialBindings)) {
            operation = (0, bus_query_operation_1.materializeOperation)(operation, actionContext.get(context_entries_1.KeysInitQuery.initialBindings));
            // Delete the query string from the context, since our initial query might have changed
            actionContext = actionContext.delete(context_entries_1.KeysInitQuery.queryString);
        }
        // Optimize the query operation
        const mediatorResult = await this.actorInitQuery.mediatorOptimizeQueryOperation
            .mediate({ context: actionContext, operation });
        operation = mediatorResult.operation;
        actionContext = mediatorResult.context || actionContext;
        // Print logical query plan
        if (explainMode === 'logical') {
            return {
                explain: true,
                type: explainMode,
                data: operation,
            };
        }
        // Save original query in context
        actionContext = actionContext.set(context_entries_1.KeysInitQuery.query, operation);
        // If we need a physical query plan, store a physical query plan logger in the context, and collect it after exec
        let physicalQueryPlanLogger;
        if (explainMode === 'physical') {
            physicalQueryPlanLogger = new MemoryPhysicalQueryPlanLogger_1.MemoryPhysicalQueryPlanLogger();
            actionContext = actionContext.set(context_entries_1.KeysInitQuery.physicalQueryPlanLogger, physicalQueryPlanLogger);
        }
        // Execute query
        const output = await this.actorInitQuery.mediatorQueryOperation.mediate({
            context: actionContext,
            operation,
        });
        output.context = actionContext;
        const finalOutput = QueryEngineBase.internalToFinalResult(output);
        // Output physical query plan after query exec if needed
        if (physicalQueryPlanLogger) {
            // Make sure the whole result is produced
            switch (finalOutput.resultType) {
                case 'bindings':
                    await (await finalOutput.execute()).toArray();
                    break;
                case 'quads':
                    await (await finalOutput.execute()).toArray();
                    break;
                case 'boolean':
                    await finalOutput.execute();
                    break;
                case 'void':
                    await finalOutput.execute();
                    break;
            }
            return {
                explain: true,
                type: explainMode,
                data: physicalQueryPlanLogger.toJson(),
            };
        }
        return finalOutput;
    }
    /**
     * @param context An optional context.
     * @return {Promise<{[p: string]: number}>} All available SPARQL (weighted) result media types.
     */
    async getResultMediaTypes(context) {
        context = core_1.ActionContext.ensureActionContext(context);
        return (await this.actorInitQuery.mediatorQueryResultSerializeMediaTypeCombiner
            .mediate({ context, mediaTypes: true })).mediaTypes;
    }
    /**
     * @param context An optional context.
     * @return {Promise<{[p: string]: number}>} All available SPARQL result media type formats.
     */
    async getResultMediaTypeFormats(context) {
        context = core_1.ActionContext.ensureActionContext(context);
        return (await this.actorInitQuery.mediatorQueryResultSerializeMediaTypeFormatCombiner
            .mediate({ context, mediaTypeFormats: true })).mediaTypeFormats;
    }
    /**
     * Convert a query result to a string stream based on a certain media type.
     * @param {IQueryOperationResult} queryResult A query result.
     * @param {string} mediaType A media type.
     * @param {ActionContext} context An optional context.
     * @return {Promise<IActorQueryResultSerializeOutput>} A text stream.
     */
    async resultToString(queryResult, mediaType, context) {
        context = core_1.ActionContext.ensureActionContext(context);
        if (!mediaType) {
            switch (queryResult.resultType) {
                case 'bindings':
                    mediaType = 'application/json';
                    break;
                case 'quads':
                    mediaType = 'application/trig';
                    break;
                default:
                    mediaType = 'simple';
                    break;
            }
        }
        const handle = { ...await QueryEngineBase.finalToInternalResult(queryResult), context };
        return (await this.actorInitQuery.mediatorQueryResultSerialize
            .mediate({ context, handle, handleMediaType: mediaType })).handle;
    }
    /**
     * Invalidate all internal caches related to the given page URL.
     * If no page URL is given, then all pages will be invalidated.
     * @param {string} url The page URL to invalidate.
     * @param context An optional ActionContext to pass to the actors.
     * @return {Promise<any>} A promise resolving when the caches have been invalidated.
     */
    invalidateHttpCache(url, context) {
        context = core_1.ActionContext.ensureActionContext(context);
        return this.actorInitQuery.mediatorHttpInvalidate.mediate({ url, context });
    }
    /**
     * Convert an internal query result to a final one.
     * @param internalResult An intermediary query result.
     */
    static internalToFinalResult(internalResult) {
        switch (internalResult.type) {
            case 'bindings':
                return {
                    resultType: 'bindings',
                    execute: async () => internalResult.bindingsStream,
                    metadata: async () => await internalResult.metadata(),
                    context: internalResult.context,
                };
            case 'quads':
                return {
                    resultType: 'quads',
                    execute: async () => internalResult.quadStream,
                    metadata: async () => await internalResult.metadata(),
                    context: internalResult.context,
                };
            case 'boolean':
                return {
                    resultType: 'boolean',
                    execute: async () => internalResult.execute(),
                    context: internalResult.context,
                };
            case 'void':
                return {
                    resultType: 'void',
                    execute: async () => internalResult.execute(),
                    context: internalResult.context,
                };
        }
    }
    /**
     * Convert a final query result to an internal one.
     * @param finalResult A final query result.
     */
    static async finalToInternalResult(finalResult) {
        switch (finalResult.resultType) {
            case 'bindings':
                return {
                    type: 'bindings',
                    bindingsStream: await finalResult.execute(),
                    metadata: async () => await finalResult.metadata(),
                };
            case 'quads':
                return {
                    type: 'quads',
                    quadStream: await finalResult.execute(),
                    metadata: async () => await finalResult.metadata(),
                };
            case 'boolean':
                return {
                    type: 'boolean',
                    execute: () => finalResult.execute(),
                };
            case 'void':
                return {
                    type: 'void',
                    execute: () => finalResult.execute(),
                };
        }
    }
}
exports.QueryEngineBase = QueryEngineBase;
//# sourceMappingURL=QueryEngineBase.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ActorRdfJoinOptionalBind = void 0;
const actor_rdf_join_inner_multi_bind_1 = require("@comunica/actor-rdf-join-inner-multi-bind");
const bus_query_operation_1 = require("@comunica/bus-query-operation");
const bus_rdf_join_1 = require("@comunica/bus-rdf-join");
const context_entries_1 = require("@comunica/context-entries");
const sparqlalgebrajs_1 = require("sparqlalgebrajs");
/**
 * A comunica Optional Bind RDF Join Actor.
 */
class ActorRdfJoinOptionalBind extends bus_rdf_join_1.ActorRdfJoin {
    constructor(args) {
        super(args, {
            logicalType: 'optional',
            physicalName: 'bind',
            limitEntries: 2,
            canHandleUndefs: true,
        });
    }
    async getOutput(action) {
        // Close the right stream, since we don't need that one
        action.entries[1].output.bindingsStream.close();
        // Bind the right pattern for each binding in the stream
        const subContext = action.context
            .set(context_entries_1.KeysQueryOperation.joinLeftMetadata, await action.entries[0].output.metadata())
            .set(context_entries_1.KeysQueryOperation.joinRightMetadatas, [await action.entries[1].output.metadata()]);
        const bindingsStream = actor_rdf_join_inner_multi_bind_1.ActorRdfJoinMultiBind.createBindStream(this.bindOrder, action.entries[0].output.bindingsStream, [action.entries[1].operation], async (operations, operationBindings) => {
            // Send the materialized patterns to the mediator for recursive join evaluation.
            // Length of operations will always be 1
            const operation = operations[0];
            const output = bus_query_operation_1.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({ operation, context: subContext?.set(context_entries_1.KeysQueryOperation.joinBindings, operationBindings) }));
            return output.bindingsStream;
        }, true);
        return {
            result: {
                type: 'bindings',
                bindingsStream,
                metadata: async () => await this.constructResultMetadata(action.entries, await bus_rdf_join_1.ActorRdfJoin.getMetadatas(action.entries), action.context, { canContainUndefs: true }),
            },
        };
    }
    async getJoinCoefficients(action, metadatas) {
        const requestInitialTimes = bus_rdf_join_1.ActorRdfJoin.getRequestInitialTimes(metadatas);
        const requestItemTimes = bus_rdf_join_1.ActorRdfJoin.getRequestItemTimes(metadatas);
        // Reject binding on some operation types
        if (action.entries[1].operation.type === sparqlalgebrajs_1.Algebra.types.EXTEND ||
            action.entries[1].operation.type === sparqlalgebrajs_1.Algebra.types.GROUP) {
            throw new Error(`Actor ${this.name} can not bind on Extend and Group operations`);
        }
        // Determine selectivity of join
        const selectivity = (await this.mediatorJoinSelectivity.mediate({
            entries: action.entries,
            context: action.context,
        })).selectivity * this.selectivityModifier;
        return {
            iterations: metadatas[0].cardinality.value * metadatas[1].cardinality.value * selectivity,
            persistedItems: 0,
            blockingItems: 0,
            requestTime: requestInitialTimes[0] +
                metadatas[0].cardinality.value * selectivity * (requestItemTimes[0] +
                    requestInitialTimes[1] +
                    metadatas[1].cardinality.value * requestItemTimes[1]),
        };
    }
}
exports.ActorRdfJoinOptionalBind = ActorRdfJoinOptionalBind;
//# sourceMappingURL=ActorRdfJoinOptionalBind.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ActorQueryOperationService = void 0;
const bindings_factory_1 = require("@comunica/bindings-factory");
const bus_query_operation_1 = require("@comunica/bus-query-operation");
const context_entries_1 = require("@comunica/context-entries");
const asynciterator_1 = require("asynciterator");
const BF = new bindings_factory_1.BindingsFactory();
/**
 * A comunica Service Query Operation Actor.
 * It unwraps the SERVICE operation and executes it on the given source.
 */
class ActorQueryOperationService extends bus_query_operation_1.ActorQueryOperationTypedMediated {
    constructor(args) {
        super(args, 'service');
    }
    async testOperation(operation, context) {
        if (operation.name.termType !== 'NamedNode') {
            throw new Error(`${this.name} can only query services by IRI, while a ${operation.name.termType} was given.`);
        }
        return true;
    }
    async runOperation(operation, context) {
        const endpoint = operation.name.value;
        // Adjust our context to only have the endpoint as source
        let subContext = context
            .delete(context_entries_1.KeysRdfResolveQuadPattern.source)
            .delete(context_entries_1.KeysRdfResolveQuadPattern.sources)
            .delete(context_entries_1.KeysInitQuery.queryString);
        const sourceType = this.forceSparqlEndpoint ? 'sparql' : undefined;
        subContext = subContext.set(context_entries_1.KeysRdfResolveQuadPattern.sources, [{ type: sourceType, value: endpoint }]);
        // Query the source
        let output;
        try {
            output = bus_query_operation_1.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({ operation: operation.input, context: subContext }));
        }
        catch (error) {
            if (operation.silent) {
                // Emit a single empty binding
                output = {
                    bindingsStream: new asynciterator_1.SingletonIterator(BF.bindings()),
                    type: 'bindings',
                    metadata: async () => ({ cardinality: { type: 'exact', value: 1 }, canContainUndefs: false, variables: [] }),
                };
            }
            else {
                throw error;
            }
        }
        return output;
    }
}
exports.ActorQueryOperationService = ActorQueryOperationService;
//# sourceMappingURL=ActorQueryOperationService.js.map
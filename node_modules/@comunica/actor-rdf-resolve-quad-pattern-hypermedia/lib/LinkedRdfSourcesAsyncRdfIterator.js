"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LinkedRdfSourcesAsyncRdfIterator = void 0;
const asynciterator_1 = require("asynciterator");
const LRUCache = require("lru-cache");
class LinkedRdfSourcesAsyncRdfIterator extends asynciterator_1.BufferedIterator {
    constructor(cacheSize, subject, predicate, object, graph, firstUrl, maxIterators) {
        super({ autoStart: true });
        this.started = false;
        this.cacheSize = cacheSize;
        this.subject = subject;
        this.predicate = predicate;
        this.object = object;
        this.graph = graph;
        this.firstUrl = firstUrl;
        this.maxIterators = maxIterators;
        if (this.maxIterators <= 0) {
            throw new Error(`LinkedRdfSourcesAsyncRdfIterator.maxIterators must be larger than zero, but got ${this.maxIterators}`);
        }
        this.currentIterators = [];
        this.iteratorsPendingCreation = 0;
    }
    _end(destroy) {
        // Close all running iterators
        for (const it of this.currentIterators) {
            it.destroy();
        }
        super._end(destroy);
    }
    /**
     * This method can optionally called after constructing an instance
     * for allowing the sources state to be cached.
     *
     * When calling without args, then the default logic will be followed to determine the sources state.
     * When calling with an arg, then the given sources state will be set instead of following the default logic.
     *
     * After calling this method, the `sourcesState` field can be retrieved and optionally cached.
     *
     * This sources state also contains a hash of all handled datasets that will be copied upon first use.
     *
     * @param {ISourcesState} sourcesState An optional sources state.
     */
    setSourcesState(sourcesState) {
        if (sourcesState) {
            this.sourcesState = sourcesState;
        }
        else {
            this.sourcesState = {
                sources: new LRUCache({ max: this.cacheSize }),
            };
            // Ignore the response, we just want the promise to be cached
            this.getSourceCached({ url: this.firstUrl }, {})
                .catch(error => this.destroy(error));
        }
    }
    /**
     * Resolve a source for the given URL.
     * This will first try to retrieve the source from cache.
     * @param link A source ILink.
     * @param handledDatasets A hash of dataset identifiers that have already been handled.
     */
    getSourceCached(link, handledDatasets) {
        let source = this.sourcesState.sources.get(link.url);
        if (source) {
            return source;
        }
        source = this.getSource(link, handledDatasets);
        this.sourcesState.sources.set(link.url, source);
        return source;
    }
    _read(count, done) {
        if (!this.started) {
            // The first time this is called, prepare the first source
            this.started = true;
            // Create a sources state if needed (can be defined if set from actor cache)
            if (!this.sourcesState) {
                this.setSourcesState();
            }
            // Await the source to be set, and start the source iterator
            this.getSourceCached({ url: this.firstUrl }, {})
                .then(sourceState => {
                this.startIterator(sourceState, true);
                done();
            })
                .catch(error => {
                // We can safely ignore this error, since it handled in setSourcesState
                done();
            });
        }
        else {
            // Read from all current iterators
            for (const iterator of this.currentIterators) {
                while (count > 0) {
                    const read = iterator.read();
                    if (read !== null) {
                        count--;
                        this._push(read);
                    }
                    else {
                        break;
                    }
                }
                if (count <= 0) {
                    break;
                }
            }
            // Schedule new iterators if needed
            if (count >= 0 && this.canStartNewIterator()) {
                this.getSourceCached({ url: this.firstUrl }, {})
                    .then(sourceState => {
                    this.startIteratorsForNextUrls(sourceState.handledDatasets, false);
                    done();
                })
                    .catch(error => this.destroy(error));
            }
            else {
                done();
            }
        }
    }
    canStartNewIterator() {
        return (this.currentIterators.length + this.iteratorsPendingCreation) < this.maxIterators && !this.readable;
    }
    areIteratorsRunning() {
        return (this.currentIterators.length + this.iteratorsPendingCreation) > 0;
    }
    /**
     * Start a new iterator for the given source.
     * Once the iterator is done, it will either determine a new source, or it will close the linked iterator.
     * @param {ISourceState} startSource The start source state.
     * @param {boolean} emitMetadata If the metadata event should be emitted.
     */
    startIterator(startSource, emitMetadata) {
        // Delegate the quad pattern query to the given source
        const iterator = startSource.source
            .match(this.subject, this.predicate, this.object, this.graph);
        this.currentIterators.push(iterator);
        let receivedMetadata = false;
        // Attach readers to the newly created iterator
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        iterator._destination = this;
        iterator.on('error', (error) => this.destroy(error));
        iterator.on('readable', () => this._fillBuffer());
        iterator.on('end', () => {
            this.currentIterators.splice(this.currentIterators.indexOf(iterator), 1);
            // If the metadata was already received, handle the next URL in the queue
            if (receivedMetadata) {
                this.startIteratorsForNextUrls(startSource.handledDatasets, true);
            }
        });
        // Listen for the metadata of the source
        // The metadata property is guaranteed to be set
        iterator.getProperty('metadata', (metadata) => {
            startSource.metadata = { ...startSource.metadata, ...metadata };
            // Emit metadata if needed
            if (emitMetadata) {
                this.setProperty('metadata', startSource.metadata);
            }
            // Determine next urls, which will eventually become a next-next source.
            this.getSourceLinks(startSource.metadata)
                .then((nextUrls) => Promise.all(nextUrls))
                .then(async (nextUrls) => {
                // Append all next URLs to our queue
                const linkQueue = await this.getLinkQueue();
                for (const nextUrl of nextUrls) {
                    linkQueue.push(nextUrl, startSource.link);
                }
                receivedMetadata = true;
                this.startIteratorsForNextUrls(startSource.handledDatasets, true);
            }).catch(error => this.destroy(error));
        });
    }
    /**
     * Check if a next URL is in the queue.
     * If yes, start a new iterator.
     * If no, close this iterator.
     * @param handledDatasets
     * @param canClose
     */
    startIteratorsForNextUrls(handledDatasets, canClose) {
        this.getLinkQueue()
            .then(linkQueue => {
            // Create as many new iterators as possible
            while (this.canStartNewIterator() && !this.done) {
                const nextLink = linkQueue.pop();
                if (nextLink) {
                    this.iteratorsPendingCreation++;
                    this.getSourceCached(nextLink, handledDatasets)
                        .then(nextSourceState => {
                        this.iteratorsPendingCreation--;
                        this.startIterator(nextSourceState, false);
                    })
                        .catch(error => this.destroy(error));
                }
                else {
                    break;
                }
            }
            // Close, only if no other iterators are still running
            if (canClose && linkQueue.isEmpty() && !this.areIteratorsRunning()) {
                this.close();
            }
        })
            .catch(error => this.destroy(error));
    }
}
exports.LinkedRdfSourcesAsyncRdfIterator = LinkedRdfSourcesAsyncRdfIterator;
//# sourceMappingURL=LinkedRdfSourcesAsyncRdfIterator.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ActorQueryOperationSparqlEndpoint = void 0;
const bindings_factory_1 = require("@comunica/bindings-factory");
const bus_query_operation_1 = require("@comunica/bus-query-operation");
const bus_rdf_resolve_quad_pattern_1 = require("@comunica/bus-rdf-resolve-quad-pattern");
const bus_rdf_update_quads_1 = require("@comunica/bus-rdf-update-quads");
const context_entries_1 = require("@comunica/context-entries");
const asynciterator_1 = require("asynciterator");
const fetch_sparql_endpoint_1 = require("fetch-sparql-endpoint");
const rdf_data_factory_1 = require("rdf-data-factory");
const sparqlalgebrajs_1 = require("sparqlalgebrajs");
const LazyCardinalityIterator_1 = require("./LazyCardinalityIterator");
const BF = new bindings_factory_1.BindingsFactory();
const DF = new rdf_data_factory_1.DataFactory();
/**
 * A comunica SPARQL Endpoint Query Operation Actor.
 */
class ActorQueryOperationSparqlEndpoint extends bus_query_operation_1.ActorQueryOperation {
    constructor(args) {
        super(args);
        this.endpointFetcher = new fetch_sparql_endpoint_1.SparqlEndpointFetcher({
            method: args.forceHttpGet ? 'GET' : 'POST',
            fetch: (input, init) => this.mediatorHttp.mediate({ input, init, context: this.lastContext }),
            prefixVariableQuestionMark: true,
        });
    }
    async test(action) {
        if (!action.operation) {
            throw new Error('Missing field \'operation\' in a query operation action.');
        }
        const source = (0, bus_rdf_resolve_quad_pattern_1.getContextSourceFirst)(action.context);
        const destination = (0, bus_rdf_update_quads_1.getContextDestinationFirst)(action.context);
        const sourceType = source ? (0, bus_rdf_resolve_quad_pattern_1.getDataSourceType)(source) : undefined;
        const destinationType = destination ? (0, bus_rdf_update_quads_1.getDataDestinationType)(destination) : undefined;
        const sourceValue = source ? (0, bus_rdf_resolve_quad_pattern_1.getDataSourceValue)(source) : undefined;
        const destinationValue = destination ? (0, bus_rdf_update_quads_1.getDataDestinationValue)(destination) : undefined;
        if ((source && sourceType === 'sparql' &&
            (!destination || (destinationType === 'sparql' && destinationValue === sourceValue))) ||
            (source && !sourceType && (!destination || (!destinationType && destinationValue === sourceValue)) &&
                typeof sourceValue === 'string' && ((this.checkUrlSuffixSparql && sourceValue.endsWith('/sparql')) ||
                (this.checkUrlSuffixUpdate && sourceValue.endsWith('/update'))))) {
            return { httpRequests: 1 };
        }
        throw new Error(`${this.name} requires a single source with a 'sparql' endpoint to be present in the context or URL ending on /sparql or /update.`);
    }
    async run(action) {
        const source = (0, bus_rdf_resolve_quad_pattern_1.getContextSourceFirst)(action.context);
        if (!source) {
            throw new Error('Illegal state: undefined sparql endpoint source.');
        }
        const endpoint = (0, bus_rdf_resolve_quad_pattern_1.getDataSourceValue)(source);
        this.lastContext = action.context;
        // Determine the full SPARQL query that needs to be sent to the endpoint
        // Also check the type of the query (SELECT, CONSTRUCT (includes DESCRIBE) or ASK)
        let query;
        let type;
        let variables;
        try {
            // Use the original query string if available
            query = action.context.get(context_entries_1.KeysInitQuery.queryString) ?? (0, sparqlalgebrajs_1.toSparql)(action.operation);
            // This will throw an error in case the result is an invalid SPARQL query
            type = this.endpointFetcher.getQueryType(query);
            // Also check if this is an update query
            if (type === 'UNKNOWN') {
                type = this.endpointFetcher.getUpdateTypes(query);
            }
        }
        catch {
            // Ignore errors
        }
        // If the input is an sub-query, wrap this in a SELECT
        if (!type || type === 'UNKNOWN') {
            variables = sparqlalgebrajs_1.Util.inScopeVariables(action.operation);
            query = (0, sparqlalgebrajs_1.toSparql)(ActorQueryOperationSparqlEndpoint.FACTORY.createProject(action.operation, variables));
            type = 'SELECT';
        }
        // Execute the query against the endpoint depending on the type
        switch (type) {
            case 'SELECT':
                if (!variables) {
                    variables = sparqlalgebrajs_1.Util.inScopeVariables(action.operation);
                }
                return this.executeQuery(endpoint, query, false, variables);
            case 'CONSTRUCT':
                return this.executeQuery(endpoint, query, true);
            case 'ASK':
                return {
                    type: 'boolean',
                    execute: () => this.endpointFetcher.fetchAsk(endpoint, query),
                };
            default:
                return {
                    type: 'void',
                    execute: () => this.endpointFetcher.fetchUpdate(endpoint, query),
                };
        }
    }
    /**
     * Execute the given SELECT or CONSTRUCT query against the given endpoint.
     * @param endpoint A SPARQL endpoint URL.
     * @param query A SELECT or CONSTRUCT query.
     * @param quads If the query returns quads, i.e., if it is a CONSTRUCT query.
     * @param variables Variables for SELECT queries.
     */
    executeQuery(endpoint, query, quads, variables) {
        const inputStream = quads ?
            this.endpointFetcher.fetchTriples(endpoint, query) :
            this.endpointFetcher.fetchBindings(endpoint, query);
        const stream = (0, asynciterator_1.wrap)(inputStream, { autoStart: false }).map(rawData => quads ?
            rawData :
            BF.bindings(Object.entries(rawData)
                .map(([key, value]) => [DF.variable(key.slice(1)), value])));
        const resultStream = new LazyCardinalityIterator_1.LazyCardinalityIterator(stream);
        const metadata = ActorQueryOperationSparqlEndpoint.cachifyMetadata(async () => ({
            cardinality: { type: 'exact', value: await resultStream.getCardinality() },
            canContainUndefs: true,
            variables,
        }));
        if (quads) {
            return {
                type: 'quads',
                quadStream: resultStream,
                metadata,
            };
        }
        return {
            type: 'bindings',
            bindingsStream: resultStream,
            metadata,
        };
    }
}
exports.ActorQueryOperationSparqlEndpoint = ActorQueryOperationSparqlEndpoint;
ActorQueryOperationSparqlEndpoint.FACTORY = new sparqlalgebrajs_1.Factory();
//# sourceMappingURL=ActorQueryOperationSparqlEndpoint.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LazyCardinalityIterator = void 0;
const asynciterator_1 = require("asynciterator");
/**
  An iterator that maintains an internal buffer of items.
  This class serves as a base class for other iterators
  with a typically complex item generation process.
  @extends module:asynciterator.AsyncIterator
*/
class LazyCardinalityIterator extends asynciterator_1.AsyncIterator {
    constructor(_source) {
        super();
        this._source = _source;
        this._count = 0;
        this._buffering = true;
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        _source[asynciterator_1.DESTINATION] = this;
        _source.on('readable', destinationSetReadable);
        _source.on('end', destinationSetReadable);
        _source.on('error', destinationEmitError);
        this.readable = _source.readable;
    }
    read() {
        if (this._buffer) {
            if (!this._buffer.empty) {
                return this._buffer.shift();
            }
            if (!this._buffering) {
                this.close();
            }
            this.readable = false;
            return null;
        }
        let item = null;
        // eslint-disable-next-line no-cond-assign
        if (this._source.readable && (item = this._source.read()) !== null) {
            this._count += 1;
        }
        else {
            this.readable = false;
            if (this._source.done) {
                this.close();
            }
        }
        return item;
    }
    getCardinality() {
        if (this._cardinality) {
            return this._cardinality;
        }
        if (this._error) {
            return Promise.reject(this._error);
        }
        if (this._source.done) {
            this.close();
        }
        if (this.done) {
            this._cardinality = Promise.resolve(this._count);
        }
        else {
            this._buffer = new asynciterator_1.LinkedList();
            this._cardinality = new Promise((resolve, reject) => {
                this._source.removeListener('readable', destinationSetReadable);
                this._source.removeListener('end', destinationSetReadable);
                const clean = () => {
                    this._source.removeListener('data', onData);
                    this._source.removeListener('end', onEnd);
                    this._source.removeListener('error', onError);
                };
                const onData = (data) => {
                    this._buffer.push(data);
                    this._count += 1;
                    this.readable = true;
                };
                const onEnd = () => {
                    this._buffering = false;
                    clean();
                    resolve(this._count);
                };
                const onError = (err) => {
                    this._buffering = false;
                    clean();
                    reject(err);
                };
                this._source.on('data', onData);
                this._source.on('end', onEnd);
                this._source.on('error', onError);
            });
        }
        return this._cardinality;
    }
    close() {
        this._source.removeListener('readable', destinationSetReadable);
        this._source.removeListener('end', destinationSetReadable);
        this._source.removeListener('error', destinationEmitError);
        delete this._source[asynciterator_1.DESTINATION];
        this._source.destroy();
        super.close();
    }
}
exports.LazyCardinalityIterator = LazyCardinalityIterator;
function destinationSetReadable() {
    this[asynciterator_1.DESTINATION].readable = true;
}
function destinationEmitError(error) {
    this[asynciterator_1.DESTINATION]._error = error;
    this[asynciterator_1.DESTINATION].emit('error', error);
}
//# sourceMappingURL=LazyCardinalityIterator.js.map
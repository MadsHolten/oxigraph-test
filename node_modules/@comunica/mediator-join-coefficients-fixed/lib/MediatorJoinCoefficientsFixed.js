"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MediatorJoinCoefficientsFixed = void 0;
const context_entries_1 = require("@comunica/context-entries");
const core_1 = require("@comunica/core");
/**
 * A mediator that mediates over actors implementing the Join Coefficients mediator type and assigns fixed weights
 * to calculate an overall score and pick the actor with the lowest score.
 */
class MediatorJoinCoefficientsFixed extends core_1.Mediator {
    constructor(args) {
        super(args);
    }
    async mediateWith(action, testResults) {
        // Obtain test results
        const errors = [];
        const promises = testResults
            .map(({ reply }) => reply)
            .map(promise => promise.catch(error => {
            errors.push(error);
        }));
        const coefficients = await Promise.all(promises);
        // Calculate costs
        let costs = coefficients
            // eslint-disable-next-line array-callback-return
            .map((coeff, i) => {
            if (coeff) {
                return coeff.iterations * this.cpuWeight +
                    coeff.persistedItems * this.memoryWeight +
                    coeff.blockingItems * this.timeWeight +
                    coeff.requestTime * this.ioWeight;
            }
        });
        const maxCost = Math.max(...costs.filter(cost => cost !== undefined));
        // If we have a limit indicator in the context,
        // increase cost of entries that have a number of iterations that is higher than the limit AND persist items.
        // In these cases, join operators that produce results early on will be preferred.
        const limitIndicator = action.context.get(context_entries_1.KeysQueryOperation.limitIndicator);
        if (limitIndicator) {
            costs = costs.map((cost, i) => {
                if (cost !== undefined && coefficients[i].persistedItems > 0 && coefficients[i].iterations > limitIndicator) {
                    return cost + maxCost;
                }
                return cost;
            });
        }
        // Determine index with lowest cost
        let minIndex = -1;
        let minValue = Number.POSITIVE_INFINITY;
        for (const [i, cost] of costs.entries()) {
            if (cost !== undefined && (minIndex === -1 || cost < minValue)) {
                minIndex = i;
                minValue = cost;
            }
        }
        // Reject if all actors rejected
        if (minIndex < 0) {
            throw new Error(`All actors rejected their test in ${this.name}\n${errors.map(error => error.message).join('\n')}`);
        }
        // Return actor with lowest cost
        const bestActor = testResults[minIndex].actor;
        // Emit calculations in logger
        if (bestActor.includeInLogs) {
            core_1.Actor.getContextLogger(action.context)?.debug(`Determined physical join operator '${bestActor.logicalType}-${bestActor.physicalName}'`, {
                entries: action.entries.length,
                variables: await Promise.all(action.entries
                    .map(async (entry) => (await entry.output.metadata()).variables.map(variable => variable.value))),
                costs: Object.fromEntries(costs.map((coeff, i) => [
                    `${testResults[i].actor.logicalType}-${testResults[i].actor.physicalName}`,
                    coeff,
                ])),
                coefficients: Object.fromEntries(coefficients.map((coeff, i) => [
                    `${testResults[i].actor.logicalType}-${testResults[i].actor.physicalName}`,
                    coeff,
                ])),
            });
        }
        return bestActor;
    }
}
exports.MediatorJoinCoefficientsFixed = MediatorJoinCoefficientsFixed;
//# sourceMappingURL=MediatorJoinCoefficientsFixed.js.map
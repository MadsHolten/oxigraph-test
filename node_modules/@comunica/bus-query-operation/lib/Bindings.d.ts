import type { Bindings } from '@comunica/types';
import type * as RDF from '@rdfjs/types';
import type { Algebra } from 'sparqlalgebrajs';
/**
 * Materialize a term with the given binding.
 *
 * If the given term is a variable,
 * and that variable exist in the given bindings object,
 * the value of that binding is returned.
 * In all other cases, the term itself is returned.
 *
 * @param {RDF.Term} term A term.
 * @param {Bindings} bindings A bindings object.
 * @return {RDF.Term} The materialized term.
 */
export declare function materializeTerm(term: RDF.Term, bindings: Bindings): RDF.Term;
/**
 * Materialize the given operation (recursively) with the given bindings.
 * Essentially, all variables in the given operation will be replaced
 * by the terms bound to the variables in the given bindings.
 * @param {Operation} operation SPARQL algebra operation.
 * @param {Bindings} bindings A bindings object.
 * @param options Options for materializations.
 * @return Algebra.Operation A new operation materialized with the given bindings.
 */
export declare function materializeOperation(operation: Algebra.Operation, bindings: Bindings, options?: {
    /**
     * If target variable bindings (such as on SELECT or BIND) should not be allowed.
     */
    strictTargetVariables?: boolean;
    /**
     * If filter expressions should be materialized
     */
    bindFilter?: boolean;
}): Algebra.Operation;

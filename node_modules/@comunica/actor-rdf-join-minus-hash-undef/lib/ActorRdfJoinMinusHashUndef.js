"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ActorRdfJoinMinusHashUndef = void 0;
const bus_query_operation_1 = require("@comunica/bus-query-operation");
const bus_rdf_join_1 = require("@comunica/bus-rdf-join");
const BindingsIndex_1 = require("./BindingsIndex");
/**
 * A comunica Minus Hash RDF Join Actor.
 */
class ActorRdfJoinMinusHashUndef extends bus_rdf_join_1.ActorRdfJoin {
    constructor(args) {
        super(args, {
            logicalType: 'minus',
            physicalName: 'hash-undef',
            limitEntries: 2,
            canHandleUndefs: true,
        });
    }
    async getOutput(action) {
        const buffer = action.entries[1].output;
        const output = action.entries[0].output;
        const metadatas = await bus_rdf_join_1.ActorRdfJoin.getMetadatas(action.entries);
        const commonVariables = bus_rdf_join_1.ActorRdfJoin.overlappingVariables(metadatas);
        if (commonVariables.length > 0) {
            /**
             * To assure we've filtered all B (`buffer`) values from A (`output`) we wait until we've fetched all values of B.
             * Then we save these triples in `index` and use it to filter our A-stream.
             */
            const index = new BindingsIndex_1.BindingsIndex(commonVariables);
            const bindingsStream = new bus_query_operation_1.ClosableTransformIterator(async () => {
                await new Promise(resolve => {
                    buffer.bindingsStream.on('data', data => index.add(data));
                    buffer.bindingsStream.on('end', resolve);
                });
                return output.bindingsStream.filter(data => !index.contains(data));
            }, {
                autoStart: false,
                onClose() {
                    buffer.bindingsStream.destroy();
                    output.bindingsStream.destroy();
                },
            });
            return {
                result: {
                    type: 'bindings',
                    bindingsStream,
                    async metadata() {
                        const bufferMetadata = await output.metadata();
                        const outputMetadata = await output.metadata();
                        return {
                            ...outputMetadata,
                            canContainUndefs: bufferMetadata.canContainUndefs || outputMetadata.canContainUndefs,
                        };
                    },
                },
            };
        }
        return {
            result: output,
        };
    }
    async getJoinCoefficients(action, metadatas) {
        const requestInitialTimes = bus_rdf_join_1.ActorRdfJoin.getRequestInitialTimes(metadatas);
        const requestItemTimes = bus_rdf_join_1.ActorRdfJoin.getRequestItemTimes(metadatas);
        return {
            // Slightly increase iteration cost, as operations in our BindingsIndex do not happen in constant time
            // This enables the mediator to favor other minus actors,
            // while this one will only be selected when streams contain undefs.
            iterations: (metadatas[0].cardinality.value + metadatas[1].cardinality.value) * 1.01,
            persistedItems: metadatas[0].cardinality.value,
            blockingItems: metadatas[0].cardinality.value,
            requestTime: requestInitialTimes[0] + metadatas[0].cardinality.value * requestItemTimes[0] +
                requestInitialTimes[1] + metadatas[1].cardinality.value * requestItemTimes[1],
        };
    }
}
exports.ActorRdfJoinMinusHashUndef = ActorRdfJoinMinusHashUndef;
//# sourceMappingURL=ActorRdfJoinMinusHashUndef.js.map
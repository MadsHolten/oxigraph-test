"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RdfSourceSparql = void 0;
const bindings_factory_1 = require("@comunica/bindings-factory");
const asynciterator_1 = require("asynciterator");
const fetch_sparql_endpoint_1 = require("fetch-sparql-endpoint");
const rdf_data_factory_1 = require("rdf-data-factory");
const rdf_terms_1 = require("rdf-terms");
const sparqlalgebrajs_1 = require("sparqlalgebrajs");
const DF = new rdf_data_factory_1.DataFactory();
const BF = new bindings_factory_1.BindingsFactory();
const VAR_COUNT = DF.variable('count');
class RdfSourceSparql {
    constructor(url, context, mediatorHttp, forceHttpGet) {
        this.url = url;
        this.context = context;
        this.mediatorHttp = mediatorHttp;
        this.endpointFetcher = new fetch_sparql_endpoint_1.SparqlEndpointFetcher({
            method: forceHttpGet ? 'GET' : 'POST',
            fetch: (input, init) => this.mediatorHttp.mediate({ input, init, context: this.context }),
            prefixVariableQuestionMark: true,
        });
    }
    /**
     * Replace all blank nodes in a pattern with variables.
     * If the pattern contains no blank nodes the original pattern gets returned.
     * @param {RDF.BaseQuad} pattern A quad pattern.
     * @return {RDF.BaseQuad} A quad pattern with no blank nodes.
     */
    static replaceBlankNodes(pattern) {
        const variableNames = (0, rdf_terms_1.getVariables)((0, rdf_terms_1.getTerms)(pattern)).map(variableTerm => variableTerm.value);
        // Track the names the blank nodes get mapped to (required if the name has to change)
        const blankMap = {};
        let changed = false;
        // For every position, convert to a variable if there is a blank node
        const result = (0, rdf_terms_1.mapTerms)(pattern, term => {
            if (term.termType === 'BlankNode') {
                let name = term.value;
                if (blankMap[name]) {
                    name = blankMap[name];
                }
                else {
                    if (variableNames.includes(name)) {
                        // Increase index added to name until we find one that is available (2 loops at most)
                        let idx = 0;
                        while (variableNames.includes(`${name}${idx}`)) {
                            ++idx;
                        }
                        name += idx;
                    }
                    blankMap[term.value] = name;
                    variableNames.push(name);
                }
                changed = true;
                return DF.variable(name);
            }
            return term;
        });
        return changed ? result : pattern;
    }
    /**
     * Convert a quad pattern to a BGP with only that pattern.
     * @param {RDF.pattern} quad A quad pattern.
     * @return {Bgp} A BGP.
     */
    static patternToBgp(pattern) {
        return RdfSourceSparql.FACTORY.createBgp([RdfSourceSparql.FACTORY
                .createPattern(pattern.subject, pattern.predicate, pattern.object, pattern.graph)]);
    }
    /**
     * Convert a quad pattern to a select query for this pattern.
     * @param {RDF.Quad} pattern A quad pattern.
     * @return {string} A select query string.
     */
    static patternToSelectQuery(pattern) {
        const variables = (0, rdf_terms_1.getVariables)((0, rdf_terms_1.getTerms)(pattern));
        return (0, sparqlalgebrajs_1.toSparql)(RdfSourceSparql.FACTORY.createProject(RdfSourceSparql.patternToBgp(pattern), variables));
    }
    /**
     * Convert a quad pattern to a count query for the number of matching triples for this pattern.
     * @param {RDF.Quad} pattern A quad pattern.
     * @return {string} A count query string.
     */
    static patternToCountQuery(pattern) {
        return (0, sparqlalgebrajs_1.toSparql)(RdfSourceSparql.FACTORY.createProject(RdfSourceSparql.FACTORY.createExtend(RdfSourceSparql.FACTORY.createGroup(RdfSourceSparql.patternToBgp(pattern), [], [RdfSourceSparql.FACTORY.createBoundAggregate(DF.variable('var0'), 'count', RdfSourceSparql.FACTORY.createWildcardExpression(), false)]), DF.variable('count'), RdfSourceSparql.FACTORY.createTermExpression(DF.variable('var0'))), [DF.variable('count')]));
    }
    /**
     * Send a SPARQL query to a SPARQL endpoint and retrieve its bindings as a stream.
     * @param {string} endpoint A SPARQL endpoint URL.
     * @param {string} query A SPARQL query string.
     * @return {BindingsStream} A stream of bindings.
     */
    queryBindings(endpoint, query) {
        const rawStream = this.endpointFetcher.fetchBindings(endpoint, query);
        return (0, asynciterator_1.wrap)(rawStream, { autoStart: false, maxBufferSize: Number.POSITIVE_INFINITY })
            .map((rawData) => BF.bindings(Object.entries(rawData)
            .map(([key, value]) => [DF.variable(key.slice(1)), value])));
    }
    match(subject, predicate, object, graph) {
        const pattern = RdfSourceSparql.replaceBlankNodes(RdfSourceSparql.FACTORY.createPattern(subject, predicate, object, graph));
        const countQuery = RdfSourceSparql.patternToCountQuery(pattern);
        const selectQuery = RdfSourceSparql.patternToSelectQuery(pattern);
        // Emit metadata containing the estimated count (reject is never called)
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        new Promise(resolve => {
            const bindingsStream = this.queryBindings(this.url, countQuery);
            bindingsStream.on('data', (bindings) => {
                const count = bindings.get(VAR_COUNT);
                if (count) {
                    const cardinality = Number.parseInt(count.value, 10);
                    if (Number.isNaN(cardinality)) {
                        return resolve({ cardinality: Number.POSITIVE_INFINITY });
                    }
                    return resolve({ cardinality });
                }
                return resolve({ cardinality: Number.POSITIVE_INFINITY });
            });
            bindingsStream.on('error', () => resolve({ cardinality: Number.POSITIVE_INFINITY }));
            bindingsStream.on('end', () => resolve({ cardinality: Number.POSITIVE_INFINITY }));
        })
            .then(metadata => quads.setProperty('metadata', { ...metadata, canContainUndefs: true }));
        // Materialize the queried pattern using each found binding.
        const quads = this.queryBindings(this.url, selectQuery)
            .map((bindings) => (0, rdf_terms_1.mapTerms)(pattern, (value) => {
            if (value.termType === 'Variable') {
                const boundValue = bindings.get(value);
                if (!boundValue) {
                    quads.destroy(new Error(`The endpoint ${this.url} failed to provide a binding for ${value.value}.`));
                }
                return boundValue;
            }
            return value;
        }));
        return quads;
    }
}
exports.RdfSourceSparql = RdfSourceSparql;
RdfSourceSparql.FACTORY = new sparqlalgebrajs_1.Factory();
//# sourceMappingURL=RdfSourceSparql.js.map
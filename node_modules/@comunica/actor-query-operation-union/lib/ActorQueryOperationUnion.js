"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ActorQueryOperationUnion = void 0;
const bus_query_operation_1 = require("@comunica/bus-query-operation");
const asynciterator_1 = require("asynciterator");
const rdf_terms_1 = require("rdf-terms");
/**
 * A comunica Union Query Operation Actor.
 */
class ActorQueryOperationUnion extends bus_query_operation_1.ActorQueryOperationTypedMediated {
    constructor(args) {
        super(args, 'union');
    }
    /**
     * Takes the union of the given double array variables.
     * Uniqueness is guaranteed.
     * @param {string[][]} variables Double array of variables to take the union of.
     * @return {string[]} The union of the given variables.
     */
    static unionVariables(variables) {
        return (0, rdf_terms_1.uniqTerms)(variables.flat());
    }
    /**
     * Takes the union of the given metadata array.
     * It will ensure that the cardinality metadata value is properly calculated.
     * @param {{[p: string]: any}[]} metadatas Array of metadata.
     * @param bindings If the union of the variables field should also be taken.
     * @return {{[p: string]: any}} Union of the metadata.
     */
    static unionMetadata(metadatas, bindings) {
        // Union cardinality
        const cardinality = { type: 'exact', value: 0 };
        for (const metadata of metadatas) {
            if ((metadata.cardinality.value && Number.isFinite(metadata.cardinality.value)) ||
                metadata.cardinality.value === 0) {
                if (metadata.cardinality.type === 'estimate') {
                    cardinality.type = 'estimate';
                }
                cardinality.value += metadata.cardinality.value;
            }
            else {
                cardinality.type = 'estimate';
                cardinality.value = Number.POSITIVE_INFINITY;
                break;
            }
        }
        const metadataBase = {
            cardinality,
            canContainUndefs: metadatas.some(metadata => metadata.canContainUndefs),
        };
        // Union variables
        if (bindings) {
            metadataBase.variables = ActorQueryOperationUnion.unionVariables(metadatas.map(metadata => metadata.variables));
            return metadataBase;
        }
        return metadataBase;
    }
    async testOperation(operation, context) {
        return true;
    }
    async runOperation(operation, context) {
        const outputs = (await Promise.all(operation.input
            .map(subOperation => this.mediatorQueryOperation.mediate({ operation: subOperation, context }))))
            .map(bus_query_operation_1.ActorQueryOperation.getSafeBindings);
        const bindingsStream = new asynciterator_1.UnionIterator(outputs.map((output) => output.bindingsStream), { autoStart: false });
        const metadata = () => Promise.all(outputs.map(output => output.metadata()))
            .then(subMeta => ActorQueryOperationUnion.unionMetadata(subMeta, true));
        return { type: 'bindings', bindingsStream, metadata };
    }
}
exports.ActorQueryOperationUnion = ActorQueryOperationUnion;
//# sourceMappingURL=ActorQueryOperationUnion.js.map
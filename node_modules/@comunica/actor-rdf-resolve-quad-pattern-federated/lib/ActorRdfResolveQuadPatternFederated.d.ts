import type { IActionRdfResolveQuadPattern, IActorRdfResolveQuadPatternArgs, IQuadSource, MediatorRdfResolveQuadPattern } from '@comunica/bus-rdf-resolve-quad-pattern';
import { ActorRdfResolveQuadPatternSource } from '@comunica/bus-rdf-resolve-quad-pattern';
import type { IActorTest } from '@comunica/core';
import type { IActionContext, IDataSource } from '@comunica/types';
import type * as RDF from '@rdfjs/types';
/**
 * A comunica Federated RDF Resolve Quad Pattern Actor.
 */
export declare class ActorRdfResolveQuadPatternFederated extends ActorRdfResolveQuadPatternSource implements IActorRdfResolveQuadPatternFederatedArgs {
    readonly mediatorResolveQuadPattern: MediatorRdfResolveQuadPattern;
    readonly skipEmptyPatterns: boolean;
    protected readonly emptyPatterns: Map<IDataSource, RDF.Quad[]>;
    constructor(args: IActorRdfResolveQuadPatternFederatedArgs);
    test(action: IActionRdfResolveQuadPattern): Promise<IActorTest>;
    protected getSource(context: IActionContext): Promise<IQuadSource>;
}
export interface IActorRdfResolveQuadPatternFederatedArgs extends IActorRdfResolveQuadPatternArgs {
    /**
     * The quad pattern resolve mediator.
     */
    mediatorResolveQuadPattern: MediatorRdfResolveQuadPattern;
    /**
     * If quad patterns that are sub-patterns of empty quad patterns should be skipped.
     * This assumes that sources remain static during query evaluation.
     * @default {false}
     */
    skipEmptyPatterns?: boolean;
}

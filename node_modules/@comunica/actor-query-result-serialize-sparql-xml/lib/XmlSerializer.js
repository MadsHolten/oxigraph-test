"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.XmlSerializer = void 0;
/**
 * A very simple XML serializer
 */
class XmlSerializer {
    constructor(push) {
        this.stack = [];
        this.push = push;
        this.push(`<?xml version="1.0" encoding="UTF-8"?>\n`);
    }
    /**
       *
       * @param name should be a valid XML tag name
       * @param attributes keys should be valid attribute names
       */
    open(name, attributes) {
        this.push(`${this.identation() + this.formatTag(name, attributes, 'open')}\n`);
        this.stack.push(name);
    }
    close() {
        const name = this.stack.pop();
        if (name === undefined) {
            throw new Error('There is no tag left to close');
        }
        this.push(`${this.identation() + this.formatTag(name, {}, 'close')}\n`);
    }
    add(node) {
        this.push(this.serializeNode(node));
    }
    serializeNode(node) {
        if (node.children === undefined) {
            return `${this.identation() + this.formatTag(node.name, node.attributes, 'self-closing')}\n`;
        }
        if (typeof node.children === 'string') {
            return `${this.identation() + this.formatTag(node.name, node.attributes, 'open') + this.escape(node.children) + this.formatTag(node.name, {}, 'close')}\n`;
        }
        const parts = [];
        parts.push(`${this.identation() + this.formatTag(node.name, node.attributes, 'open')}\n`);
        this.stack.push(node.name);
        for (const child of node.children) {
            parts.push(this.serializeNode(child));
        }
        this.stack.pop();
        parts.push(`${this.identation() + this.formatTag(node.name, {}, 'close')}\n`);
        return parts.join('');
    }
    identation() {
        return this.stack.map(_ => '  ').join('');
    }
    formatTag(name, attributes, state) {
        return `<${state === 'close' ? '/' : ''}${name}${Object.entries(attributes || {}).map(attr => ` ${attr[0]}="${this.escape(attr[1])}"`)}${state === 'self-closing' ? '/' : ''}>`;
    }
    escape(text) {
        return text.replace(/["&'<>]/gu, (char) => {
            switch (char) {
                case '<': return '&lt;';
                case '>': return '&gt;';
                case '&': return '&amp;';
                case '\'': return '&apos;';
                case '"': return '&quot;';
            }
        });
    }
}
exports.XmlSerializer = XmlSerializer;
//# sourceMappingURL=XmlSerializer.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ActorQueryResultSerializeSparqlXml = void 0;
const bus_query_result_serialize_1 = require("@comunica/bus-query-result-serialize");
const readable_stream_1 = require("readable-stream");
const XmlSerializer_1 = require("./XmlSerializer");
/**
 * A comunica sparql-results+xml Serialize Actor.
 */
class ActorQueryResultSerializeSparqlXml extends bus_query_result_serialize_1.ActorQueryResultSerializeFixedMediaTypes {
    /**
     * @param args -
     *   \ @defaultNested {{
     *       "application/sparql-results+xml": 0.8
     *     }} mediaTypePriorities
     *   \ @defaultNested {{
     *       "application/sparql-results+xml": "http://www.w3.org/ns/formats/SPARQL_Results_XML"
     *     }} mediaTypeFormats
     */
    constructor(args) {
        super(args);
    }
    /**
     * Converts an RDF term to its object-based XML representation.
     * @param {RDF.Term} value An RDF term.
     * @param {string} key A variable name, '?' must be included as a prefix.
     * @return {IXmlNode} An object-based XML tag.
     */
    static bindingToXmlBindings(value, key) {
        return { name: 'binding', attributes: { name: key.value }, children: [this.valueToXmlValue(value)] };
    }
    static valueToXmlValue(value) {
        let attributes;
        switch (value.termType) {
            case 'Literal':
                if (value.language) {
                    attributes = { 'xml:lang': value.language };
                }
                else if (value.datatype && value.datatype.value !== 'http://www.w3.org/2001/XMLSchema#string') {
                    attributes = { datatype: value.datatype.value };
                }
                else {
                    attributes = {};
                }
                return { name: 'literal', attributes, children: value.value };
            case 'BlankNode':
                return { name: 'bnode', children: value.value };
            default:
                return { name: 'uri', children: value.value };
        }
    }
    async testHandleChecked(action, context) {
        if (!['bindings', 'boolean'].includes(action.type)) {
            throw new Error('This actor can only handle bindings streams or booleans.');
        }
        return true;
    }
    async runHandle(action, mediaType, context) {
        const data = new readable_stream_1.Readable();
        data._read = () => {
            // Do nothing
        };
        // Write head
        const serializer = new XmlSerializer_1.XmlSerializer(chunk => data.push(chunk));
        serializer.open('sparql', { xmlns: 'http://www.w3.org/2005/sparql-results#' });
        const metadata = await action.metadata();
        serializer.add({
            name: 'head',
            children: metadata.variables.map(variable => ({ name: 'variable', attributes: { name: variable.value } })),
        });
        if (action.type === 'bindings') {
            serializer.open('results');
            const resultStream = action.bindingsStream;
            // Write bindings
            resultStream.on('error', (error) => {
                data.emit('error', error);
            });
            resultStream.on('data', (bindings) => {
                // XML SPARQL results spec does not allow unbound variables and blank node bindings
                serializer.add({ name: 'result',
                    children: [...bindings]
                        .map(([key, value]) => ActorQueryResultSerializeSparqlXml.bindingToXmlBindings(value, key)) });
            });
            // Close streams
            resultStream.on('end', () => {
                serializer.close();
                serializer.close();
                setTimeout(() => data.push(null));
            });
        }
        else {
            try {
                const result = await action.execute();
                serializer.add({ name: 'boolean', children: result.toString() });
                serializer.close();
                setTimeout(() => data.push(null));
            }
            catch (error) {
                setTimeout(() => data.emit('error', error));
            }
        }
        return { data };
    }
}
exports.ActorQueryResultSerializeSparqlXml = ActorQueryResultSerializeSparqlXml;
//# sourceMappingURL=ActorQueryResultSerializeSparqlXml.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Bindings = void 0;
const immutable_1 = require("immutable");
const bindingsToString_1 = require("./bindingsToString");
/**
 * An immutable.js-based Bindings object.
 */
class Bindings {
    constructor(dataFactory, entries) {
        this.type = 'bindings';
        this.dataFactory = dataFactory;
        this.entries = entries;
    }
    has(key) {
        return this.entries.has(typeof key === 'string' ? key : key.value);
    }
    get(key) {
        return this.entries.get(typeof key === 'string' ? key : key.value);
    }
    set(key, value) {
        return new Bindings(this.dataFactory, this.entries.set(typeof key === 'string' ? key : key.value, value));
    }
    delete(key) {
        return new Bindings(this.dataFactory, this.entries.delete(typeof key === 'string' ? key : key.value));
    }
    keys() {
        return this.mapIterable(this.iteratorToIterable(this.entries.keys()), key => this.dataFactory.variable(key));
    }
    values() {
        return this.iteratorToIterable(this.entries.values());
    }
    forEach(fn) {
        this.entries.forEach((value, key) => fn(value, this.dataFactory.variable(key)));
    }
    get size() {
        return this.entries.size;
    }
    [Symbol.iterator]() {
        return this.mapIterable(this.iteratorToIterable(this.entries.entries()), ([key, value]) => [this.dataFactory.variable(key), value])[Symbol.iterator]();
    }
    equals(other) {
        if (!other) {
            return false;
        }
        if (this === other) {
            return true;
        }
        // First check if size is equal
        if (this.size !== other.size) {
            return false;
        }
        // Then check if keys and values are equal
        for (const key of this.keys()) {
            if (!this.get(key)?.equals(other.get(key))) {
                return false;
            }
        }
        return true;
    }
    filter(fn) {
        return new Bindings(this.dataFactory, (0, immutable_1.Map)(this.entries
            .filter((value, key) => fn(value, this.dataFactory.variable(key)))));
    }
    map(fn) {
        return new Bindings(this.dataFactory, (0, immutable_1.Map)(this.entries
            .map((value, key) => fn(value, this.dataFactory.variable(key)))));
    }
    merge(other) {
        // Determine the union of keys
        const keys = new Set([
            ...this.iteratorToIterable(this.entries.keys()),
            ...[...other.keys()].map(key => key.value),
        ]);
        // Collect entries
        const entries = [];
        for (const key of keys) {
            const left = this.entries.get(key);
            const right = other.get(this.dataFactory.variable(key));
            if (left && right && !left.equals(right)) {
                return;
            }
            const value = left || right;
            entries.push([key, value]);
        }
        return new Bindings(this.dataFactory, (0, immutable_1.Map)(entries));
    }
    mergeWith(merger, other) {
        // Determine the union of keys
        const keys = new Set([
            ...this.iteratorToIterable(this.entries.keys()),
            ...[...other.keys()].map(key => key.value),
        ]);
        // Collect entries
        const entries = [];
        for (const key of keys) {
            const variable = this.dataFactory.variable(key);
            const left = this.entries.get(key);
            const right = other.get(variable);
            let value;
            if (left && right && !left.equals(right)) {
                value = merger(left, right, variable);
            }
            else {
                value = left || right;
            }
            entries.push([key, value]);
        }
        return new Bindings(this.dataFactory, (0, immutable_1.Map)(entries));
    }
    toString() {
        return (0, bindingsToString_1.bindingsToString)(this);
    }
    *mapIterable(iterable, callback) {
        for (const x of iterable) {
            // eslint-disable-next-line callback-return
            yield callback(x);
        }
    }
    iteratorToIterable(iterator) {
        return {
            [Symbol.iterator]: () => iterator,
        };
    }
}
exports.Bindings = Bindings;
//# sourceMappingURL=Bindings.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.QuadDestinationSparql = void 0;
const fetch_sparql_endpoint_1 = require("fetch-sparql-endpoint");
const rdf_string_ttl_1 = require("rdf-string-ttl");
const stringifyStream = require('stream-to-string');
/**
 * A quad destination that represents an LDP resource.
 */
class QuadDestinationSparql {
    constructor(url, context, mediatorHttp) {
        this.url = url;
        this.context = context;
        this.mediatorHttp = mediatorHttp;
        this.endpointFetcher = new fetch_sparql_endpoint_1.SparqlEndpointFetcher({
            fetch: (input, init) => this.mediatorHttp.mediate({ input, init, context: this.context }),
            prefixVariableQuestionMark: true,
        });
    }
    insert(quads) {
        return this.wrapSparqlUpdateRequest('INSERT', quads);
    }
    async delete(quads) {
        return this.wrapSparqlUpdateRequest('DELETE', quads);
    }
    async wrapSparqlUpdateRequest(type, quads) {
        // Wrap triples in DATA block
        const dataWrapped = quads
            .map((quad) => {
            let stringQuad = `${(0, rdf_string_ttl_1.termToString)(quad.subject)} ${(0, rdf_string_ttl_1.termToString)(quad.predicate)} ${(0, rdf_string_ttl_1.termToString)(quad.object)} .`;
            if (quad.graph.termType !== 'DefaultGraph') {
                stringQuad = `  GRAPH ${(0, rdf_string_ttl_1.termToString)(quad.graph)} { ${stringQuad} }\n`;
            }
            else {
                stringQuad = `  ${stringQuad}\n`;
            }
            return stringQuad;
        })
            .prepend([`${type} DATA {\n`])
            .append(['}']);
        // Serialize query stream to string
        const query = await stringifyStream(dataWrapped);
        // Send update query to endpoint
        await this.endpointFetcher.fetchUpdate(this.url, query);
    }
    async deleteGraphs(graphsIn, requireExistence, dropGraphs) {
        const graphs = Array.isArray(graphsIn) ?
            graphsIn :
            [graphsIn];
        const queries = [];
        for (const graph of graphs) {
            let graphValue;
            if (typeof graph === 'string') {
                graphValue = graph;
            }
            else if (graph.termType === 'DefaultGraph') {
                graphValue = 'DEFAULT';
            }
            else {
                graphValue = `GRAPH <${graph.value}>`;
            }
            queries.push(`${dropGraphs ? 'DROP' : 'CLEAR'} ${requireExistence ? '' : 'SILENT '}${graphValue}`);
        }
        await this.endpointFetcher.fetchUpdate(this.url, queries.join('; '));
    }
    async createGraphs(graphs, requireNonExistence) {
        const queries = [];
        for (const graph of graphs) {
            queries.push(`CREATE${requireNonExistence ? '' : ' SILENT'} GRAPH <${graph.value}>`);
        }
        await this.endpointFetcher.fetchUpdate(this.url, queries.join('; '));
    }
}
exports.QuadDestinationSparql = QuadDestinationSparql;
//# sourceMappingURL=QuadDestinationSparql.js.map
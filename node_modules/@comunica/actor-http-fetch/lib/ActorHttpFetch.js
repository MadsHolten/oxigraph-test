"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ActorHttpFetch = void 0;
const bus_http_1 = require("@comunica/bus-http");
const context_entries_1 = require("@comunica/context-entries");
require("cross-fetch/polyfill");
const FetchInitPreprocessor_1 = require("./FetchInitPreprocessor");
/**
 * A node-fetch actor that listens on the 'init' bus.
 *
 * It will call `fetch` with either action.input or action.url.
 */
class ActorHttpFetch extends bus_http_1.ActorHttp {
    constructor(args) {
        super(args);
        this.userAgent = ActorHttpFetch.createUserAgent();
        this.fetchInitPreprocessor = new FetchInitPreprocessor_1.FetchInitPreprocessor(args.agentOptions);
    }
    static createUserAgent() {
        return `Comunica/actor-http-fetch (${typeof global.navigator === 'undefined' ?
            `Node.js ${process.version}; ${process.platform}` :
            `Browser-${global.navigator.userAgent}`})`;
    }
    async test(action) {
        return { time: Number.POSITIVE_INFINITY };
    }
    async run(action) {
        // Prepare headers
        const initHeaders = action.init?.headers ?? {};
        action.init = action.init ?? {};
        action.init.headers = new Headers(initHeaders);
        if (!action.init.headers.has('user-agent')) {
            action.init.headers.append('user-agent', this.userAgent);
        }
        const authString = action.context.get(context_entries_1.KeysHttp.auth);
        if (authString) {
            action.init.headers.append('Authorization', `Basic ${Buffer.from(authString).toString('base64')}`);
        }
        // Log request
        this.logInfo(action.context, `Requesting ${typeof action.input === 'string' ?
            action.input :
            action.input.url}`, () => ({
            headers: bus_http_1.ActorHttp.headersToHash(new Headers(action.init.headers)),
            method: action.init.method || 'GET',
        }));
        // TODO: remove this workaround once this has a fix: https://github.com/inrupt/solid-client-authn-js/issues/1708
        if (action.init?.headers && 'append' in action.init.headers && action.context.has(context_entries_1.KeysHttp.fetch)) {
            action.init.headers = bus_http_1.ActorHttp.headersToHash(action.init.headers);
        }
        let requestInit = { ...action.init };
        if (action.context.get(context_entries_1.KeysHttp.includeCredentials)) {
            requestInit.credentials = 'include';
        }
        const httpTimeout = action.context?.get(context_entries_1.KeysHttp.httpTimeout);
        let requestTimeout;
        let onTimeout;
        if (httpTimeout !== undefined) {
            const controller = await this.fetchInitPreprocessor.createAbortController();
            requestInit.signal = controller.signal;
            onTimeout = () => controller.abort();
            requestTimeout = setTimeout(() => onTimeout(), httpTimeout);
        }
        try {
            requestInit = await this.fetchInitPreprocessor.handle(requestInit);
            // Perform request
            const customFetch = action
                .context?.get(context_entries_1.KeysHttp.fetch);
            const response = await (customFetch || fetch)(action.input, requestInit);
            // We remove or update the timeout
            if (requestTimeout !== undefined) {
                const httpBodyTimeout = action.context?.get(context_entries_1.KeysHttp.httpBodyTimeout) || false;
                if (httpBodyTimeout && response.body) {
                    onTimeout = () => response.body?.cancel(new Error(`HTTP timeout when reading the body of ${response.url}.
This error can be disabled by modifying the 'httpBodyTimeout' and/or 'httpTimeout' options.`));
                    response.body.on('close', () => {
                        clearTimeout(requestTimeout);
                    });
                }
                else {
                    clearTimeout(requestTimeout);
                }
            }
            // Node-fetch does not support body.cancel, while it is mandatory according to the fetch and readablestream api.
            // If it doesn't exist, we monkey-patch it.
            if (response.body && !response.body.cancel) {
                response.body.cancel = async (error) => {
                    response.body.destroy(error);
                    if (requestTimeout !== undefined) {
                        // We make sure to remove the timeout if it is still enabled
                        clearTimeout(requestTimeout);
                    }
                };
            }
            return response;
        }
        catch (error) {
            if (requestTimeout !== undefined) {
                clearTimeout(requestTimeout);
            }
            throw error;
        }
    }
}
exports.ActorHttpFetch = ActorHttpFetch;
//# sourceMappingURL=ActorHttpFetch.js.map